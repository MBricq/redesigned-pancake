
AVRASM ver. 2.2.8  C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\main.asm Wed May 12 09:58:18 2021

[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.1.130\avrasm\inc\m128def.inc'
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\main.asm(1): Including file 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\Libraries\macros.asm'
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\main.asm(2): Including file 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\Libraries\definitions.asm'
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\main.asm(18): Including file 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\temp.asm'
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\temp.asm(5): Including file 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\Libraries\math_speed.asm'
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\temp.asm(6): Including file 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\Libraries\lcd.asm'
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\temp.asm(7): Including file 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\Libraries\wire1.asm'
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\temp.asm(8): Including file 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\Libraries\printf.asm'
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\temp.asm(9): Including file 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\moteur.asm'
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\moteur.asm(7): Including file 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\macro_projet.asm'
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\main.asm(19): Including file 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\remote.asm'
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\main.asm(20): Including file 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\Libraries\eeprom.asm'
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\main.asm(21): Including file 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\affichage.asm'
[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.1.130\avrasm\inc\m128def.inc'
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\main.asm(1): Including file 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\Libraries\macros.asm'
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\main.asm(2): Including file 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\Libraries\definitions.asm'
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\main.asm(18): Including file 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\temp.asm'
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\temp.asm(5): Including file 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\Libraries\math_speed.asm'
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\temp.asm(6): Including file 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\Libraries\lcd.asm'
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\temp.asm(7): Including file 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\Libraries\wire1.asm'
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\temp.asm(8): Including file 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\Libraries\printf.asm'
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\temp.asm(9): Including file 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\moteur.asm'
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\moteur.asm(7): Including file 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\macro_projet.asm'
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\main.asm(19): Including file 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\remote.asm'
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\main.asm(20): Including file 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\Libraries\eeprom.asm'
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\main.asm(21): Including file 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\affichage.asm'
                                 
                                 .include	"Libraries\macros.asm"		; include macro definitions
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega128.xml ***********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m128def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega128
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega128
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M128DEF_INC_
                                 #define _M128DEF_INC_
                                 
                                 
                                 #pragma partinc 0
                                 
                                 ; ***** SPECIFY DEVICE ***************************************************
                                 .device ATmega128
                                 #pragma AVRPART ADMIN PART_NAME ATmega128
                                 .equ	SIGNATURE_000	= 0x1e
                                 .equ	SIGNATURE_001	= 0x97
                                 .equ	SIGNATURE_002	= 0x02
                                 
                                 #pragma AVRPART CORE CORE_VERSION V2E
                                 
                                 
                                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                                 ; NOTE:
                                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                                 ; and cannot be used with IN/OUT instructions
                                 .equ	UCSR1C	= 0x9d	; MEMORY MAPPED
                                 .equ	UDR1	= 0x9c	; MEMORY MAPPED
                                 .equ	UCSR1A	= 0x9b	; MEMORY MAPPED
                                 .equ	UCSR1B	= 0x9a	; MEMORY MAPPED
                                 .equ	UBRR1H	= 0x98	; MEMORY MAPPED
                                 .equ	UBRR1L	= 0x99	; MEMORY MAPPED
                                 .equ	UCSR0C	= 0x95	; MEMORY MAPPED
                                 .equ	UBRR0H	= 0x90	; MEMORY MAPPED
                                 .equ	TCCR3C	= 0x8c	; MEMORY MAPPED
                                 .equ	TCCR3A	= 0x8b	; MEMORY MAPPED
                                 .equ	TCCR3B	= 0x8a	; MEMORY MAPPED
                                 .equ	TCNT3L	= 0x88	; MEMORY MAPPED
                                 .equ	TCNT3H	= 0x89	; MEMORY MAPPED
                                 .equ	OCR3AL	= 0x86	; MEMORY MAPPED
                                 .equ	OCR3AH	= 0x87	; MEMORY MAPPED
                                 .equ	OCR3BL	= 0x84	; MEMORY MAPPED
                                 .equ	OCR3BH	= 0x85	; MEMORY MAPPED
                                 .equ	OCR3CL	= 0x82	; MEMORY MAPPED
                                 .equ	OCR3CH	= 0x83	; MEMORY MAPPED
                                 .equ	ICR3L	= 0x80	; MEMORY MAPPED
                                 .equ	ICR3H	= 0x81	; MEMORY MAPPED
                                 .equ	ETIMSK	= 0x7d	; MEMORY MAPPED
                                 .equ	ETIFR	= 0x7c	; MEMORY MAPPED
                                 .equ	TCCR1C	= 0x7a	; MEMORY MAPPED
                                 .equ	OCR1CL	= 0x78	; MEMORY MAPPED
                                 .equ	OCR1CH	= 0x79	; MEMORY MAPPED
                                 .equ	TWCR	= 0x74	; MEMORY MAPPED
                                 .equ	TWDR	= 0x73	; MEMORY MAPPED
                                 .equ	TWAR	= 0x72	; MEMORY MAPPED
                                 .equ	TWSR	= 0x71	; MEMORY MAPPED
                                 .equ	TWBR	= 0x70	; MEMORY MAPPED
                                 .equ	OSCCAL	= 0x6f	; MEMORY MAPPED
                                 .equ	XMCRA	= 0x6d	; MEMORY MAPPED
                                 .equ	XMCRB	= 0x6c	; MEMORY MAPPED
                                 .equ	EICRA	= 0x6a	; MEMORY MAPPED
                                 .equ	SPMCSR	= 0x68	; MEMORY MAPPED
                                 .equ	PORTG	= 0x65	; MEMORY MAPPED
                                 .equ	DDRG	= 0x64	; MEMORY MAPPED
                                 .equ	PING	= 0x63	; MEMORY MAPPED
                                 .equ	PORTF	= 0x62	; MEMORY MAPPED
                                 .equ	DDRF	= 0x61	; MEMORY MAPPED
                                 .equ	SREG	= 0x3f
                                 .equ	SPL	= 0x3d
                                 .equ	SPH	= 0x3e
                                 .equ	XDIV	= 0x3c
                                 .equ	RAMPZ	= 0x3b
                                 .equ	EICRB	= 0x3a
                                 .equ	EIMSK	= 0x39
                                 .equ	EIFR	= 0x38
                                 .equ	TIMSK	= 0x37
                                 .equ	TIFR	= 0x36
                                 .equ	MCUCR	= 0x35
                                 .equ	MCUCSR	= 0x34
                                 .equ	TCCR0	= 0x33
                                 .equ	TCNT0	= 0x32
                                 .equ	OCR0	= 0x31
                                 .equ	ASSR	= 0x30
                                 .equ	TCCR1A	= 0x2f
                                 .equ	TCCR1B	= 0x2e
                                 .equ	TCNT1L	= 0x2c
                                 .equ	TCNT1H	= 0x2d
                                 .equ	OCR1AL	= 0x2a
                                 .equ	OCR1AH	= 0x2b
                                 .equ	OCR1BL	= 0x28
                                 .equ	OCR1BH	= 0x29
                                 .equ	ICR1L	= 0x26
                                 .equ	ICR1H	= 0x27
                                 .equ	TCCR2	= 0x25
                                 .equ	TCNT2	= 0x24
                                 .equ	OCR2	= 0x23
                                 .equ	OCDR	= 0x22
                                 .equ	WDTCR	= 0x21
                                 .equ	SFIOR	= 0x20
                                 .equ	EEARL	= 0x1e
                                 .equ	EEARH	= 0x1f
                                 .equ	EEDR	= 0x1d
                                 .equ	EECR	= 0x1c
                                 .equ	PORTA	= 0x1b
                                 .equ	DDRA	= 0x1a
                                 .equ	PINA	= 0x19
                                 .equ	PORTB	= 0x18
                                 .equ	DDRB	= 0x17
                                 .equ	PINB	= 0x16
                                 .equ	PORTC	= 0x15
                                 .equ	DDRC	= 0x14
                                 .equ	PINC	= 0x13
                                 .equ	PORTD	= 0x12
                                 .equ	DDRD	= 0x11
                                 .equ	PIND	= 0x10
                                 .equ	SPDR	= 0x0f
                                 .equ	SPSR	= 0x0e
                                 .equ	SPCR	= 0x0d
                                 .equ	UDR0	= 0x0c
                                 .equ	UCSR0A	= 0x0b
                                 .equ	UCSR0B	= 0x0a
                                 .equ	UBRR0L	= 0x09
                                 .equ	ACSR	= 0x08
                                 .equ	ADMUX	= 0x07
                                 .equ	ADCSRA	= 0x06
                                 .equ	ADCH	= 0x05
                                 .equ	ADCL	= 0x04
                                 .equ	PORTE	= 0x03
                                 .equ	DDRE	= 0x02
                                 .equ	PINE	= 0x01
                                 .equ	PINF	= 0x00
                                 
                                 
                                 ; ***** BIT DEFINITIONS **************************************************
                                 
                                 ; ***** ANALOG_COMPARATOR ************
                                 ; SFIOR - Special Function IO Register
                                 .equ	ACME	= 3	; Analog Comparator Multiplexer Enable
                                 
                                 ; ACSR - Analog Comparator Control And Status Register
                                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                                 .equ	ACO	= 5	; Analog Compare Output
                                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                                 .equ	ACD	= 7	; Analog Comparator Disable
                                 
                                 
                                 ; ***** SPI **************************
                                 ; SPDR - SPI Data Register
                                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                                 
                                 ; SPSR - SPI Status Register
                                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                                 .equ	WCOL	= 6	; Write Collision Flag
                                 .equ	SPIF	= 7	; SPI Interrupt Flag
                                 
                                 ; SPCR - SPI Control Register
                                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                                 .equ	CPHA	= 2	; Clock Phase
                                 .equ	CPOL	= 3	; Clock polarity
                                 .equ	MSTR	= 4	; Master/Slave Select
                                 .equ	DORD	= 5	; Data Order
                                 .equ	SPE	= 6	; SPI Enable
                                 .equ	SPIE	= 7	; SPI Interrupt Enable
                                 
                                 
                                 ; ***** TWI **************************
                                 ; TWBR - TWI Bit Rate register
                                 .equ	I2BR	= TWBR	; For compatibility
                                 .equ	TWBR0	= 0	; 
                                 .equ	TWBR1	= 1	; 
                                 .equ	TWBR2	= 2	; 
                                 .equ	TWBR3	= 3	; 
                                 .equ	TWBR4	= 4	; 
                                 .equ	TWBR5	= 5	; 
                                 .equ	TWBR6	= 6	; 
                                 .equ	TWBR7	= 7	; 
                                 
                                 ; TWCR - TWI Control Register
                                 .equ	I2CR	= TWCR	; For compatibility
                                 .equ	TWIE	= 0	; TWI Interrupt Enable
                                 .equ	I2IE	= TWIE	; For compatibility
                                 .equ	TWEN	= 2	; TWI Enable Bit
                                 .equ	I2EN	= TWEN	; For compatibility
                                 .equ	ENI2C	= TWEN	; For compatibility
                                 .equ	TWWC	= 3	; TWI Write Collition Flag
                                 .equ	I2WC	= TWWC	; For compatibility
                                 .equ	TWSTO	= 4	; TWI Stop Condition Bit
                                 .equ	I2STO	= TWSTO	; For compatibility
                                 .equ	TWSTA	= 5	; TWI Start Condition Bit
                                 .equ	I2STA	= TWSTA	; For compatibility
                                 .equ	TWEA	= 6	; TWI Enable Acknowledge Bit
                                 .equ	I2EA	= TWEA	; For compatibility
                                 .equ	TWINT	= 7	; TWI Interrupt Flag
                                 .equ	I2INT	= TWINT	; For compatibility
                                 
                                 ; TWSR - TWI Status Register
                                 .equ	I2SR	= TWSR	; For compatibility
                                 .equ	TWPS0	= 0	; TWI Prescaler
                                 .equ	TWS0	= TWPS0	; For compatibility
                                 .equ	I2GCE	= TWPS0	; For compatibility
                                 .equ	TWPS1	= 1	; TWI Prescaler
                                 .equ	TWS1	= TWPS1	; For compatibility
                                 .equ	TWS3	= 3	; TWI Status
                                 .equ	I2S3	= TWS3	; For compatibility
                                 .equ	TWS4	= 4	; TWI Status
                                 .equ	I2S4	= TWS4	; For compatibility
                                 .equ	TWS5	= 5	; TWI Status
                                 .equ	I2S5	= TWS5	; For compatibility
                                 .equ	TWS6	= 6	; TWI Status
                                 .equ	I2S6	= TWS6	; For compatibility
                                 .equ	TWS7	= 7	; TWI Status
                                 .equ	I2S7	= TWS7	; For compatibility
                                 
                                 ; TWDR - TWI Data register
                                 .equ	I2DR	= TWDR	; For compatibility
                                 .equ	TWD0	= 0	; TWI Data Register Bit 0
                                 .equ	TWD1	= 1	; TWI Data Register Bit 1
                                 .equ	TWD2	= 2	; TWI Data Register Bit 2
                                 .equ	TWD3	= 3	; TWI Data Register Bit 3
                                 .equ	TWD4	= 4	; TWI Data Register Bit 4
                                 .equ	TWD5	= 5	; TWI Data Register Bit 5
                                 .equ	TWD6	= 6	; TWI Data Register Bit 6
                                 .equ	TWD7	= 7	; TWI Data Register Bit 7
                                 
                                 ; TWAR - TWI (Slave) Address register
                                 .equ	I2AR	= TWAR	; For compatibility
                                 .equ	TWGCE	= 0	; TWI General Call Recognition Enable Bit
                                 .equ	TWA0	= 1	; TWI (Slave) Address register Bit 0
                                 .equ	TWA1	= 2	; TWI (Slave) Address register Bit 1
                                 .equ	TWA2	= 3	; TWI (Slave) Address register Bit 2
                                 .equ	TWA3	= 4	; TWI (Slave) Address register Bit 3
                                 .equ	TWA4	= 5	; TWI (Slave) Address register Bit 4
                                 .equ	TWA5	= 6	; TWI (Slave) Address register Bit 5
                                 .equ	TWA6	= 7	; TWI (Slave) Address register Bit 6
                                 
                                 
                                 ; ***** USART0 ***********************
                                 ; UDR0 - USART I/O Data Register
                                 .equ	UDR00	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR01	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR02	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR03	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR04	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR05	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR06	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR07	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR0A - USART Control and Status Register A
                                 .equ	MPCM0	= 0	; Multi-processor Communication Mode
                                 .equ	U2X0	= 1	; Double the USART transmission speed
                                 .equ	UPE0	= 2	; Parity Error
                                 .equ	DOR0	= 3	; Data overRun
                                 .equ	FE0	= 4	; Framing Error
                                 .equ	UDRE0	= 5	; USART Data Register Empty
                                 .equ	TXC0	= 6	; USART Transmitt Complete
                                 .equ	RXC0	= 7	; USART Receive Complete
                                 
                                 ; UCSR0B - USART Control and Status Register B
                                 .equ	TXB80	= 0	; Transmit Data Bit 8
                                 .equ	RXB80	= 1	; Receive Data Bit 8
                                 .equ	UCSZ02	= 2	; Character Size
                                 .equ	UCSZ2	= UCSZ02	; For compatibility
                                 .equ	TXEN0	= 3	; Transmitter Enable
                                 .equ	RXEN0	= 4	; Receiver Enable
                                 .equ	UDRIE0	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE0	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE0	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR0C - USART Control and Status Register C
                                 .equ	UCPOL0	= 0	; Clock Polarity
                                 .equ	UCSZ00	= 1	; Character Size
                                 .equ	UCSZ01	= 2	; Character Size
                                 .equ	USBS0	= 3	; Stop Bit Select
                                 .equ	UPM00	= 4	; Parity Mode Bit 0
                                 .equ	UPM01	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL0	= 6	; USART Mode Select
                                 
                                 ; UBRR0H - USART Baud Rate Register Hight Byte
                                 .equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 .equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 .equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 .equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR0L - USART Baud Rate Register Low Byte
                                 .equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                                 .equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                                 .equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                                 .equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                                 .equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                                 .equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                                 .equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                                 .equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** USART1 ***********************
                                 ; UDR1 - USART I/O Data Register
                                 .equ	UDR10	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR11	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR12	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR13	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR14	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR15	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR16	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR17	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR1A - USART Control and Status Register A
                                 .equ	MPCM1	= 0	; Multi-processor Communication Mode
                                 .equ	U2X1	= 1	; Double the USART transmission speed
                                 .equ	UPE1	= 2	; Parity Error
                                 .equ	DOR1	= 3	; Data overRun
                                 .equ	FE1	= 4	; Framing Error
                                 .equ	UDRE1	= 5	; USART Data Register Empty
                                 .equ	TXC1	= 6	; USART Transmitt Complete
                                 .equ	RXC1	= 7	; USART Receive Complete
                                 
                                 ; UCSR1B - USART Control and Status Register B
                                 .equ	TXB81	= 0	; Transmit Data Bit 8
                                 .equ	RXB81	= 1	; Receive Data Bit 8
                                 .equ	UCSZ12	= 2	; Character Size
                                 .equ	TXEN1	= 3	; Transmitter Enable
                                 .equ	RXEN1	= 4	; Receiver Enable
                                 .equ	UDRIE1	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE1	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE1	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR1C - USART Control and Status Register C
                                 .equ	UCPOL1	= 0	; Clock Polarity
                                 .equ	UCSZ10	= 1	; Character Size
                                 .equ	UCSZ11	= 2	; Character Size
                                 .equ	USBS1	= 3	; Stop Bit Select
                                 .equ	UPM10	= 4	; Parity Mode Bit 0
                                 .equ	UPM11	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL1	= 6	; USART Mode Select
                                 
                                 ; UBRR1H - USART Baud Rate Register Hight Byte
                                 ;.equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 ;.equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 ;.equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 ;.equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR1L - USART Baud Rate Register Low Byte
                                 ;.equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                                 ;.equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                                 ;.equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                                 ;.equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                                 ;.equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                                 ;.equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                                 ;.equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                                 ;.equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** CPU **************************
                                 ; SREG - Status Register
                                 .equ	SREG_C	= 0	; Carry Flag
                                 .equ	SREG_Z	= 1	; Zero Flag
                                 .equ	SREG_N	= 2	; Negative Flag
                                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                                 .equ	SREG_S	= 4	; Sign Bit
                                 .equ	SREG_H	= 5	; Half Carry Flag
                                 .equ	SREG_T	= 6	; Bit Copy Storage
                                 .equ	SREG_I	= 7	; Global Interrupt Enable
                                 
                                 ; MCUCR - MCU Control Register
                                 .equ	IVCE	= 0	; Interrupt Vector Change Enable
                                 .equ	IVSEL	= 1	; Interrupt Vector Select
                                 .equ	SM2	= 2	; Sleep Mode Select
                                 .equ	SM0	= 3	; Sleep Mode Select
                                 .equ	SM1	= 4	; Sleep Mode Select
                                 .equ	SE	= 5	; Sleep Enable
                                 .equ	SRW10	= 6	; External SRAM Wait State Select
                                 .equ	SRE	= 7	; External SRAM Enable
                                 
                                 ; XMCRA - External Memory Control Register A
                                 .equ	SRW11	= 1	; Wait state select bit upper page
                                 .equ	SRW00	= 2	; Wait state select bit lower page
                                 .equ	SRW01	= 3	; Wait state select bit lower page
                                 .equ	SRL0	= 4	; Wait state page limit
                                 .equ	SRL1	= 5	; Wait state page limit
                                 .equ	SRL2	= 6	; Wait state page limit
                                 
                                 ; XMCRB - External Memory Control Register B
                                 .equ	XMM0	= 0	; External Memory High Mask
                                 .equ	XMM1	= 1	; External Memory High Mask
                                 .equ	XMM2	= 2	; External Memory High Mask
                                 .equ	XMBK	= 7	; External Memory Bus Keeper Enable
                                 
                                 ; OSCCAL - Oscillator Calibration Value
                                 .equ	CAL0	= 0	; Oscillator Calibration Value
                                 .equ	CAL1	= 1	; Oscillator Calibration Value
                                 .equ	CAL2	= 2	; Oscillator Calibration Value
                                 .equ	CAL3	= 3	; Oscillator Calibration Value
                                 .equ	CAL4	= 4	; Oscillator Calibration Value
                                 .equ	CAL5	= 5	; Oscillator Calibration Value
                                 .equ	CAL6	= 6	; Oscillator Calibration Value
                                 .equ	CAL7	= 7	; Oscillator Calibration Value
                                 
                                 ; XDIV - XTAL Divide Control Register
                                 .equ	XDIV0	= 0	; XTAl Divide Select Bit 0
                                 .equ	XDIV1	= 1	; XTAl Divide Select Bit 1
                                 .equ	XDIV2	= 2	; XTAl Divide Select Bit 2
                                 .equ	XDIV3	= 3	; XTAl Divide Select Bit 3
                                 .equ	XDIV4	= 4	; XTAl Divide Select Bit 4
                                 .equ	XDIV5	= 5	; XTAl Divide Select Bit 5
                                 .equ	XDIV6	= 6	; XTAl Divide Select Bit 6
                                 .equ	XDIVEN	= 7	; XTAL Divide Enable
                                 
                                 ; MCUCSR - MCU Control And Status Register
                                 .equ	PORF	= 0	; Power-on reset flag
                                 .equ	EXTRF	= 1	; External Reset Flag
                                 .equ	BORF	= 2	; Brown-out Reset Flag
                                 .equ	WDRF	= 3	; Watchdog Reset Flag
                                 .equ	JTRF	= 4	; JTAG Reset Flag
                                 .equ	JTD	= 7	; JTAG Interface Disable
                                 
                                 ; RAMPZ - RAM Page Z Select Register
                                 .equ	RAMPZ0	= 0	; RAM Page Z Select Register Bit 0
                                 
                                 
                                 ; ***** BOOT_LOAD ********************
                                 ; SPMCSR - Store Program Memory Control Register
                                 .equ	SPMCR	= SPMCSR	; For compatibility
                                 .equ	SPMEN	= 0	; Store Program Memory Enable
                                 .equ	PGERS	= 1	; Page Erase
                                 .equ	PGWRT	= 2	; Page Write
                                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                                 .equ	RWWSRE	= 4	; Read While Write section read enable
                                 .equ	ASRE	= RWWSRE	; For compatibility
                                 .equ	RWWSB	= 6	; Read While Write Section Busy
                                 .equ	ASB	= RWWSB	; For compatibility
                                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                                 
                                 
                                 ; ***** JTAG *************************
                                 ; OCDR - On-Chip Debug Related Register in I/O Memory
                                 .equ	OCDR0	= 0	; On-Chip Debug Register Bit 0
                                 .equ	OCDR1	= 1	; On-Chip Debug Register Bit 1
                                 .equ	OCDR2	= 2	; On-Chip Debug Register Bit 2
                                 .equ	OCDR3	= 3	; On-Chip Debug Register Bit 3
                                 .equ	OCDR4	= 4	; On-Chip Debug Register Bit 4
                                 .equ	OCDR5	= 5	; On-Chip Debug Register Bit 5
                                 .equ	OCDR6	= 6	; On-Chip Debug Register Bit 6
                                 .equ	OCDR7	= 7	; On-Chip Debug Register Bit 7
                                 .equ	IDRD	= OCDR7	; For compatibility
                                 
                                 ; MCUCSR - MCU Control And Status Register
                                 ;.equ	JTRF	= 4	; JTAG Reset Flag
                                 ;.equ	JTD	= 7	; JTAG Interface Disable
                                 
                                 
                                 ; ***** MISC *************************
                                 ; SFIOR - Special Function IO Register
                                 .equ	PSR321	= 0	; Prescaler Reset Timer/Counter3, Timer/Counter2, and Timer/Counter1
                                 .equ	PSR1	= PSR321	; For compatibility
                                 .equ	PSR2	= PSR321	; For compatibility
                                 .equ	PSR3	= PSR321	; For compatibility
                                 .equ	PSR0	= 1	; Prescaler Reset Timer/Counter0
                                 .equ	PUD	= 2	; Pull Up Disable
                                 ;.equ	ACME	= 3	; Analog Comparator Multiplexer Enable
                                 .equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** EXTERNAL_INTERRUPT ***********
                                 ; EICRA - External Interrupt Control Register A
                                 .equ	ISC00	= 0	; External Interrupt Sense Control Bit
                                 .equ	ISC01	= 1	; External Interrupt Sense Control Bit
                                 .equ	ISC10	= 2	; External Interrupt Sense Control Bit
                                 .equ	ISC11	= 3	; External Interrupt Sense Control Bit
                                 .equ	ISC20	= 4	; External Interrupt Sense Control Bit
                                 .equ	ISC21	= 5	; External Interrupt Sense Control Bit
                                 .equ	ISC30	= 6	; External Interrupt Sense Control Bit
                                 .equ	ISC31	= 7	; External Interrupt Sense Control Bit
                                 
                                 ; EICRB - External Interrupt Control Register B
                                 .equ	ISC40	= 0	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC41	= 1	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC50	= 2	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC51	= 3	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC60	= 4	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC61	= 5	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC70	= 6	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC71	= 7	; External Interrupt 7-4 Sense Control Bit
                                 
                                 ; EIMSK - External Interrupt Mask Register
                                 .equ	GICR	= EIMSK	; For compatibility
                                 .equ	GIMSK	= EIMSK	; For compatibility
                                 .equ	INT0	= 0	; External Interrupt Request 0 Enable
                                 .equ	INT1	= 1	; External Interrupt Request 1 Enable
                                 .equ	INT2	= 2	; External Interrupt Request 2 Enable
                                 .equ	INT3	= 3	; External Interrupt Request 3 Enable
                                 .equ	INT4	= 4	; External Interrupt Request 4 Enable
                                 .equ	INT5	= 5	; External Interrupt Request 5 Enable
                                 .equ	INT6	= 6	; External Interrupt Request 6 Enable
                                 .equ	INT7	= 7	; External Interrupt Request 7 Enable
                                 
                                 ; EIFR - External Interrupt Flag Register
                                 .equ	GIFR	= EIFR	; For compatibility
                                 .equ	INTF0	= 0	; External Interrupt Flag 0
                                 .equ	INTF1	= 1	; External Interrupt Flag 1
                                 .equ	INTF2	= 2	; External Interrupt Flag 2
                                 .equ	INTF3	= 3	; External Interrupt Flag 3
                                 .equ	INTF4	= 4	; External Interrupt Flag 4
                                 .equ	INTF5	= 5	; External Interrupt Flag 5
                                 .equ	INTF6	= 6	; External Interrupt Flag 6
                                 .equ	INTF7	= 7	; External Interrupt Flag 7
                                 
                                 
                                 ; ***** EEPROM ***********************
                                 ; EEDR - EEPROM Data Register
                                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                                 
                                 ; EECR - EEPROM Control Register
                                 .equ	EERE	= 0	; EEPROM Read Enable
                                 .equ	EEWE	= 1	; EEPROM Write Enable
                                 .equ	EEMWE	= 2	; EEPROM Master Write Enable
                                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                                 
                                 
                                 ; ***** PORTA ************************
                                 ; PORTA - Port A Data Register
                                 .equ	PORTA0	= 0	; Port A Data Register bit 0
                                 .equ	PA0	= 0	; For compatibility
                                 .equ	PORTA1	= 1	; Port A Data Register bit 1
                                 .equ	PA1	= 1	; For compatibility
                                 .equ	PORTA2	= 2	; Port A Data Register bit 2
                                 .equ	PA2	= 2	; For compatibility
                                 .equ	PORTA3	= 3	; Port A Data Register bit 3
                                 .equ	PA3	= 3	; For compatibility
                                 .equ	PORTA4	= 4	; Port A Data Register bit 4
                                 .equ	PA4	= 4	; For compatibility
                                 .equ	PORTA5	= 5	; Port A Data Register bit 5
                                 .equ	PA5	= 5	; For compatibility
                                 .equ	PORTA6	= 6	; Port A Data Register bit 6
                                 .equ	PA6	= 6	; For compatibility
                                 .equ	PORTA7	= 7	; Port A Data Register bit 7
                                 .equ	PA7	= 7	; For compatibility
                                 
                                 ; DDRA - Port A Data Direction Register
                                 .equ	DDA0	= 0	; Data Direction Register, Port A, bit 0
                                 .equ	DDA1	= 1	; Data Direction Register, Port A, bit 1
                                 .equ	DDA2	= 2	; Data Direction Register, Port A, bit 2
                                 .equ	DDA3	= 3	; Data Direction Register, Port A, bit 3
                                 .equ	DDA4	= 4	; Data Direction Register, Port A, bit 4
                                 .equ	DDA5	= 5	; Data Direction Register, Port A, bit 5
                                 .equ	DDA6	= 6	; Data Direction Register, Port A, bit 6
                                 .equ	DDA7	= 7	; Data Direction Register, Port A, bit 7
                                 
                                 ; PINA - Port A Input Pins
                                 .equ	PINA0	= 0	; Input Pins, Port A bit 0
                                 .equ	PINA1	= 1	; Input Pins, Port A bit 1
                                 .equ	PINA2	= 2	; Input Pins, Port A bit 2
                                 .equ	PINA3	= 3	; Input Pins, Port A bit 3
                                 .equ	PINA4	= 4	; Input Pins, Port A bit 4
                                 .equ	PINA5	= 5	; Input Pins, Port A bit 5
                                 .equ	PINA6	= 6	; Input Pins, Port A bit 6
                                 .equ	PINA7	= 7	; Input Pins, Port A bit 7
                                 
                                 
                                 ; ***** PORTB ************************
                                 ; PORTB - Port B Data Register
                                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                                 .equ	PB0	= 0	; For compatibility
                                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                                 .equ	PB1	= 1	; For compatibility
                                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                                 .equ	PB2	= 2	; For compatibility
                                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                                 .equ	PB3	= 3	; For compatibility
                                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                                 .equ	PB4	= 4	; For compatibility
                                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                                 .equ	PB5	= 5	; For compatibility
                                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                                 .equ	PB6	= 6	; For compatibility
                                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                                 .equ	PB7	= 7	; For compatibility
                                 
                                 ; DDRB - Port B Data Direction Register
                                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                                 
                                 ; PINB - Port B Input Pins
                                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                                 
                                 
                                 ; ***** PORTC ************************
                                 ; PORTC - Port C Data Register
                                 .equ	PORTC0	= 0	; Port C Data Register bit 0
                                 .equ	PC0	= 0	; For compatibility
                                 .equ	PORTC1	= 1	; Port C Data Register bit 1
                                 .equ	PC1	= 1	; For compatibility
                                 .equ	PORTC2	= 2	; Port C Data Register bit 2
                                 .equ	PC2	= 2	; For compatibility
                                 .equ	PORTC3	= 3	; Port C Data Register bit 3
                                 .equ	PC3	= 3	; For compatibility
                                 .equ	PORTC4	= 4	; Port C Data Register bit 4
                                 .equ	PC4	= 4	; For compatibility
                                 .equ	PORTC5	= 5	; Port C Data Register bit 5
                                 .equ	PC5	= 5	; For compatibility
                                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                                 .equ	PC6	= 6	; For compatibility
                                 .equ	PORTC7	= 7	; Port C Data Register bit 7
                                 .equ	PC7	= 7	; For compatibility
                                 
                                 ; DDRC - Port C Data Direction Register
                                 .equ	DDC0	= 0	; Port C Data Direction Register bit 0
                                 .equ	DDC1	= 1	; Port C Data Direction Register bit 1
                                 .equ	DDC2	= 2	; Port C Data Direction Register bit 2
                                 .equ	DDC3	= 3	; Port C Data Direction Register bit 3
                                 .equ	DDC4	= 4	; Port C Data Direction Register bit 4
                                 .equ	DDC5	= 5	; Port C Data Direction Register bit 5
                                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                                 .equ	DDC7	= 7	; Port C Data Direction Register bit 7
                                 
                                 ; PINC - Port C Input Pins
                                 .equ	PINC0	= 0	; Port C Input Pins bit 0
                                 .equ	PINC1	= 1	; Port C Input Pins bit 1
                                 .equ	PINC2	= 2	; Port C Input Pins bit 2
                                 .equ	PINC3	= 3	; Port C Input Pins bit 3
                                 .equ	PINC4	= 4	; Port C Input Pins bit 4
                                 .equ	PINC5	= 5	; Port C Input Pins bit 5
                                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                                 .equ	PINC7	= 7	; Port C Input Pins bit 7
                                 
                                 
                                 ; ***** PORTD ************************
                                 ; PORTD - Port D Data Register
                                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                                 .equ	PD0	= 0	; For compatibility
                                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                                 .equ	PD1	= 1	; For compatibility
                                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                                 .equ	PD2	= 2	; For compatibility
                                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                                 .equ	PD3	= 3	; For compatibility
                                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                                 .equ	PD4	= 4	; For compatibility
                                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                                 .equ	PD5	= 5	; For compatibility
                                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                                 .equ	PD6	= 6	; For compatibility
                                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                                 .equ	PD7	= 7	; For compatibility
                                 
                                 ; DDRD - Port D Data Direction Register
                                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                                 
                                 ; PIND - Port D Input Pins
                                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                                 
                                 
                                 ; ***** PORTE ************************
                                 ; PORTE - Data Register, Port E
                                 .equ	PORTE0	= 0	; 
                                 .equ	PE0	= 0	; For compatibility
                                 .equ	PORTE1	= 1	; 
                                 .equ	PE1	= 1	; For compatibility
                                 .equ	PORTE2	= 2	; 
                                 .equ	PE2	= 2	; For compatibility
                                 .equ	PORTE3	= 3	; 
                                 .equ	PE3	= 3	; For compatibility
                                 .equ	PORTE4	= 4	; 
                                 .equ	PE4	= 4	; For compatibility
                                 .equ	PORTE5	= 5	; 
                                 .equ	PE5	= 5	; For compatibility
                                 .equ	PORTE6	= 6	; 
                                 .equ	PE6	= 6	; For compatibility
                                 .equ	PORTE7	= 7	; 
                                 .equ	PE7	= 7	; For compatibility
                                 
                                 ; DDRE - Data Direction Register, Port E
                                 .equ	DDE0	= 0	; 
                                 .equ	DDE1	= 1	; 
                                 .equ	DDE2	= 2	; 
                                 .equ	DDE3	= 3	; 
                                 .equ	DDE4	= 4	; 
                                 .equ	DDE5	= 5	; 
                                 .equ	DDE6	= 6	; 
                                 .equ	DDE7	= 7	; 
                                 
                                 ; PINE - Input Pins, Port E
                                 .equ	PINE0	= 0	; 
                                 .equ	PINE1	= 1	; 
                                 .equ	PINE2	= 2	; 
                                 .equ	PINE3	= 3	; 
                                 .equ	PINE4	= 4	; 
                                 .equ	PINE5	= 5	; 
                                 .equ	PINE6	= 6	; 
                                 .equ	PINE7	= 7	; 
                                 
                                 
                                 ; ***** PORTF ************************
                                 ; PORTF - Data Register, Port F
                                 .equ	PORTF0	= 0	; 
                                 .equ	PF0	= 0	; For compatibility
                                 .equ	PORTF1	= 1	; 
                                 .equ	PF1	= 1	; For compatibility
                                 .equ	PORTF2	= 2	; 
                                 .equ	PF2	= 2	; For compatibility
                                 .equ	PORTF3	= 3	; 
                                 .equ	PF3	= 3	; For compatibility
                                 .equ	PORTF4	= 4	; 
                                 .equ	PF4	= 4	; For compatibility
                                 .equ	PORTF5	= 5	; 
                                 .equ	PF5	= 5	; For compatibility
                                 .equ	PORTF6	= 6	; 
                                 .equ	PF6	= 6	; For compatibility
                                 .equ	PORTF7	= 7	; 
                                 .equ	PF7	= 7	; For compatibility
                                 
                                 ; DDRF - Data Direction Register, Port F
                                 .equ	DDF0	= 0	; 
                                 .equ	DDF1	= 1	; 
                                 .equ	DDF2	= 2	; 
                                 .equ	DDF3	= 3	; 
                                 .equ	DDF4	= 4	; 
                                 .equ	DDF5	= 5	; 
                                 .equ	DDF6	= 6	; 
                                 .equ	DDF7	= 7	; 
                                 
                                 ; PINF - Input Pins, Port F
                                 .equ	PINF0	= 0	; 
                                 .equ	PINF1	= 1	; 
                                 .equ	PINF2	= 2	; 
                                 .equ	PINF3	= 3	; 
                                 .equ	PINF4	= 4	; 
                                 .equ	PINF5	= 5	; 
                                 .equ	PINF6	= 6	; 
                                 .equ	PINF7	= 7	; 
                                 
                                 
                                 ; ***** PORTG ************************
                                 ; PORTG - Data Register, Port G
                                 .equ	PORTG0	= 0	; 
                                 .equ	PG0	= 0	; For compatibility
                                 .equ	PORTG1	= 1	; 
                                 .equ	PG1	= 1	; For compatibility
                                 .equ	PORTG2	= 2	; 
                                 .equ	PG2	= 2	; For compatibility
                                 .equ	PORTG3	= 3	; 
                                 .equ	PG3	= 3	; For compatibility
                                 .equ	PORTG4	= 4	; 
                                 .equ	PG4	= 4	; For compatibility
                                 
                                 ; DDRG - Data Direction Register, Port G
                                 .equ	DDG0	= 0	; 
                                 .equ	DDG1	= 1	; 
                                 .equ	DDG2	= 2	; 
                                 .equ	DDG3	= 3	; 
                                 .equ	DDG4	= 4	; 
                                 
                                 ; PING - Input Pins, Port G
                                 .equ	PING0	= 0	; 
                                 .equ	PING1	= 1	; 
                                 .equ	PING2	= 2	; 
                                 .equ	PING3	= 3	; 
                                 .equ	PING4	= 4	; 
                                 
                                 
                                 ; ***** TIMER_COUNTER_0 **************
                                 ; TCCR0 - Timer/Counter Control Register
                                 .equ	CS00	= 0	; Clock Select 0
                                 .equ	CS01	= 1	; Clock Select 1
                                 .equ	CS02	= 2	; Clock Select 2
                                 .equ	WGM01	= 3	; Waveform Generation Mode 1
                                 .equ	CTC0	= WGM01	; For compatibility
                                 .equ	COM00	= 4	; Compare match Output Mode 0
                                 .equ	COM01	= 5	; Compare Match Output Mode 1
                                 .equ	WGM00	= 6	; Waveform Generation Mode 0
                                 .equ	PWM0	= WGM00	; For compatibility
                                 .equ	FOC0	= 7	; Force Output Compare
                                 
                                 ; TCNT0 - Timer/Counter Register
                                 .equ	TCNT0_0	= 0	; 
                                 .equ	TCNT0_1	= 1	; 
                                 .equ	TCNT0_2	= 2	; 
                                 .equ	TCNT0_3	= 3	; 
                                 .equ	TCNT0_4	= 4	; 
                                 .equ	TCNT0_5	= 5	; 
                                 .equ	TCNT0_6	= 6	; 
                                 .equ	TCNT0_7	= 7	; 
                                 
                                 ; OCR0 - Output Compare Register
                                 .equ	OCR0_0	= 0	; 
                                 .equ	OCR0_1	= 1	; 
                                 .equ	OCR0_2	= 2	; 
                                 .equ	OCR0_3	= 3	; 
                                 .equ	OCR0_4	= 4	; 
                                 .equ	OCR0_5	= 5	; 
                                 .equ	OCR0_6	= 6	; 
                                 .equ	OCR0_7	= 7	; 
                                 
                                 ; ASSR - Asynchronus Status Register
                                 .equ	TCR0UB	= 0	; Timer/Counter Control Register 0 Update Busy
                                 .equ	OCR0UB	= 1	; Output Compare register 0 Busy
                                 .equ	TCN0UB	= 2	; Timer/Counter0 Update Busy
                                 .equ	AS0	= 3	; Asynchronus Timer/Counter 0
                                 
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
                                 .equ	OCIE0	= 1	; Timer/Counter0 Output Compare Match Interrupt register
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag register
                                 .equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
                                 .equ	OCF0	= 1	; Output Compare Flag 0
                                 
                                 ; SFIOR - Special Function IO Register
                                 ;.equ	PSR0	= 1	; Prescaler Reset Timer/Counter0
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** TIMER_COUNTER_1 **************
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	TOIE1	= 2	; Timer/Counter1 Overflow Interrupt Enable
                                 .equ	OCIE1B	= 3	; Timer/Counter1 Output CompareB Match Interrupt Enable
                                 .equ	OCIE1A	= 4	; Timer/Counter1 Output CompareA Match Interrupt Enable
                                 .equ	TICIE1	= 5	; Timer/Counter1 Input Capture Interrupt Enable
                                 
                                 ; ETIMSK - Extended Timer/Counter Interrupt Mask Register
                                 .equ	OCIE1C	= 0	; Timer/Counter 1, Output Compare Match C Interrupt Enable
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag register
                                 .equ	TOV1	= 2	; Timer/Counter1 Overflow Flag
                                 .equ	OCF1B	= 3	; Output Compare Flag 1B
                                 .equ	OCF1A	= 4	; Output Compare Flag 1A
                                 .equ	ICF1	= 5	; Input Capture Flag 1
                                 
                                 ; ETIFR - Extended Timer/Counter Interrupt Flag register
                                 .equ	OCF1C	= 0	; Timer/Counter 1, Output Compare C Match Flag
                                 
                                 ; SFIOR - Special Function IO Register
                                 ;.equ	PSR321	= 0	; Prescaler Reset, T/C3, T/C2, T/C1
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 ; TCCR1A - Timer/Counter1 Control Register A
                                 .equ	WGM10	= 0	; Waveform Generation Mode Bit 0
                                 .equ	PWM10	= WGM10	; For compatibility
                                 .equ	WGM11	= 1	; Waveform Generation Mode Bit 1
                                 .equ	PWM11	= WGM11	; For compatibility
                                 .equ	COM1C0	= 2	; Compare Output Mode 1C, bit 0
                                 .equ	COM1C1	= 3	; Compare Output Mode 1C, bit 1
                                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                                 .equ	COM1A0	= 6	; Compare Ouput Mode 1A, bit 0
                                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 ; TCCR1B - Timer/Counter1 Control Register B
                                 .equ	CS10	= 0	; Clock Select bit 0
                                 .equ	CS11	= 1	; Clock Select 1 bit 1
                                 .equ	CS12	= 2	; Clock Select1 bit 2
                                 .equ	WGM12	= 3	; Waveform Generation Mode
                                 .equ	CTC10	= WGM12	; For compatibility
                                 .equ	WGM13	= 4	; Waveform Generation Mode
                                 .equ	CTC11	= WGM13	; For compatibility
                                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                                 
                                 ; TCCR1C - Timer/Counter1 Control Register C
                                 .equ	FOC1C	= 5	; Force Output Compare for channel C
                                 .equ	FOC1B	= 6	; Force Output Compare for channel B
                                 .equ	FOC1A	= 7	; Force Output Compare for channel A
                                 
                                 
                                 ; ***** TIMER_COUNTER_2 **************
                                 ; TCCR2 - Timer/Counter Control Register
                                 .equ	CS20	= 0	; Clock Select
                                 .equ	CS21	= 1	; Clock Select
                                 .equ	CS22	= 2	; Clock Select
                                 .equ	WGM21	= 3	; Waveform Generation Mode
                                 .equ	CTC2	= WGM21	; For compatibility
                                 .equ	COM20	= 4	; Compare Match Output Mode
                                 .equ	COM21	= 5	; Compare Match Output Mode
                                 .equ	WGM20	= 6	; Wafeform Generation Mode
                                 .equ	PWM2	= WGM20	; For compatibility
                                 .equ	FOC2	= 7	; Force Output Compare
                                 
                                 ; TCNT2 - Timer/Counter Register
                                 .equ	TCNT2_0	= 0	; Timer/Counter Register Bit 0
                                 .equ	TCNT2_1	= 1	; Timer/Counter Register Bit 1
                                 .equ	TCNT2_2	= 2	; Timer/Counter Register Bit 2
                                 .equ	TCNT2_3	= 3	; Timer/Counter Register Bit 3
                                 .equ	TCNT2_4	= 4	; Timer/Counter Register Bit 4
                                 .equ	TCNT2_5	= 5	; Timer/Counter Register Bit 5
                                 .equ	TCNT2_6	= 6	; Timer/Counter Register Bit 6
                                 .equ	TCNT2_7	= 7	; Timer/Counter Register Bit 7
                                 
                                 ; OCR2 - Output Compare Register
                                 .equ	OCR2_0	= 0	; Output Compare Register Bit 0
                                 .equ	OCR2_1	= 1	; Output Compare Register Bit 1
                                 .equ	OCR2_2	= 2	; Output Compare Register Bit 2
                                 .equ	OCR2_3	= 3	; Output Compare Register Bit 3
                                 .equ	OCR2_4	= 4	; Output Compare Register Bit 4
                                 .equ	OCR2_5	= 5	; Output Compare Register Bit 5
                                 .equ	OCR2_6	= 6	; Output Compare Register Bit 6
                                 .equ	OCR2_7	= 7	; Output Compare Register Bit 7
                                 
                                 ; TIMSK - 
                                 .equ	TOIE2	= 6	; 
                                 .equ	OCIE2	= 7	; 
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag Register
                                 .equ	TOV2	= 6	; Timer/Counter2 Overflow Flag
                                 .equ	OCF2	= 7	; Output Compare Flag 2
                                 
                                 
                                 ; ***** TIMER_COUNTER_3 **************
                                 ; ETIMSK - Extended Timer/Counter Interrupt Mask Register
                                 .equ	OCIE3C	= 1	; Timer/Counter3, Output Compare Match Interrupt Enable
                                 .equ	TOIE3	= 2	; Timer/Counter3 Overflow Interrupt Enable
                                 .equ	OCIE3B	= 3	; Timer/Counter3 Output CompareB Match Interrupt Enable
                                 .equ	OCIE3A	= 4	; Timer/Counter3 Output CompareA Match Interrupt Enable
                                 .equ	TICIE3	= 5	; Timer/Counter3 Input Capture Interrupt Enable
                                 
                                 ; ETIFR - Extended Timer/Counter Interrupt Flag register
                                 .equ	OCF3C	= 1	; Timer/Counter3 Output Compare C Match Flag
                                 .equ	TOV3	= 2	; Timer/Counter3 Overflow Flag
                                 .equ	OCF3B	= 3	; Output Compare Flag 1B
                                 .equ	OCF3A	= 4	; Output Compare Flag 1A
                                 .equ	ICF3	= 5	; Input Capture Flag 1
                                 
                                 ; SFIOR - Special Function IO Register
                                 ;.equ	PSR321	= 0	; Prescaler Reset, T/C3, T/C2, T/C1
                                 ;.equ	PSR1	= PSR321	; For compatibility
                                 ;.equ	PSR2	= PSR321	; For compatibility
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 ; TCCR3A - Timer/Counter3 Control Register A
                                 .equ	WGM30	= 0	; Waveform Generation Mode Bit 0
                                 .equ	PWM30	= WGM30	; For compatibility
                                 .equ	WGM31	= 1	; Waveform Generation Mode Bit 1
                                 .equ	PWM31	= WGM31	; For compatibility
                                 .equ	COM3C0	= 2	; Compare Output Mode 3C, bit 0
                                 .equ	COM3C1	= 3	; Compare Output Mode 3C, bit 1
                                 .equ	COM3B0	= 4	; Compare Output Mode 3B, bit 0
                                 .equ	COM3B1	= 5	; Compare Output Mode 3B, bit 1
                                 .equ	COM3A0	= 6	; Comparet Ouput Mode 3A, bit 0
                                 .equ	COM3A1	= 7	; Compare Output Mode 3A, bit 1
                                 
                                 ; TCCR3B - Timer/Counter3 Control Register B
                                 .equ	CS30	= 0	; Clock Select 3 bit 0
                                 .equ	CS31	= 1	; Clock Select 3 bit 1
                                 .equ	CS32	= 2	; Clock Select3 bit 2
                                 .equ	WGM32	= 3	; Waveform Generation Mode
                                 .equ	CTC30	= WGM32	; For compatibility
                                 .equ	WGM33	= 4	; Waveform Generation Mode
                                 .equ	CTC31	= WGM33	; For compatibility
                                 .equ	ICES3	= 6	; Input Capture 3 Edge Select
                                 .equ	ICNC3	= 7	; Input Capture 3  Noise Canceler
                                 
                                 ; TCCR3C - Timer/Counter3 Control Register C
                                 .equ	FOC3C	= 5	; Force Output Compare for channel C
                                 .equ	FOC3B	= 6	; Force Output Compare for channel B
                                 .equ	FOC3A	= 7	; Force Output Compare for channel A
                                 
                                 ; TCNT3L - Timer/Counter3 Low Byte
                                 .equ	TCN3L0	= 0	; Timer/Counter 3 bit 0
                                 .equ	TCN3L1	= 1	; Timer/Counter 3 bit 1
                                 .equ	TCN3L2	= 2	; Timer/Counter 3 bit 2
                                 .equ	TCN3L3	= 3	; Timer/Counter 3 bit 3
                                 .equ	TCN3L4	= 4	; Timer/Counter 3 bit 4
                                 .equ	TCN3L5	= 5	; Timer/Counter 3 bit 5
                                 .equ	TCN3L6	= 6	; Timer/Counter 3 bit 6
                                 .equ	TCN3L7	= 7	; Timer/Counter 3 bit 7
                                 
                                 
                                 ; ***** WATCHDOG *********************
                                 ; WDTCR - Watchdog Timer Control Register
                                 .equ	WDTCSR	= WDTCR	; For compatibility
                                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                                 .equ	WDE	= 3	; Watch Dog Enable
                                 .equ	WDCE	= 4	; Watchdog Change Enable
                                 .equ	WDTOE	= WDCE	; For compatibility
                                 
                                 
                                 ; ***** AD_CONVERTER *****************
                                 ; ADMUX - The ADC multiplexer Selection Register
                                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                                 .equ	MUX4	= 4	; Analog Channel and Gain Selection Bits
                                 .equ	ADLAR	= 5	; Left Adjust Result
                                 .equ	REFS0	= 6	; Reference Selection Bit 0
                                 .equ	REFS1	= 7	; Reference Selection Bit 1
                                 
                                 ; ADCSRA - The ADC Control and Status register
                                 .equ	ADCSR	= ADCSRA	; For compatibility
                                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                                 .equ	ADIE	= 3	; ADC Interrupt Enable
                                 .equ	ADIF	= 4	; ADC Interrupt Flag
                                 .equ	ADFR	= 5	; ADC  Free Running Select
                                 .equ	ADSC	= 6	; ADC Start Conversion
                                 .equ	ADEN	= 7	; ADC Enable
                                 
                                 ; ADCH - ADC Data Register High Byte
                                 .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                                 .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                                 .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                                 .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                                 .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                                 .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                                 .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                                 .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                                 
                                 ; ADCL - ADC Data Register Low Byte
                                 .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                                 .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                                 .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                                 .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                                 .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                                 .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                                 .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                                 .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                                 
                                 
                                 
                                 ; ***** LOCKSBITS ********************************************************
                                 .equ	LB1	= 0	; Lock bit
                                 .equ	LB2	= 1	; Lock bit
                                 .equ	BLB01	= 2	; Boot Lock bit
                                 .equ	BLB02	= 3	; Boot Lock bit
                                 .equ	BLB11	= 4	; Boot lock bit
                                 .equ	BLB12	= 5	; Boot lock bit
                                 
                                 
                                 ; ***** FUSES ************************************************************
                                 ; LOW fuse bits
                                 .equ	CKSEL0	= 0	; Select Clock Source
                                 .equ	CKSEL1	= 1	; Select Clock Source
                                 .equ	CKSEL2	= 2	; Select Clock Source
                                 .equ	CKSEL3	= 3	; Select Clock Source
                                 .equ	SUT0	= 4	; Select start-up time
                                 .equ	SUT1	= 5	; Select start-up time
                                 .equ	BODEN	= 6	; Brown out detector enable
                                 .equ	BODLEVEL	= 7	; Brown out detector trigger level
                                 
                                 ; HIGH fuse bits
                                 .equ	BOOTRST	= 0	; Select Reset Vector
                                 .equ	BOOTSZ0	= 1	; Select Boot Size
                                 .equ	BOOTSZ1	= 2	; Select Boot Size
                                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                                 .equ	CKOPT	= 4	; Oscillator Options
                                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                                 .equ	JTAGEN	= 6	; Enable JTAG
                                 .equ	OCDEN	= 7	; Enable OCD
                                 
                                 ; EXTENDED fuse bits
                                 .equ	WDTON	= 0	; Watchdog timer always on
                                 .equ	M103C	= 1	; ATmega103 compatibility mode
                                 
                                 
                                 
                                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                                 .def	XH	= r27
                                 .def	XL	= r26
                                 .def	YH	= r29
                                 .def	YL	= r28
                                 .def	ZH	= r31
                                 .def	ZL	= r30
                                 
                                 
                                 
                                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                                 .equ	FLASHEND	= 0xffff	; Note: Word address
                                 .equ	IOEND	= 0x00ff
                                 .equ	SRAM_START	= 0x0100
                                 .equ	SRAM_SIZE	= 4096
                                 .equ	RAMEND	= 0x10ff
                                 .equ	XRAMEND	= 0xffff
                                 .equ	E2END	= 0x0fff
                                 .equ	EEPROMEND	= 0x0fff
                                 .equ	EEADRBITS	= 12
                                 #pragma AVRPART MEMORY PROG_FLASH 131072
                                 #pragma AVRPART MEMORY EEPROM 4096
                                 #pragma AVRPART MEMORY INT_SRAM SIZE 4096
                                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x100
                                 
                                 
                                 
                                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                                 .equ	NRWW_START_ADDR	= 0xf000
                                 .equ	NRWW_STOP_ADDR	= 0xffff
                                 .equ	RWW_START_ADDR	= 0x0
                                 .equ	RWW_STOP_ADDR	= 0xefff
                                 .equ	PAGESIZE	= 128
                                 .equ	FIRSTBOOTSTART	= 0xfe00
                                 .equ	SECONDBOOTSTART	= 0xfc00
                                 .equ	THIRDBOOTSTART	= 0xf800
                                 .equ	FOURTHBOOTSTART	= 0xf000
                                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                                 
                                 
                                 
                                 ; ***** INTERRUPT VECTORS ************************************************
                                 .equ	INT0addr	= 0x0002	; External Interrupt Request 0
                                 .equ	INT1addr	= 0x0004	; External Interrupt Request 1
                                 .equ	INT2addr	= 0x0006	; External Interrupt Request 2
                                 .equ	INT3addr	= 0x0008	; External Interrupt Request 3
                                 .equ	INT4addr	= 0x000a	; External Interrupt Request 4
                                 .equ	INT5addr	= 0x000c	; External Interrupt Request 5
                                 .equ	INT6addr	= 0x000e	; External Interrupt Request 6
                                 .equ	INT7addr	= 0x0010	; External Interrupt Request 7
                                 .equ	OC2addr	= 0x0012	; Timer/Counter2 Compare Match
                                 .equ	OVF2addr	= 0x0014	; Timer/Counter2 Overflow
                                 .equ	ICP1addr	= 0x0016	; Timer/Counter1 Capture Event
                                 .equ	OC1Aaddr	= 0x0018	; Timer/Counter1 Compare Match A
                                 .equ	OC1Baddr	= 0x001a	; Timer/Counter Compare Match B
                                 .equ	OVF1addr	= 0x001c	; Timer/Counter1 Overflow
                                 .equ	OC0addr	= 0x001e	; Timer/Counter0 Compare Match
                                 .equ	OVF0addr	= 0x0020	; Timer/Counter0 Overflow
                                 .equ	SPIaddr	= 0x0022	; SPI Serial Transfer Complete
                                 .equ	URXC0addr	= 0x0024	; USART0, Rx Complete
                                 .equ	UDRE0addr	= 0x0026	; USART0 Data Register Empty
                                 .equ	UTXC0addr	= 0x0028	; USART0, Tx Complete
                                 .equ	ADCCaddr	= 0x002a	; ADC Conversion Complete
                                 .equ	ERDYaddr	= 0x002c	; EEPROM Ready
                                 .equ	ACIaddr	= 0x002e	; Analog Comparator
                                 .equ	OC1Caddr	= 0x0030	; Timer/Counter1 Compare Match C
                                 .equ	ICP3addr	= 0x0032	; Timer/Counter3 Capture Event
                                 .equ	OC3Aaddr	= 0x0034	; Timer/Counter3 Compare Match A
                                 .equ	OC3Baddr	= 0x0036	; Timer/Counter3 Compare Match B
                                 .equ	OC3Caddr	= 0x0038	; Timer/Counter3 Compare Match C
                                 .equ	OVF3addr	= 0x003a	; Timer/Counter3 Overflow
                                 .equ	URXC1addr	= 0x003c	; USART1, Rx Complete
                                 .equ	UDRE1addr	= 0x003e	; USART1, Data Register Empty
                                 .equ	UTXC1addr	= 0x0040	; USART1, Tx Complete
                                 .equ	TWIaddr	= 0x0042	; 2-wire Serial Interface
                                 .equ	SPMRaddr	= 0x0044	; Store Program Memory Read
                                 
                                 .equ	INT_VECTORS_SIZE	= 70	; size in words
                                 
                                 #endif  /* _M128DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 
                                 ; purpose library, general-purpose macros
                                 ; author (c) R.Holzer (adapted MICRO210/EE208 A.Schmid)
                                 ; v2019.01 20180820 AxS
                                 
                                 ; ==============
                                 ; 	pointers
                                 ; ==============
                                 
                                 ; --- loading an immediate into a pointer XYZ,SP ---
                                 .macro 	LDIX	; sram
                                 	ldi	xl, low(@0)
                                 	ldi	xh,high(@0)
                                 	.endmacro	
                                 .macro 	LDIY	; sram	
                                 	ldi	yl, low(@0)
                                 	ldi	yh,high(@0)
                                 	.endmacro	
                                 .macro 	LDIZ	; sram
                                 	ldi	zl, low(@0)
                                 	ldi	zh,high(@0)
                                 	
                                 	.endmacro
                                 .macro	LDZD	; sram, reg	; sram+reg -> Z
                                 	mov	zl,@1
                                 	clr	zh
                                 	subi	zl, low(-@0)
                                 	sbci	zh,high(-@0)
                                 	.endmacro
                                 .macro	LDSP	; sram
                                 	ldi	r16, low(@0)
                                 	out	spl,r16
                                 	ldi	r16,high(@0)
                                 	out	sph,r16
                                 	.endmacro
                                 
                                 ; --- load/store SRAM addr into pointer XYZ ---	
                                 .macro 	LDSX	; sram
                                 	lds	xl,@0
                                 	lds	xh,@0+1
                                 	.endmacro
                                 .macro 	LDSY	; sram
                                 	lds	yl,@0
                                 	lds	yh,@0+1
                                 	.endmacro
                                 .macro 	LDSZ	; sram
                                 	lds	zl,@0
                                 	lds	zh,@0+1
                                 	.endmacro
                                 .macro 	STSX	; sram
                                 	sts	@0,  xl
                                 	sts	@0+1,xh
                                 	.endmacro	
                                 .macro 	STSY	; sram
                                 	sts	@0,  yl
                                 	sts	@0+1,yh
                                 	.endmacro
                                 .macro 	STSZ	; sram
                                 	sts	@0,  zl
                                 	sts	@0+1,zh
                                 	.endmacro	
                                 
                                 ; --- push/pop pointer XYZ ---
                                 .macro	PUSHX			; push X
                                 	push	xl
                                 	push	xh
                                 	.endmacro
                                 .macro	POPX			; pop X
                                 	pop	xh
                                 	pop	xl
                                 	.endmacro
                                 	
                                 .macro	PUSHY			; push Y
                                 	push	yl
                                 	push	yh
                                 	.endmacro
                                 .macro	POPY			; pop Y
                                 	pop	yh
                                 	pop	yl
                                 	.endmacro
                                 
                                 .macro	PUSHZ			; push Z
                                 	push	zl
                                 	push	zh
                                 	.endmacro
                                 .macro	POPZ			; pop Z
                                 	pop	zh
                                 	pop	zl
                                 	.endmacro
                                 
                                 ; --- multiply/divide Z ---	
                                 .macro	MUL2Z			; multiply Z by 2
                                 	lsl	zl
                                 	rol	zh
                                 	.endmacro
                                 .macro	DIV2Z			; divide Z by 2
                                 	lsr	zh
                                 	ror	zl
                                 	.endmacro
                                 
                                 ; --- add register to pointer XYZ ---	
                                 .macro	ADDX	;reg		; x <- y+reg
                                 	add	xl,@0
                                 	brcc	PC+2
                                 	subi	xh,-1		; add carry
                                 	.endmacro
                                 .macro	ADDY	;reg		; y <- y+reg
                                 	add	yl,@0
                                 	brcc	PC+2
                                 	subi	yh,-1		; add carry
                                 	.endmacro
                                 .macro	ADDZ	;reg		; z <- z+reg
                                 	add	zl,@0
                                 	brcc	PC+2
                                 	subi	zh,-1		; add carry
                                 	.endmacro
                                 
                                 ; ===================
                                 ; 	miscellaneous
                                 ; ===================
                                 
                                 ; --- output/store (regular I/O space) immediate value ---
                                 .macro	OUTI	; port,k	output immediate value to port
                                 	ldi	w,@1
                                 	out	@0,w
                                 	.endmacro
                                 
                                 ; --- output/store (extended I/O space) immediate value ---
                                 .macro OUTEI	; port,k    output immediate value to port
                                 	ldi	w,@1
                                 	sts	@0,w
                                 	.endmacro
                                 
                                 ; --- add immediate value ---
                                 .macro	ADDI
                                 	subi	@0,-@1
                                 	.endmacro
                                 .macro	ADCI
                                 	sbci	@0,-@1
                                 	.endmacro
                                 
                                 ; --- inc/dec with range limitation ---
                                 .macro	INC_LIM	; reg,limit
                                 	cpi	@0,@1
                                 	brlo	PC+3
                                 	ldi	@0,@1	
                                 	rjmp	PC+2
                                 	inc	@0
                                 	.endmacro
                                 
                                 .macro	DEC_LIM	; reg,limit
                                 	cpi	@0,@1
                                 	breq	PC+5
                                 	brlo	PC+3
                                 	dec	@0
                                 	rjmp	PC+2
                                 	ldi	@0,@1
                                 	.endmacro
                                 
                                 ; --- inc/dec with cyclic range ---
                                 .macro	INC_CYC	; reg,low,high
                                 	cpi	@0,@2
                                 	brsh	_low	; reg>=high then reg=low
                                 	cpi	@0,@1
                                 	brlo	_low	; reg< low  then reg=low
                                 	inc	@0
                                 	rjmp	_done
                                 _low:	ldi	@0,@1
                                 _done:	
                                     .endmacro
                                 	
                                 .macro	DEC_CYC	; reg,low,high
                                 	cpi	@0,@1
                                 	breq	_high	; reg=low then reg=high
                                 	brlo	_high	; reg<low then reg=high
                                 	dec	@0	
                                 	cpi	@0,@2
                                 	brsh	_high	; reg>=high then high
                                 	rjmp	_done
                                 _high:	ldi	@0,@2
                                 _done:	
                                 	.endmacro
                                 
                                 .macro	INCDEC	;port,b1,b2,reg,low,high
                                 	sbic	@0,@1
                                 	rjmp	PC+6
                                 
                                 	cpi	@3,@5
                                 	brlo	PC+3
                                 	ldi	@3,@4	
                                 	rjmp	PC+2
                                 	inc	@3
                                 
                                 	sbic	@0,@2
                                 	rjmp	PC+7
                                 	
                                 	cpi	@3,@4
                                 	breq	PC+5
                                 	brlo	PC+3
                                 	dec	@3
                                 	rjmp	PC+2
                                 	ldi	@3,@5
                                 	.endmacro		
                                 
                                 ; --- wait loops ---
                                 ; wait 10...196608 cycles
                                 .macro	WAIT_C	; k
                                 	ldi	w,  low((@0-7)/3)
                                 	mov	u,w			; u=LSB
                                 	ldi	w,high((@0-7)/3)+1	; w=MSB
                                 	dec	u
                                 	brne	PC-1
                                 	dec	u
                                 	dec	w
                                 	brne	PC-4
                                 	.endmacro
                                 
                                 ; wait micro-seconds (us)
                                 ; us = x*3*1000'000/clock)	==> x=us*clock/3000'000
                                 .macro	WAIT_US ; k
                                 	ldi	w, low((clock/1000*@0/3000)-1)
                                 	mov	u,w
                                 	ldi	w,high((clock/1000*@0/3000)-1)+1 ; set up: 3 cyles
                                 	dec	u
                                 	brne	PC-1		; inner loop: 3 cycles
                                 	dec	u		; adjustment for outer loop
                                 	dec	w
                                 	brne	PC-4
                                 	.endmacro
                                 
                                 ; wait mili-seconds (ms)
                                 .macro	WAIT_MS ; k
                                 	ldi	w, low(@0)
                                 	mov	u,w		; u = LSB	
                                 	ldi	w,high(@0)+1	; w = MSB
                                 wait_ms:
                                 	push	w		; wait 1000 usec
                                 	push	u
                                 	ldi	w, low((clock/3000)-5)	
                                 	mov	u,w
                                 	ldi	w,high((clock/3000)-5)+1
                                 	dec	u
                                 	brne	PC-1		; inner loop: 3 cycles
                                 	dec	u		; adjustment for outer loop
                                 	dec	w
                                 	brne	PC-4
                                 	pop	u
                                 	pop	w
                                 	
                                 	dec	u
                                 	brne	wait_ms
                                 	dec	w
                                 	brne	wait_ms
                                 	.endmacro
                                 
                                 ; --- conditional jumps/calls ---
                                 .macro	JC0			; jump if carry=0
                                 	brcs	PC+2	
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	JC1			; jump if carry=1
                                 	brcc	PC+2	
                                 	rjmp	@0
                                 	.endmacro
                                 
                                 .macro	JK	; reg,k,addr	; jump if reg=k
                                 	cpi	@0,@1
                                 	breq	@2
                                 	.endmacro
                                 .macro	_JK	; reg,k,addr	; jump if reg=k
                                 	cpi	@0,@1
                                 	brne	PC+2
                                 	rjmp	@2
                                 	.endmacro	
                                 .macro	JNK	; reg,k,addr	; jump if not(reg=k)
                                 	cpi	@0,@1
                                 	brne	@2
                                 	.endmacro 
                                 
                                 .macro	CK	; reg,k,addr	; call if reg=k
                                 	cpi	@0,@1
                                 	brne	PC+2
                                 	rcall	@2
                                 	.endmacro
                                 .macro	CNK	; reg,k,addr	; call if not(reg=k)
                                 	cpi	@0,@1
                                 	breq	PC+2
                                 	rcall	@2
                                 	.endmacro 
                                 
                                 .macro	JSK	; sram,k,addr	; jump if sram=k
                                 	lds	w,@0
                                 	cpi	w,@1
                                 	breq	@2
                                 	.endmacro 
                                 .macro	JSNK	; sram,k,addr	; jump if not(sram=k)
                                 	lds	w,@0
                                 	cpi	w,@1
                                 	brne	@2
                                 	.endmacro
                                 
                                 ; --- loops ---
                                 .macro	DJNZ	; reg,addr	; decr and jump if not zero
                                 	dec	@0
                                 	brne	@1
                                 	.endmacro
                                 .macro	DJNK	; reg,k,addr	; decr and jump if not k
                                 	dec	@0
                                 	cpi	@0,@1
                                 	brne	@2
                                 	.endmacro
                                 
                                 .macro	IJNZ	; reg,addr	; inc and jump if not zero
                                 	inc	@0
                                 	brne	@1
                                 	.endmacro
                                 .macro	IJNK	; reg,k,addr	; inc and jump if not k
                                 	inc	@0
                                 	cpi	@0,@1
                                 	brne	@2
                                 	.endmacro
                                 .macro	_IJNK	; reg,k,addr	; inc and jump if not k
                                 	inc	@0
                                 	ldi	w,@1
                                 	cp	@0,w
                                 	brne	@2
                                 	.endmacro
                                 
                                 .macro	ISJNK	; sram,k,addr	; inc sram and jump if not k
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	cpi	w,@1
                                 	brne	@2
                                 	.endmacro
                                 .macro	_ISJNK	; sram,k,addr	; inc sram and jump if not k
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	cpi	w,@1
                                 	breq	PC+2	
                                 	rjmp	@2
                                 	.endmacro
                                 
                                 .macro	DSJNK	; sram,k,addr	; dec sram and jump if not k
                                 	lds	w,@0
                                 	dec	w
                                 	sts	@0,w
                                 	cpi	w,@1
                                 	brne	@2
                                 	.endmacro
                                 
                                 ; --- table lookup ---
                                 .macro	LOOKUP	;reg, index,tbl
                                 	push	ZL
                                 	push	ZH
                                 	mov	zl,@1		; move index into z
                                 	clr	zh
                                 	subi	zl, low(-2*@2)	; add base address of table
                                 	sbci	zh,high(-2*@2)	
                                 	lpm			; load program memory (into r0)
                                 	mov	@0,r0
                                 	pop	ZH
                                 	pop	ZL
                                 	.endmacro
                                 
                                 .macro	LOOKUP2	;r1,r0, index,tbl
                                 	mov	zl,@2		; move index into z
                                 	clr	zh
                                 	lsl	zl		; multiply by 2
                                 	rol	zh
                                 	subi	zl, low(-2*@3)	; add base address of table
                                 	sbci	zh,high(-2*@3)
                                 	lpm			; get LSB byte
                                 	mov	w,r0		; temporary store LSB in w
                                 	adiw	zl,1		; increment Z
                                 	lpm			; get MSB byte
                                 	mov	@0,r0		; mov MSB to res1
                                 	mov	@1,w		; mov LSB to res0
                                 	.endmacro
                                 
                                 .macro	LOOKUP4	;r3,r2,r1,r0, index,tbl
                                 	mov	zl,@4		; move index into z
                                 	clr	zh
                                 	lsl	zl		; multiply by 2
                                 	rol	zh
                                 	lsl	zl		; multiply by 2
                                 	rol	zh	
                                 	subi	zl, low(-2*@5)	; add base address of table
                                 	sbci	zh,high(-2*@5)
                                 	lpm
                                 	mov	@1,r0		; load high word LSB
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@0,r0		; load high word MSB
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@3,r0		; load low word LSB		
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@2,r0		; load low word MSB
                                 	.endmacro
                                 
                                 .macro	LOOKDOWN ;reg,index,tbl
                                 	ldi	ZL, low(2*@2)	; load table address
                                 	ldi	ZH,high(2*@2)
                                 	clr	@1
                                 loop:	lpm
                                 	cp	r0,@0
                                 	breq	found
                                 	inc	@1
                                 	adiw	ZL,1
                                 	tst	r0
                                 	breq	notfound
                                 	rjmp	loop
                                 notfound:
                                 	ldi	@1,-1
                                 found:	
                                 	.endmacro
                                 
                                 ; --- branch table ---
                                 .macro	C_TBL	; reg,tbl
                                 	ldi	ZL, low(2*@1)
                                 	ldi	ZH,high(2*@1)
                                 	lsl	@0
                                 	add	ZL,@0
                                 	brcc	PC+2
                                 	inc	ZH
                                 	lpm
                                 	push	r0
                                 	lpm
                                 	mov	zh,r0
                                 	pop	zl
                                 	icall
                                 	.endmacro
                                 .macro	J_TBL	; reg,tbl	
                                 	ldi	ZL, low(2*@1)
                                 	ldi	ZH,high(2*@1)
                                 	lsl	@0
                                 	add	ZL,@0
                                 	brcc	PC+2
                                 	inc	ZH
                                 	lpm
                                 	push	r0
                                 	lpm
                                 	mov	zh,r0
                                 	pop	zl	
                                 	ijmp
                                 	.endmacro
                                 
                                 .macro	BRANCH	; reg		; branching using the stack
                                 	ldi	w, low(tbl)
                                 	add	w,@0
                                 	push	w
                                 	ldi	w,high(tbl)
                                 	brcc	PC+2
                                 	inc	w
                                 	push	w
                                 	ret
                                 tbl:
                                 	.endmacro	
                                 
                                 ; --- multiply/division ---
                                 .macro	DIV2	; reg
                                 	lsr	@0
                                 	.endmacro
                                 .macro	DIV4	; reg
                                 	lsr	@0
                                 	lsr	@0
                                 	.endmacro	
                                 .macro	DIV8	; reg
                                 	lsr	@0
                                 	lsr	@0
                                 	lsr	@0
                                 	.endmacro
                                 	
                                 .macro	MUL2	; reg
                                 	lsl	@0
                                 	.endmacro
                                 .macro	MUL4	; reg
                                 	lsl	@0
                                 	lsl	@0
                                 	.endmacro
                                 .macro	MUL8	; reg
                                 	lsl	@0
                                 	lsl	@0
                                 	lsl	@0
                                 	.endmacro
                                 
                                 ; ====================================
                                 ; 	extending existing instructios
                                 ; ====================================
                                 
                                 ; --- immediate ops with r0..r15 ---
                                 .macro	_ADDI
                                 	ldi	w,@1
                                 	add	@0,w
                                 	.endmacro
                                 .macro	_ADCI
                                 	ldi	w,@1
                                 	adc	@0,w
                                 	.endmacro
                                 .macro	_SUBI
                                 	ldi	w,@1
                                 	sub	@0,w
                                 	.endmacro
                                 .macro	_SBCI
                                 	ldi	w,@1
                                 	sbc	@0,w
                                 	.endmacro
                                 .macro	_ANDI
                                 	ldi	w,@1
                                 	and	@0,w
                                 	.endmacro
                                 .macro	_ORI
                                 	ldi	w,@1
                                 	or	@0,w
                                 	.endmacro
                                 .macro	_EORI
                                 	ldi	w,@1
                                 	eor	@0,w
                                 	.endmacro
                                 .macro	_SBR
                                 	ldi	w,@1
                                 	or	@0,w
                                 	.endmacro
                                 .macro	_CBR
                                 	ldi	w,~@1
                                 	and	@0,w
                                 	.endmacro
                                 .macro	_CPI
                                 	ldi	w,@1
                                 	cp	@0,w
                                 	.endmacro
                                 .macro	_LDI
                                 	ldi	w,@1
                                 	mov	@0,w
                                 	.endmacro
                                 
                                 ; --- bit access for port p32..p63 ---
                                 .macro	_SBI
                                 	in	w,@0
                                 	ori	w,1<<@1
                                 	out	@0,w
                                 	.endmacro
                                 .macro	_CBI
                                 	in	w,@0
                                 	andi	w,~(1<<@1)
                                 	out	@0,w
                                 	.endmacro
                                 	
                                 ; --- extending branch distance to +/-2k ---
                                 .macro	_BREQ
                                 	brne	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRNE
                                 	breq	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRCS
                                 	brcc	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRCC
                                 	brcs	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRSH
                                 	brlo	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRLO
                                 	brsh	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRMI
                                 	brpl	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRPL
                                 	brmi	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRGE
                                 	brlt	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRLT
                                 	brge	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRHS
                                 	brhc	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRHC
                                 	brhs	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRTS
                                 	brtc	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRTC
                                 	brts	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRVS
                                 	brvc	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRVC
                                 	brvs	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRIE
                                 	brid	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRID
                                 	brie	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 
                                 ; ====================
                                 ; 	bit operations
                                 ; ====================
                                 
                                 ; --- moving bits ---
                                 .macro	MOVB	; reg1,b1, reg2,b2	; reg1,bit1 <- reg2,bit2
                                 	bst	@2,@3
                                 	bld	@0,@1
                                 	.endmacro
                                 .macro	OUTB	; port1,b1, reg2,b2	; port1,bit1 <- reg2,bit2
                                 	sbrs	@2,@3
                                 	cbi	@0,@1
                                 	sbrc	@2,@3
                                 	sbi	@0,@1
                                 	.endmacro
                                 .macro	INB	; reg1,b1, port2,b2	; reg1,bit1 <- port2,bit2
                                 	sbis	@2,@3
                                 	cbr	@0,1<<@1
                                 	sbic	@2,@3
                                 	sbr	@0,1<<@1
                                 	.endmacro
                                 
                                 .macro	Z2C				; zero to carry
                                 	sec
                                 	breq	PC+2	; (Z=1)
                                 	clc
                                 	.endmacro
                                 .macro	Z2INVC				; zero to inverse carry
                                 	sec
                                 	brne	PC+2	; (Z=0)
                                 	clc
                                 	.endmacro
                                 
                                 .macro	C2Z				; carry to zero
                                 	sez
                                 	brcs	PC+2	; (C=1)
                                 	clz
                                 	.endmacro
                                 
                                 .macro	B2C	; reg,b			; bit to carry
                                 	sbrc	@0,@1
                                 	sec
                                 	sbrs	@0,@1
                                 	clc
                                 	.endmacro
                                 .macro	C2B	; reg,b			; carry to bit
                                 	brcc	PC+2
                                 	sbr	@0,(1<<@1)
                                 	brcs	PC+2
                                 	cbr	@0,(1<<@1)
                                 	.endmacro
                                 .macro	P2C	; port,b		; port to carry
                                 	sbic	@0,@1
                                 	sec
                                 	sbis	@0,@1
                                 	clc
                                 	.endmacro
                                 .macro	C2P	; port,b		; carry to port
                                 	brcc	PC+2
                                 	sbi	@0,@1
                                 	brcs	PC+2
                                 	cbi	@0,@1
                                 	.endmacro
                                 
                                 ; --- inverting bits ---
                                 .macro	INVB	; reg,bit		; inverse reg,bit
                                 	ldi	w,(1<<@1)
                                 	eor	@0,w
                                 	.endmacro
                                 .macro	INVP	; port,bit		; inverse port,bit	
                                 	sbis	@0,@1
                                 	rjmp	PC+3
                                 	cbi	@0,@1
                                 	rjmp	PC+2
                                 	sbi	@0,@1
                                 	.endmacro
                                 .macro	INVC				; inverse carry	
                                 	brcs	PC+3
                                 	sec
                                 	rjmp	PC+2
                                 	clc
                                 	.endmacro
                                 
                                 ; --- setting a single bit ---
                                 .macro	SETBIT	; reg(0..7)
                                 ; in	reg (0..7)
                                 ; out	reg with bit (0..7) set to 1.
                                 ; 0=00000001
                                 ; 1=00000010
                                 ; ...
                                 ; 7=10000000
                                 	mov	w,@0
                                 	clr	@0
                                 	inc	@0
                                 	andi	w,0b111	
                                 	breq	PC+4
                                 	lsl	@0
                                 	dec	w
                                 	brne	PC-2
                                 	.endmacro
                                 
                                 ; --- logical operations with masks ---
                                 .macro	MOVMSK	; reg1,reg2,mask	; reg1 <- reg2 (mask)
                                 	ldi	w,~@2	
                                 	and	@0,w
                                 	ldi	w,@2
                                 	and	@1,w	
                                 	or	@0,@1
                                 	.endmacro	
                                 .macro	ANDMSK	; reg1,reg2,mask	; reg1 <- ret 1 AND reg2 (mask)		
                                 	mov	w,@1
                                 	ori	w,~@2
                                 	and	@0,w
                                 	.endmacro	
                                 .macro	ORMSK	; reg1,reg2,mask	; reg1 <- ret 1 AND reg2 (mask)		
                                 	mov	w,@1
                                 	andi	w,@2
                                 	or	@0,w
                                 	.endmacro
                                 	
                                 ; --- logical operations on bits ---
                                 .macro	ANDB	; r1,b1, r2,b2, r3,b3	; reg1,b1 <- reg2,b2 AND reg3,b3
                                 	set
                                 	sbrs	@4,@5	
                                 	clt
                                 	sbrs	@2,@3	
                                 	clt
                                 	bld	@0,@1
                                 	.endmacro
                                 .macro	ORB	; r1,b1, r2,b2, r3,b3	; reg1.b1 <- reg2.b2 OR reg3.b3
                                 	clt
                                 	sbrc	@4,@5	
                                 	set
                                 	sbrc	@2,@3	
                                 	set
                                 	bld	@0,@1
                                 	.endmacro
                                 .macro	EORB	; r1,b1, r2,b2, r3,b3	; reg1.b1 <- reg2.b2 XOR reg3.b3
                                 	sbrc	@4,@5
                                 	rjmp	f1
                                 f0:	bst	@2,@3	
                                 	rjmp	PC+4
                                 f1:	set
                                 	sbrc	@0,@1
                                 	clt
                                 	bld	@0,@0	
                                 	.endmacro
                                 	
                                 ; --- operations based on register bits ---
                                 .macro	FB0	; reg,bit		; bit=0
                                 	cbr	@0,1<<@1
                                 	.endmacro
                                 .macro	FB1	; reg,bit		; bit=1
                                 	sbr	@0,1<<@1
                                 	.endmacro
                                 .macro	_FB0	; reg,bit		; bit=0
                                 	ldi	w,~(1<<@1)
                                 	and	@0,w
                                 	.endmacro
                                 .macro	_FB1	; reg,bit		; bit=1
                                 	ldi	w,1<<@1
                                 	or	@0,w
                                 	.endmacro
                                 .macro	SB0	; reg,bit,addr		; skip if bit=0
                                 	sbrc	@0,@1
                                 	.endmacro
                                 .macro	SB1	; reg,bit,addr		; skip if bit=1
                                 	sbrs	@0,@1
                                 	.endmacro
                                 .macro	JB0	; reg,bit,addr		; jump if bit=0
                                 	sbrs	@0,@1
                                 	rjmp	@2
                                 	.endmacro
                                 .macro	JB1	; reg,bit,addr		; jump if bit=1
                                 	sbrc	@0,@1
                                 	rjmp	@2
                                 	.endmacro
                                 .macro	CB0	; reg,bit,addr		; call if bit=0
                                 	sbrs	@0,@1
                                 	rcall	@2
                                 	.endmacro
                                 .macro	CB1	; reg,bit,addr		; call if bit=1
                                 	sbrc	@0,@1
                                 	rcall	@2
                                 	.endmacro
                                 .macro	WB0	; reg,bit		; wait if bit=0
                                 	sbrs	@0,@1
                                 	rjmp	PC-1
                                 	.endmacro
                                 .macro	WB1	; reg,bit		; wait if bit=1
                                 	sbrc	@0,@1
                                 	rjmp	PC-1
                                 	.endmacro
                                 .macro	RB0	; reg,bit		; return if bit=0
                                 	sbrs	@0,@1
                                 	ret
                                 	.endmacro
                                 .macro	RB1	; reg,bit		; return if bit=1
                                 	sbrc	@0,@1
                                 	ret
                                 	.endmacro
                                 
                                 ; wait if bit=0 with timeout
                                 ; if timeout (in units of 5 cyc) then jump to addr
                                 .macro	WB0T	; reg,bit,timeout,addr
                                 	ldi	w,@2+1
                                 	dec	w	; 1 cyc
                                 	breq	@3	; 1 cyc
                                 	sbrs	@0,@1	; 1 cyc
                                 	rjmp	PC-3	; 2 cyc = 5 cycles
                                 	.endmacro
                                 
                                 ; wait if bit=1 with timeout
                                 ; if timeout (in units of 5 cyc) then jump to addr	
                                 .macro	WB1T	; reg,bit,timeout,addr
                                 	ldi	w,@2+1
                                 	dec	w	; 1 cyc
                                 	breq	@3	; 1 cyc
                                 	sbrc	@0,@1	; 1 cyc
                                 	rjmp	PC-3	; 2 cyc = 5 cycles
                                 	.endmacro	
                                 	
                                 ; --- operations based on port bits ---
                                 .macro	P0	; port,bit		; port=0
                                 	cbi	@0,@1
                                 	.endmacro
                                 .macro	P1	; port,bit		; port=1
                                 	sbi	@0,@1
                                 	.endmacro
                                 .macro	SP0	; port,bit		; skip if port=0
                                 	sbic	@0,@1
                                 	.endmacro
                                 .macro	SP1	; port,bit		; skip if port=1
                                 	sbis	@0,@1
                                 	.endmacro
                                 .macro	JP0	; port,bit,addr		; jump if port=0
                                 	sbis	@0,@1
                                 	rjmp	@2
                                 	.endmacro
                                 .macro	JP1	; port,bit,addr		; jump if port=1
                                 	sbic	@0,@1
                                 	rjmp	@2
                                 	.endmacro
                                 .macro	CP0	; port,bit,addr		; call if port=0
                                 	sbis	@0,@1
                                 	rcall	@2
                                 	.endmacro
                                 .macro	CP1	; port,bit,addr		; call if port=1
                                 	sbic	@0,@1
                                 	rcall	@2
                                 	.endmacro
                                 .macro	WP0	; port,bit		; wait if port=0
                                 	sbis	@0,@1
                                 	rjmp	PC-1
                                 	.endmacro
                                 .macro	WP1	; port,bit		; wait if port=1
                                 	sbic	@0,@1
                                 	rjmp	PC-1
                                 	.endmacro
                                 .macro	RP0	; port,bit		; return if port=0
                                 	sbis	@0,@1
                                 	ret
                                 	.endmacro
                                 .macro	RP1	; port,bit		; return if port=1
                                 	sbic	@0,@1
                                 	ret
                                 	.endmacro
                                 
                                 ; wait if port=0 with timeout
                                 ; if timeout (in units of 5 cyc) then jump to addr
                                 .macro	WP0T	; port,bit,timeout,addr
                                 	ldi	w,@2+1
                                 	dec	w	; 1 cyc
                                 	breq	@3	; 1 cyc
                                 	sbis	@0,@1	; 1 cyc
                                 	rjmp	PC-3	; 2 cyc = 5 cycles
                                 	.endmacro
                                 
                                 ; wait if port=1 with timeout
                                 ; if timeout (in units of 5 cyc) then jump to addr	
                                 .macro	WP1T	; port,bit,timeout,addr
                                 	ldi	w,@2+1
                                 	dec	w	; 1 cyc
                                 	breq	@3	; 1 cyc
                                 	sbic	@0,@1	; 1 cyc
                                 	rjmp	PC-3	; 2 cyc = 5 cycles
                                 	.endmacro	
                                 
                                 ; ===========================
                                 ; 	multi-byte operations
                                 ; ===========================
                                 
                                 .macro	SWAP4			; swap 2 variables
                                 	mov	w ,@0
                                 	mov	@0,@4
                                 	mov	@4,w
                                 	mov	w ,@1
                                 	mov	@1,@5
                                 	mov	@5,w
                                 	mov	w ,@2
                                 	mov	@2,@6
                                 	mov	@6,w
                                 	mov	w ,@3
                                 	mov	@3,@7
                                 	mov	@7,w
                                 	.endmacro
                                 .macro	SWAP3
                                 	mov	w ,@0
                                 	mov	@0,@3
                                 	mov	@3,w
                                 	mov	w ,@1
                                 	mov	@1,@4
                                 	mov	@4,w
                                 	mov	w ,@2
                                 	mov	@2,@5
                                 	mov	@5,w
                                 	.endmacro
                                 .macro	SWAP2
                                 	mov	w ,@0
                                 	mov	@0,@2
                                 	mov	@2,w
                                 	mov	w ,@1
                                 	mov	@1,@3
                                 	mov	@3,w
                                 	.endmacro
                                 .macro	SWAP1
                                 	mov	w ,@0
                                 	mov	@0,@1
                                 	mov	@1,w
                                 	.endmacro
                                 
                                 .macro	LDX4	;r..r0		; load from (x+)
                                 	ld	@3,x+
                                 	ld	@2,x+	
                                 	ld	@1,x+
                                 	ld	@0,x+
                                 	.endmacro
                                 .macro	LDX3	;r..r0
                                 	ld	@2,x+	
                                 	ld	@1,x+
                                 	ld	@0,x+
                                 	.endmacro
                                 .macro	LDX2	;r..r0	
                                 	ld	@1,x+
                                 	ld	@0,x+
                                 	.endmacro
                                 	
                                 .macro	LDY4	;r..r0		; load from (y+)
                                 	ld	@3,y+
                                 	ld	@2,y+	
                                 	ld	@1,y+
                                 	ld	@0,y+
                                 	.endmacro
                                 .macro	LDY3	;r..r0
                                 	ld	@2,y+	
                                 	ld	@1,y+
                                 	ld	@0,y+
                                 	.endmacro
                                 .macro	LDY2	;r..r0	
                                 	ld	@1,y+
                                 	ld	@0,y+
                                 	.endmacro
                                 
                                 .macro	LDZ4	;r..r0		; load from (z+)
                                 	ld	@3,z+
                                 	ld	@2,z+	
                                 	ld	@1,z+
                                 	ld	@0,z+
                                 	.endmacro
                                 .macro	LDZ3	;r..r0
                                 	ld	@2,z+	
                                 	ld	@1,z+
                                 	ld	@0,z+
                                 	.endmacro
                                 .macro	LDZ2	;r..r0
                                 	ld	@1,z+
                                 	ld	@0,z+
                                 	.endmacro
                                 
                                 .macro	STX4	;r..r0		; store to (x+)
                                 	st	x+,@3
                                 	st	x+,@2	
                                 	st	x+,@1
                                 	st	x+,@0
                                 	.endmacro
                                 .macro	STX3	;r..r0
                                 	st	x+,@2	
                                 	st	x+,@1
                                 	st	x+,@0
                                 	.endmacro
                                 .macro	STX2	;r..r0
                                 	st	x+,@1
                                 	st	x+,@0
                                 	.endmacro
                                 	
                                 .macro	STY4	;r..r0		; store to (y+)
                                 	st	y+,@3
                                 	st	y+,@2	
                                 	st	y+,@1
                                 	st	y+,@0
                                 	.endmacro
                                 .macro	STY3	;r..r0
                                 	st	y+,@2	
                                 	st	y+,@1
                                 	st	y+,@0
                                 	.endmacro
                                 .macro	STY2	;r..r0	
                                 	st	y+,@1
                                 	st	y+,@0
                                 	.endmacro
                                 	
                                 .macro	STZ4	;r..r0		; store to (z+)
                                 	st	z+,@3
                                 	st	z+,@2	
                                 	st	z+,@1
                                 	st	z+,@0
                                 	.endmacro	
                                 .macro	STZ3	;r..r0
                                 	st	z+,@2	
                                 	st	z+,@1
                                 	st	z+,@0
                                 	.endmacro	
                                 .macro	STZ2	;r..r0	
                                 	st	z+,@1
                                 	st	z+,@0
                                 	.endmacro	
                                 	
                                 .macro	STI4	;addr,k		; store immediate
                                 	ldi	w,  low(@1)
                                 	sts	@0+0,w
                                 	ldi	w, high(@1)
                                 	sts	@0+1,w
                                 	ldi	w,byte3(@1)
                                 	sts	@0+2,w
                                 	ldi	w,byte4(@1)
                                 	sts	@0+3,w	
                                 	.endmacro	
                                 .macro	STI3	;addr,k
                                 	ldi	w,  low(@1)
                                 	sts	@0+0,w
                                 	ldi	w, high(@1)
                                 	sts	@0+1,w
                                 	ldi	w,byte3(@1)
                                 	sts	@0+2,w
                                 	.endmacro	
                                 .macro	STI2	;addr,k
                                 	ldi	w,  low(@1)
                                 	sts	@0+0,w
                                 	ldi	w, high(@1)
                                 	sts	@0+1,w
                                 	.endmacro
                                 .macro	STI	;addr,k
                                 	ldi	w,@1
                                 	sts	@0,w
                                 	.endmacro
                                 
                                 .macro	INC4			; increment
                                 	ldi	w,0xff
                                 	sub	@3,w
                                 	sbc	@2,w
                                 	sbc	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 .macro	INC3
                                 	ldi	w,0xff
                                 	sub	@2,w
                                 	sbc	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 .macro	INC2
                                 	ldi	w,0xff
                                 	sub	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 
                                 .macro	DEC4			; decrement
                                 	ldi	w,0xff
                                 	add	@3,w
                                 	adc	@2,w
                                 	adc	@1,w
                                 	adc	@0,w
                                 	.endmacro
                                 .macro	DEC3
                                 	ldi	w,0xff
                                 	add	@2,w
                                 	adc	@1,w
                                 	adc	@0,w
                                 	.endmacro
                                 .macro	DEC2
                                 	ldi	w,0xff
                                 	add	@1,w
                                 	adc	@0,w
                                 	.endmacro
                                 
                                 .macro	CLR9			; clear (also clears the carry)
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	clr	@4
                                 	clr	@5
                                 	clr	@6
                                 	clr	@7
                                 	clr	@8
                                 	.endmacro
                                 .macro	CLR8
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	clr	@4
                                 	clr	@5
                                 	clr	@6
                                 	clr	@7
                                 	.endmacro
                                 .macro	CLR7
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	clr	@4
                                 	clr	@5
                                 	clr	@6
                                 	.endmacro
                                 .macro	CLR6
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	clr	@4
                                 	clr	@5
                                 	.endmacro
                                 .macro	CLR5
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	clr	@4
                                 	.endmacro
                                 .macro	CLR4
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	.endmacro
                                 .macro	CLR3
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	.endmacro
                                 .macro	CLR2
                                 	sub	@0,@0
                                 	clr	@1
                                 	.endmacro
                                 
                                 .macro	COM4			; one's complement
                                 	com	@0
                                 	com	@1
                                 	com	@2
                                 	com	@3
                                 	.endmacro
                                 .macro	COM3
                                 	com	@0
                                 	com	@1
                                 	com	@2
                                 	.endmacro
                                 .macro	COM2
                                 	com	@0
                                 	com	@1
                                 	.endmacro
                                 
                                 .macro	NEG4			; negation (two's complement)
                                 	com	@0
                                 	com	@1
                                 	com	@2
                                 	com	@3
                                 	ldi	w,0xff
                                 	sub	@3,w
                                 	sbc	@2,w
                                 	sbc	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 .macro	NEG3
                                 	com	@0
                                 	com	@1
                                 	com	@2
                                 	ldi	w,0xff
                                 	sub	@2,w
                                 	sbc	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 .macro	NEG2
                                 	com	@0
                                 	com	@1
                                 	ldi	w,0xff
                                 	sub	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 	
                                 .macro	LDI4 	; r..r0, k	; load immediate
                                 	ldi	@3,  low(@4)
                                 	ldi	@2, high(@4)
                                 	ldi	@1,byte3(@4)
                                 	ldi	@0,byte4(@4)
                                 	.endmacro
                                 .macro	LDI3
                                 	ldi	@2,  low(@3)
                                 	ldi	@1, high(@3)
                                 	ldi	@0,byte3(@3)
                                 	.endmacro
                                 .macro	LDI2
                                 	ldi	@1,  low(@2)
                                 	ldi	@0, high(@2)
                                 	.endmacro
                                 
                                 .macro	LDS4			; load direct from SRAM
                                 	lds	@3,@4
                                 	lds	@2,@4+1
                                 	lds	@1,@4+2
                                 	lds	@0,@4+3
                                 	.endmacro
                                 .macro	LDS3
                                 	lds	@2,@3
                                 	lds	@1,@3+1
                                 	lds	@0,@3+2
                                 	.endmacro
                                 .macro	LDS2
                                 	lds	@1,@2
                                 	lds	@0,@2+1
                                 	.endmacro
                                 
                                 .macro	STS4			; store direct to SRAM
                                 	sts	@0+0,@4
                                 	sts	@0+1,@3
                                 	sts	@0+2,@2
                                 	sts	@0+3,@1
                                 	.endmacro
                                 .macro	STS3
                                 	sts	@0+0,@3
                                 	sts	@0+1,@2
                                 	sts	@0+2,@1
                                 	.endmacro
                                 .macro	STS2
                                 	sts	@0+0,@2
                                 	sts	@0+1,@1
                                 	.endmacro
                                 
                                 .macro	STDZ4	; d, r3,r2,r1,r0
                                 	std	z+@0+0,@4
                                 	std	z+@0+1,@3
                                 	std	z+@0+2,@2
                                 	std	z+@0+3,@1
                                 	.endmacro
                                 .macro	STDZ3	; d, r2,r1,r0
                                 	std	z+@0+0,@3
                                 	std	z+@0+1,@2
                                 	std	z+@0+2,@1
                                 	.endmacro
                                 .macro	STDZ2	; d, r1,r0
                                 	std	z+@0+0,@2
                                 	std	z+@0+1,@1
                                 	.endmacro
                                 	
                                 .macro	LPM4			; load program memory
                                 	lpm
                                 	mov	@3,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@2,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@1,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@0,r0
                                 	adiw	zl,1
                                 	.endmacro
                                 .macro	LPM3
                                 	lpm
                                 	mov	@2,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@1,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@0,r0
                                 	adiw	zl,1
                                 	.endmacro
                                 .macro	LPM2
                                 	lpm
                                 	mov	@1,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@0,r0
                                 	adiw	zl,1
                                 	.endmacro
                                 .macro	LPM1
                                 	lpm
                                 	mov	@0,r0
                                 	adiw	zl,1
                                 	.endmacro
                                 
                                 .macro	MOV4			; move between registers
                                 	mov	@3,@7
                                 	mov	@2,@6
                                 	mov	@1,@5
                                 	mov	@0,@4
                                 	.endmacro
                                 .macro	MOV3
                                 	mov	@2,@5
                                 	mov	@1,@4
                                 	mov	@0,@3
                                 	.endmacro
                                 .macro	MOV2
                                 	mov	@1,@3
                                 	mov	@0,@2
                                 	.endmacro
                                 
                                 .macro	ADD4			; add
                                 	add	@3,@7
                                 	adc	@2,@6
                                 	adc	@1,@5
                                 	adc	@0,@4
                                 	.endmacro
                                 .macro	ADD3
                                 	add	@2,@5
                                 	adc	@1,@4
                                 	adc	@0,@3
                                 	.endmacro
                                 .macro	ADD2
                                 	add	@1,@3
                                 	adc	@0,@2
                                 	.endmacro
                                 
                                 .macro	SUB4			; subtract
                                 	sub	@3,@7
                                 	sbc	@2,@6
                                 	sbc	@1,@5
                                 	sbc	@0,@4
                                 	.endmacro
                                 .macro	SUB3
                                 	sub	@2,@5
                                 	sbc	@1,@4
                                 	sbc	@0,@3
                                 	.endmacro
                                 .macro	SUB2
                                 	sub	@1,@3
                                 	sbc	@0,@2
                                 	.endmacro
                                 	
                                 .macro	CP4			; compare
                                 	cp	@3,@7
                                 	cpc	@2,@6
                                 	cpc	@1,@5
                                 	cpc	@0,@4
                                 	.endmacro
                                 .macro	CP3
                                 	cp	@2,@5
                                 	cpc	@1,@4
                                 	cpc	@0,@3
                                 	.endmacro
                                 .macro	CP2
                                 	cp	@1,@3
                                 	cpc	@0,@2
                                 	.endmacro
                                 
                                 .macro	TST4			; test
                                 	clr	w
                                 	cp	@3,w
                                 	cpc	@2,w
                                 	cpc	@1,w
                                 	cpc	@0,w
                                 	.endmacro
                                 .macro	TST3
                                 	clr	w
                                 	cp	@2,w
                                 	cpc	@1,w
                                 	cpc	@0,w
                                 	.endmacro
                                 .macro	TST2
                                 	clr	w
                                 	cp	@1,w
                                 	cpc	@0,w
                                 	.endmacro
                                 
                                 .macro	ADDI4			; add immediate
                                 	subi	@3,  low(-@4)
                                 	sbci	@2, high(-@4)
                                 	sbci	@1,byte3(-@4)
                                 	sbci	@0,byte4(-@4)
                                 	.endmacro
                                 .macro	ADDI3
                                 	subi	@2,  low(-@3)
                                 	sbci	@1, high(-@3)
                                 	sbci	@0,byte3(-@3)
                                 	.endmacro
                                 .macro	ADDI2
                                 	subi	@1,  low(-@2)
                                 	sbci	@0, high(-@2)
                                 	.endmacro
                                 	
                                 .macro	SUBI4			; subtract immediate
                                 	subi	@3,  low(@4)
                                 	sbci	@2, high(@4)
                                 	sbci	@1,byte3(@4)
                                 	sbci	@0,byte4(@4)
                                 	.endmacro
                                 .macro	SUBI3
                                 	subi	@2,  low(@3)
                                 	sbci	@1, high(@3)
                                 	sbci	@0,byte3(@3)
                                 	.endmacro
                                 .macro	SUBI2
                                 	subi	@1,  low(@2)
                                 	sbci	@0, high(@2)
                                 	.endmacro
                                 
                                 .macro	LSL5			; logical shift left
                                 	lsl	@4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	LSL4
                                 	lsl	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	LSL3
                                 	lsl	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	LSL2
                                 	lsl	@1
                                 	rol	@0
                                 	.endmacro
                                 	
                                 .macro	LSR4			; logical shift right
                                 	lsr	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	.endmacro
                                 .macro	LSR3
                                 	lsr	@0
                                 	ror	@1
                                 	ror	@2
                                 	.endmacro
                                 .macro	LSR2
                                 	lsr	@0
                                 	ror	@1
                                 	.endmacro
                                 
                                 .macro	ASR4			; arithmetic shift right
                                 	asr	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	.endmacro
                                 .macro	ASR3
                                 	asr	@0
                                 	ror	@1
                                 	ror	@2
                                 	.endmacro
                                 .macro	ASR2
                                 	asr	@0
                                 	ror	@1
                                 	.endmacro
                                 
                                 .macro	ROL8			; rotate left through carry
                                 	rol	@7
                                 	rol	@6
                                 	rol	@5
                                 	rol	@4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL7
                                 	rol	@6
                                 	rol	@5
                                 	rol	@4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL6
                                 	rol	@5
                                 	rol	@4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL5
                                 	rol	@4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 
                                 .macro	ROR8			; rotate right through carry
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	ror	@4
                                 	ror	@5
                                 	ror	@6
                                 	ror	@7
                                 	.endmacro
                                 .macro	ROR7
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	ror	@4
                                 	ror	@5
                                 	ror	@6
                                 	.endmacro
                                 .macro	ROR6
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	ror	@4
                                 	ror	@5
                                 	.endmacro
                                 .macro	ROR5
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	ror	@4
                                 	.endmacro	
                                 .macro	ROR4
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	.endmacro
                                 .macro	ROR3
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	.endmacro
                                 .macro	ROR2
                                 	ror	@0
                                 	ror	@1
                                 	.endmacro
                                 
                                 .macro	PUSH2
                                 	push	@0
                                 	push	@1
                                 	.endmacro	
                                 .macro	POP2
                                 	pop	@1
                                 	pop	@0
                                 	.endmacro
                                 
                                 .macro	PUSH3
                                 	push	@0
                                 	push	@1
                                 	push	@2
                                 	.endmacro	
                                 .macro	POP3
                                 	pop	@2
                                 	pop	@1
                                 	pop	@0
                                 	.endmacro
                                 	
                                 .macro	PUSH4
                                 	push	@0
                                 	push	@1
                                 	push	@2
                                 	push	@3
                                 	.endmacro	
                                 .macro	POP4
                                 	pop	@3
                                 	pop	@2
                                 	pop	@1
                                 	pop	@0
                                 	.endmacro	
                                 	
                                 .macro	PUSH5
                                 	push	@0
                                 	push	@1
                                 	push	@2
                                 	push	@3
                                 	push	@4
                                 	.endmacro	
                                 .macro	POP5
                                 	pop	@4
                                 	pop	@3
                                 	pop	@2
                                 	pop	@1
                                 	pop	@0
                                 	.endmacro	
                                 
                                 ; --- SRAM operations ---
                                 .macro	INCS4	; sram		; increment SRAM 4-byte variable
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	brne	end
                                 	lds	w,@0+1
                                 	inc	w
                                 	sts	@0+1,w
                                 	brne	end
                                 	lds	w,@0+2
                                 	inc	w
                                 	sts	@0+2,w
                                 	brne	end
                                 	lds	w,@0+3
                                 	inc	w
                                 	sts	@0+3,w
                                 end:	
                                 	.endmacro
                                 
                                 .macro	INCS3	; sram		; increment SRAM 3-byte variable
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	brne	end
                                 	lds	w,@0+1
                                 	inc	w
                                 	sts	@0+1,w
                                 	brne	end
                                 	lds	w,@0+2
                                 	inc	w
                                 	sts	@0+2,w
                                 end:	
                                 	.endmacro
                                 
                                 .macro	INCS2	; sram		; increment SRAM 2-byte variable
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	brne	end
                                 	lds	w,@0+1
                                 	inc	w
                                 	sts	@0+1,w
                                 end:	
                                 	.endmacro
                                 
                                 .macro	INCS	; sram		; increment SRAM 1-byte variable
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	.endmacro
                                 
                                 .macro	DECS4	; sram		; decrement SRAM 4-byte variable
                                 	ldi	w,1
                                 	lds	u,@0
                                 	sub	u,w
                                 	sts	@0,u
                                 	clr	w
                                 	lds	u,@0+1
                                 	sbc	u,w
                                 	sts	@0+1,u
                                 	lds	u,@0+2
                                 	sbc	u,w
                                 	sts	@0+2,u
                                 	lds	u,@0+3
                                 	sbc	u,w
                                 	sts	@0+3,u
                                 	.endmacro
                                 .macro	DECS3	; sram		; decrement SRAM 3-byte variable
                                 	ldi	w,1
                                 	lds	u,@0
                                 	sub	u,w
                                 	sts	@0,u
                                 	clr	w
                                 	lds	u,@0+1
                                 	sbc	u,w
                                 	sts	@0+1,u
                                 	lds	u,@0+2
                                 	sbc	u,w
                                 	sts	@0+2,u
                                 	.endmacro
                                 .macro	DECS2	; sram		; decrement SRAM 2-byte variable
                                 	ldi	w,1
                                 	lds	u,@0
                                 	sub	u,w
                                 	sts	@0,u
                                 	clr	w
                                 	lds	u,@0+1
                                 	sbc	u,w
                                 	sts	@0+1,u
                                 	.endmacro
                                 .macro	DECS	; sram		; decrement
                                 	lds	w,@0
                                 	dec	w
                                 	sts	@0,w
                                 	.endmacro
                                 
                                 .macro	MOVS4	; addr0,addr1	; [addr0] <-- [addr1]
                                 	lds	w,@1
                                 	sts	@0,w
                                 	lds	w,@1+1
                                 	sts	@0+1,w
                                 	lds	w,@1+2
                                 	sts	@0+2,w
                                 	lds	w,@3+1
                                 	sts	@0+3,w	
                                 	.endmacro
                                 .macro	MOVS3	; addr0,addr1	; [addr0] <-- [addr1]
                                 	lds	w,@1
                                 	sts	@0,w
                                 	lds	w,@1+1
                                 	sts	@0+1,w
                                 	lds	w,@1+2
                                 	sts	@0+2,w
                                 	.endmacro
                                 .macro	MOVS2	; addr0,addr1	; [addr0] <-- [addr1]
                                 	lds	w,@1
                                 	sts	@0,w
                                 	lds	w,@1+1
                                 	sts	@0+1,w
                                 	.endmacro
                                 .macro	MOVS	; addr0,addr1	; [addr0] <-- [addr1]
                                 	lds	w,@1
                                 	sts	@0,w
                                 	.endmacro
                                 
                                 .macro	SEXT	; reg1,reg0	; sign extend
                                 	clr	@0
                                 	sbrc	@1,7
                                 	dec	@0
                                 	.endmacro
                                 
                                 ; =======================================
                                 ;	Jump/Call with constant arguments
                                 ; =======================================
                                 	
                                 ; --- calls with arguments a,b,XYZ ---
                                 .macro	CX	; subroutine,x
                                 	ldi	xl, low(@1)
                                 	ldi	xh,high(@1)
                                 	rcall	@0
                                 	.endmacro
                                 .macro	CXY	; subroutine,x,y
                                 	ldi	xl, low(@1)
                                 	ldi	xh,high(@1)
                                 	ldi	yl, low(@2)
                                 	ldi	yh,high(@2)	
                                 	rcall	@0
                                 	.endmacro		
                                 .macro	CXZ	; subroutine,x,z
                                 	ldi	xl, low(@1)
                                 	ldi	xh,high(@1)
                                 	ldi	zl, low(@2)
                                 	ldi	zh,high(@2)	
                                 	rcall	@0
                                 	.endmacro		
                                 .macro	CXYZ	; subroutine,x,y,z
                                 	ldi	xl, low(@1)
                                 	ldi	xh,high(@1)
                                 	ldi	yl, low(@2)
                                 	ldi	yh,high(@2)
                                 	ldi	zl, low(@3)
                                 	ldi	zh,high(@3)		
                                 	rcall	@0
                                 	.endmacro
                                 .macro	CW	; subroutine,w
                                 	ldi	w, @1
                                 	rcall	@0
                                 	.endmacro
                                 .macro	CA	; subroutine,a
                                 	ldi	a0, @1
                                 	rcall	@0
                                 	.endmacro
                                 .macro	CAB	; subroutine,a,b
                                 	ldi	a0, @1
                                 	ldi	b0, @2
                                 	rcall	@0
                                 	.endmacro
                                 
                                 ; --- jump with arguments w,a,b ---
                                 .macro	JW	; subroutine,w
                                 	ldi	w, @1
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	JA	; subroutine,a
                                 	ldi	a0, @1
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	JAB	; subroutine,a,b
                                 	ldi	a0, @1
                                 	ldi	b0, @2
                                 	rjmp	@0
                                 	.endmacro
                                 .list
                                 .include	"Libraries\definitions.asm"	; include register/constant definitions
                                 
                                 ; purpose library, definition of addresses and constants
                                 ; 20171114 A.S.
                                 
                                 ; === definitions  ===
                                 .list
                                 
                                 .def	m = r6					;registre de travail
                                 .equ	th_addr = 0x0200		;address to store the high temp
                                 .equ	tl_addr = 0x0201		;address to store the low temp
                                 .equ	unit_addr = 0x0202		;address to store the unit
                                 .equ	m_eep_addr = 0x0000
                                 .equ	th_eep = 0x0001
                                 .equ	tl_eep = 0x0002
                                 
                                 .org	0
000000 940c 0898                 	jmp	reset
                                 
                                 .org OVF0addr
000020 940c 0888                 	jmp	ovf0
                                 
                                 .include	"temp.asm"
                                 
                                 ; purpose Dallas 1-wire(R) temperature sensor interfacing: temperature
                                 ; module: M5, input port: PORTB
                                 	
                                 .include	"Libraries\math_speed.asm"
                                 
                                 ; purpose library, mathematical routines, optimized for speed
                                 ; copyright R.Holzer	
                                 
                                 ; === multiplication ===
                                 
                                 .macro	M11
                                 	sbrc	b0,@0
                                 	add	c1,a0
                                 	ror	c1
                                 	ror	c0
                                 .endmacro
000022 1899
000023 2488                      mul11:	CLR2	c1,c0	; clears also the carry
000024 fd60
000025 0e92
000026 9497
000027 9487                      	M11	0
000028 fd61
000029 0e92
00002a 9497
00002b 9487                      	M11	1
00002c fd62
00002d 0e92
00002e 9497
00002f 9487                      	M11	2
000030 fd63
000031 0e92
000032 9497
000033 9487                      	M11	3
000034 fd64
000035 0e92
000036 9497
000037 9487                      	M11	4
000038 fd65
000039 0e92
00003a 9497
00003b 9487                      	M11	5
00003c fd66
00003d 0e92
00003e 9497
00003f 9487                      	M11	6
000040 fd67
000041 0e92
000042 9497
000043 9487                      	M11	7
000044 9508                      	ret
                                 
                                 .macro	M21
                                 	sbrs	b0,@0
                                 	rjmp	PC+3
                                 	add	c1,a0
                                 	adc	c2,a1
                                 	ror	c2	; shift-in carry from MSB addition
                                 	ror	c1
                                 	ror	c0
                                 .endmacro
000045 18aa
000046 2499
000047 2488                      mul21:	CLR3	c2,c1,c0
000048 ff60
000049 c002
00004a 0e92
00004b 1ea3
00004c 94a7
00004d 9497
00004e 9487                      	M21	0
00004f ff61
000050 c002
000051 0e92
000052 1ea3
000053 94a7
000054 9497
000055 9487                      	M21	1
000056 ff62
000057 c002
000058 0e92
000059 1ea3
00005a 94a7
00005b 9497
00005c 9487                      	M21	2
00005d ff63
00005e c002
00005f 0e92
000060 1ea3
000061 94a7
000062 9497
000063 9487                      	M21	3
000064 ff64
000065 c002
000066 0e92
000067 1ea3
000068 94a7
000069 9497
00006a 9487                      	M21	4
00006b ff65
00006c c002
00006d 0e92
00006e 1ea3
00006f 94a7
000070 9497
000071 9487                      	M21	5
000072 ff66
000073 c002
000074 0e92
000075 1ea3
000076 94a7
000077 9497
000078 9487                      	M21	6
000079 ff67
00007a c002
00007b 0e92
00007c 1ea3
00007d 94a7
00007e 9497
00007f 9487                      	M21	7
000080 9508                      	ret
                                 	
                                 .macro	M22
                                 	sbrs	b0,@0
                                 	rjmp	PC+4
                                 	add	c1,a0
                                 	adc	c2,a1
                                 	adc	c3,r0	; propagate the carry (r0=0)
                                 	sbrs	b1,@0
                                 	rjmp	PC+3
                                 	add	c2,a0
                                 	adc	c3,a1
                                 	ror	c3	; shift-in carry from MSB addition
                                 	ror	c2
                                 	ror	c1
                                 	ror	c0
                                 .endmacro
000081 18bb
000082 24aa
000083 2499
000084 2488
000085 2400                      mul22:	CLR5	c3,c2,c1,c0,r0
000086 ff60
000087 c003
000088 0e92
000089 1ea3
00008a 1cb0
00008b ff70
00008c c002
00008d 0ea2
00008e 1eb3
00008f 94b7
000090 94a7
000091 9497
000092 9487                      	M22	0
000093 ff61
000094 c003
000095 0e92
000096 1ea3
000097 1cb0
000098 ff71
000099 c002
00009a 0ea2
00009b 1eb3
00009c 94b7
00009d 94a7
00009e 9497
00009f 9487                      	M22	1
0000a0 ff62
0000a1 c003
0000a2 0e92
0000a3 1ea3
0000a4 1cb0
0000a5 ff72
0000a6 c002
0000a7 0ea2
0000a8 1eb3
0000a9 94b7
0000aa 94a7
0000ab 9497
0000ac 9487                      	M22	2
0000ad ff63
0000ae c003
0000af 0e92
0000b0 1ea3
0000b1 1cb0
0000b2 ff73
0000b3 c002
0000b4 0ea2
0000b5 1eb3
0000b6 94b7
0000b7 94a7
0000b8 9497
0000b9 9487                      	M22	3
0000ba ff64
0000bb c003
0000bc 0e92
0000bd 1ea3
0000be 1cb0
0000bf ff74
0000c0 c002
0000c1 0ea2
0000c2 1eb3
0000c3 94b7
0000c4 94a7
0000c5 9497
0000c6 9487                      	M22	4
0000c7 ff65
0000c8 c003
0000c9 0e92
0000ca 1ea3
0000cb 1cb0
0000cc ff75
0000cd c002
0000ce 0ea2
0000cf 1eb3
0000d0 94b7
0000d1 94a7
0000d2 9497
0000d3 9487                      	M22	5
0000d4 ff66
0000d5 c003
0000d6 0e92
0000d7 1ea3
0000d8 1cb0
0000d9 ff76
0000da c002
0000db 0ea2
0000dc 1eb3
0000dd 94b7
0000de 94a7
0000df 9497
0000e0 9487                      	M22	6
0000e1 ff67
0000e2 c003
0000e3 0e92
0000e4 1ea3
0000e5 1cb0
0000e6 ff77
0000e7 c002
0000e8 0ea2
0000e9 1eb3
0000ea 94b7
0000eb 94a7
0000ec 9497
0000ed 9487                      	M22	7
0000ee 9508                      	ret
                                 
                                 .macro	M31
                                 	sbrs	b0,@0
                                 	rjmp	PC+4
                                 	add	c1,a0
                                 	adc	c2,a1
                                 	adc	c3,a2
                                 	ror	c3
                                 	ror	c2
                                 	ror	c1
                                 	ror	c0
                                 .endmacro
0000ef 18bb
0000f0 24aa
0000f1 2499
0000f2 2488                      mul31:	CLR4	c3,c2,c1,c0
0000f3 ff60
0000f4 c003
0000f5 0e92
0000f6 1ea3
0000f7 1eb4
0000f8 94b7
0000f9 94a7
0000fa 9497
0000fb 9487                      	M31	0
0000fc ff61
0000fd c003
0000fe 0e92
0000ff 1ea3
000100 1eb4
000101 94b7
000102 94a7
000103 9497
000104 9487                      	M31	1
000105 ff62
000106 c003
000107 0e92
000108 1ea3
000109 1eb4
00010a 94b7
00010b 94a7
00010c 9497
00010d 9487                      	M31	2
00010e ff63
00010f c003
000110 0e92
000111 1ea3
000112 1eb4
000113 94b7
000114 94a7
000115 9497
000116 9487                      	M31	3
000117 ff64
000118 c003
000119 0e92
00011a 1ea3
00011b 1eb4
00011c 94b7
00011d 94a7
00011e 9497
00011f 9487                      	M31	4
000120 ff65
000121 c003
000122 0e92
000123 1ea3
000124 1eb4
000125 94b7
000126 94a7
000127 9497
000128 9487                      	M31	5
000129 ff66
00012a c003
00012b 0e92
00012c 1ea3
00012d 1eb4
00012e 94b7
00012f 94a7
000130 9497
000131 9487                      	M31	6
000132 ff67
000133 c003
000134 0e92
000135 1ea3
000136 1eb4
000137 94b7
000138 94a7
000139 9497
00013a 9487                      	M31	7
00013b 9508                      	ret	
                                 
                                 .macro	M32
                                 	sbrs	b0,@0
                                 	rjmp	PC+5
                                 	add	c1,a0
                                 	adc	c2,a1
                                 	adc	c3,a2
                                 	adc	d0,r0
                                 	sbrs	b1,@0
                                 	rjmp	PC+4
                                 	add	c2,a0
                                 	adc	c3,a1
                                 	adc	d0,a2
                                 	ror	d0
                                 	ror	c3
                                 	ror	c2
                                 	ror	c1
                                 	ror	c0
                                 .endmacro
00013c 18cc
00013d 24bb
00013e 24aa
00013f 2499
000140 2488
000141 2400                      mul32:	CLR6	d0,c3,c2,c1,c0,r0
000142 ff60
000143 c004
000144 0e92
000145 1ea3
000146 1eb4
000147 1cc0
000148 ff70
000149 c003
00014a 0ea2
00014b 1eb3
00014c 1ec4
00014d 94c7
00014e 94b7
00014f 94a7
000150 9497
000151 9487                      	M32	0
000152 ff61
000153 c004
000154 0e92
000155 1ea3
000156 1eb4
000157 1cc0
000158 ff71
000159 c003
00015a 0ea2
00015b 1eb3
00015c 1ec4
00015d 94c7
00015e 94b7
00015f 94a7
000160 9497
000161 9487                      	M32	1
000162 ff62
000163 c004
000164 0e92
000165 1ea3
000166 1eb4
000167 1cc0
000168 ff72
000169 c003
00016a 0ea2
00016b 1eb3
00016c 1ec4
00016d 94c7
00016e 94b7
00016f 94a7
000170 9497
000171 9487                      	M32	2
000172 ff63
000173 c004
000174 0e92
000175 1ea3
000176 1eb4
000177 1cc0
000178 ff73
000179 c003
00017a 0ea2
00017b 1eb3
00017c 1ec4
00017d 94c7
00017e 94b7
00017f 94a7
000180 9497
000181 9487                      	M32	3
000182 ff64
000183 c004
000184 0e92
000185 1ea3
000186 1eb4
000187 1cc0
000188 ff74
000189 c003
00018a 0ea2
00018b 1eb3
00018c 1ec4
00018d 94c7
00018e 94b7
00018f 94a7
000190 9497
000191 9487                      	M32	4
000192 ff65
000193 c004
000194 0e92
000195 1ea3
000196 1eb4
000197 1cc0
000198 ff75
000199 c003
00019a 0ea2
00019b 1eb3
00019c 1ec4
00019d 94c7
00019e 94b7
00019f 94a7
0001a0 9497
0001a1 9487                      	M32	5
0001a2 ff66
0001a3 c004
0001a4 0e92
0001a5 1ea3
0001a6 1eb4
0001a7 1cc0
0001a8 ff76
0001a9 c003
0001aa 0ea2
0001ab 1eb3
0001ac 1ec4
0001ad 94c7
0001ae 94b7
0001af 94a7
0001b0 9497
0001b1 9487                      	M32	6
0001b2 ff67
0001b3 c004
0001b4 0e92
0001b5 1ea3
0001b6 1eb4
0001b7 1cc0
0001b8 ff77
0001b9 c003
0001ba 0ea2
0001bb 1eb3
0001bc 1ec4
0001bd 94c7
0001be 94b7
0001bf 94a7
0001c0 9497
0001c1 9487                      	M32	7
0001c2 9508                      	ret
                                 
                                 .macro	M33
                                 	sbrs	b0,@0
                                 	rjmp	PC+5
                                 	add	c1,a0
                                 	adc	c2,a1
                                 	adc	c3,a2
                                 	adc	d0,r0
                                 	adc	d1,r0
                                 	sbrs	b1,@0
                                 	rjmp	PC+4
                                 	add	c2,a0
                                 	adc	c3,a1
                                 	adc	d0,a2
                                 	adc	d1,r0
                                 	sbrs	b2,@0
                                 	rjmp	PC+4
                                 	add	c3,a0
                                 	adc	c0,a1
                                 	adc	d1,a2
                                 	ror	d1
                                 	ror	d0
                                 	ror	c3
                                 	ror	c2
                                 	ror	c1
                                 	ror	c0
                                 .endmacro
0001c3 18dd
0001c4 24cc
0001c5 24bb
0001c6 24aa
0001c7 2499
0001c8 2488
0001c9 2400                      mul33:	CLR7	d1,d0,c3,c2,c1,c0,r0
0001ca ff60
0001cb c004
0001cc 0e92
0001cd 1ea3
0001ce 1eb4
0001cf 1cc0
0001d0 1cd0
0001d1 ff70
0001d2 c003
0001d3 0ea2
0001d4 1eb3
0001d5 1ec4
0001d6 1cd0
0001d7 ff80
0001d8 c003
0001d9 0eb2
0001da 1e83
0001db 1ed4
0001dc 94d7
0001dd 94c7
0001de 94b7
0001df 94a7
0001e0 9497
0001e1 9487                      	M33	0
0001e2 ff61
0001e3 c004
0001e4 0e92
0001e5 1ea3
0001e6 1eb4
0001e7 1cc0
0001e8 1cd0
0001e9 ff71
0001ea c003
0001eb 0ea2
0001ec 1eb3
0001ed 1ec4
0001ee 1cd0
0001ef ff81
0001f0 c003
0001f1 0eb2
0001f2 1e83
0001f3 1ed4
0001f4 94d7
0001f5 94c7
0001f6 94b7
0001f7 94a7
0001f8 9497
0001f9 9487                      	M33	1
0001fa ff62
0001fb c004
0001fc 0e92
0001fd 1ea3
0001fe 1eb4
0001ff 1cc0
000200 1cd0
000201 ff72
000202 c003
000203 0ea2
000204 1eb3
000205 1ec4
000206 1cd0
000207 ff82
000208 c003
000209 0eb2
00020a 1e83
00020b 1ed4
00020c 94d7
00020d 94c7
00020e 94b7
00020f 94a7
000210 9497
000211 9487                      	M33	2
000212 ff63
000213 c004
000214 0e92
000215 1ea3
000216 1eb4
000217 1cc0
000218 1cd0
000219 ff73
00021a c003
00021b 0ea2
00021c 1eb3
00021d 1ec4
00021e 1cd0
00021f ff83
000220 c003
000221 0eb2
000222 1e83
000223 1ed4
000224 94d7
000225 94c7
000226 94b7
000227 94a7
000228 9497
000229 9487                      	M33	3
00022a ff64
00022b c004
00022c 0e92
00022d 1ea3
00022e 1eb4
00022f 1cc0
000230 1cd0
000231 ff74
000232 c003
000233 0ea2
000234 1eb3
000235 1ec4
000236 1cd0
000237 ff84
000238 c003
000239 0eb2
00023a 1e83
00023b 1ed4
00023c 94d7
00023d 94c7
00023e 94b7
00023f 94a7
000240 9497
000241 9487                      	M33	4
000242 ff65
000243 c004
000244 0e92
000245 1ea3
000246 1eb4
000247 1cc0
000248 1cd0
000249 ff75
00024a c003
00024b 0ea2
00024c 1eb3
00024d 1ec4
00024e 1cd0
00024f ff85
000250 c003
000251 0eb2
000252 1e83
000253 1ed4
000254 94d7
000255 94c7
000256 94b7
000257 94a7
000258 9497
000259 9487                      	M33	5
00025a ff66
00025b c004
00025c 0e92
00025d 1ea3
00025e 1eb4
00025f 1cc0
000260 1cd0
000261 ff76
000262 c003
000263 0ea2
000264 1eb3
000265 1ec4
000266 1cd0
000267 ff86
000268 c003
000269 0eb2
00026a 1e83
00026b 1ed4
00026c 94d7
00026d 94c7
00026e 94b7
00026f 94a7
000270 9497
000271 9487                      	M33	6
000272 ff67
000273 c004
000274 0e92
000275 1ea3
000276 1eb4
000277 1cc0
000278 1cd0
000279 ff77
00027a c003
00027b 0ea2
00027c 1eb3
00027d 1ec4
00027e 1cd0
00027f ff87
000280 c003
000281 0eb2
000282 1e83
000283 1ed4
000284 94d7
000285 94c7
000286 94b7
000287 94a7
000288 9497
000289 9487                      	M33	7
00028a 9508                      	ret
                                 
                                 .macro	M44
                                 	sbrs	b0,@0
                                 	rjmp	PC+8
                                 	add	c1,a0
                                 	adc	c2,a1
                                 	adc	c3,a2
                                 	adc	d0,a3
                                 	adc	d1,r0
                                 	adc	d2,r0
                                 	adc	d3,r0
                                 	
                                 	sbrs	b1,@0
                                 	rjmp	PC+7
                                 	add	c2,a0
                                 	adc	c3,a1
                                 	adc	d0,a2
                                 	adc	d1,a3
                                 	adc	d2,r0
                                 	adc	d3,r0	
                                 	
                                 	sbrs	b2,@0
                                 	rjmp	PC+6
                                 	add	c3,a0
                                 	adc	d0,a1
                                 	adc	d1,a2
                                 	adc	d2,a3
                                 	adc	d3,r0
                                 	
                                 	sbrs	b3,@0
                                 	rjmp	PC+5
                                 	add	d0,a0
                                 	adc	d1,a1
                                 	adc	d2,a2
                                 	adc	d3,a3
                                 	
                                 	ror	d3
                                 	ror	d2
                                 	ror	d1
                                 	ror	d0
                                 	ror	c3
                                 	ror	c2
                                 	ror	c1
                                 	ror	c0
                                 .endmacro
00028b 18ff
00028c 24ee
00028d 24dd
00028e 24cc
00028f 24bb
000290 24aa
000291 2499
000292 2488
000293 2400                      mul44:	CLR9	d3,d2,d1,d0,c3,c2,c1,c0,r0	
000294 ff60
000295 c007
000296 0e92
000297 1ea3
000298 1eb4
000299 1ec5
00029a 1cd0
00029b 1ce0
00029c 1cf0
00029d ff70
00029e c006
00029f 0ea2
0002a0 1eb3
0002a1 1ec4
0002a2 1ed5
0002a3 1ce0
0002a4 1cf0
0002a5 ff80
0002a6 c005
0002a7 0eb2
0002a8 1ec3
0002a9 1ed4
0002aa 1ee5
0002ab 1cf0
0002ac ff90
0002ad c004
0002ae 0ec2
0002af 1ed3
0002b0 1ee4
0002b1 1ef5
0002b2 94f7
0002b3 94e7
0002b4 94d7
0002b5 94c7
0002b6 94b7
0002b7 94a7
0002b8 9497
0002b9 9487                      	M44	0
0002ba ff61
0002bb c007
0002bc 0e92
0002bd 1ea3
0002be 1eb4
0002bf 1ec5
0002c0 1cd0
0002c1 1ce0
0002c2 1cf0
0002c3 ff71
0002c4 c006
0002c5 0ea2
0002c6 1eb3
0002c7 1ec4
0002c8 1ed5
0002c9 1ce0
0002ca 1cf0
0002cb ff81
0002cc c005
0002cd 0eb2
0002ce 1ec3
0002cf 1ed4
0002d0 1ee5
0002d1 1cf0
0002d2 ff91
0002d3 c004
0002d4 0ec2
0002d5 1ed3
0002d6 1ee4
0002d7 1ef5
0002d8 94f7
0002d9 94e7
0002da 94d7
0002db 94c7
0002dc 94b7
0002dd 94a7
0002de 9497
0002df 9487                      	M44	1
0002e0 ff62
0002e1 c007
0002e2 0e92
0002e3 1ea3
0002e4 1eb4
0002e5 1ec5
0002e6 1cd0
0002e7 1ce0
0002e8 1cf0
0002e9 ff72
0002ea c006
0002eb 0ea2
0002ec 1eb3
0002ed 1ec4
0002ee 1ed5
0002ef 1ce0
0002f0 1cf0
0002f1 ff82
0002f2 c005
0002f3 0eb2
0002f4 1ec3
0002f5 1ed4
0002f6 1ee5
0002f7 1cf0
0002f8 ff92
0002f9 c004
0002fa 0ec2
0002fb 1ed3
0002fc 1ee4
0002fd 1ef5
0002fe 94f7
0002ff 94e7
000300 94d7
000301 94c7
000302 94b7
000303 94a7
000304 9497
000305 9487                      	M44	2
000306 ff63
000307 c007
000308 0e92
000309 1ea3
00030a 1eb4
00030b 1ec5
00030c 1cd0
00030d 1ce0
00030e 1cf0
00030f ff73
000310 c006
000311 0ea2
000312 1eb3
000313 1ec4
000314 1ed5
000315 1ce0
000316 1cf0
000317 ff83
000318 c005
000319 0eb2
00031a 1ec3
00031b 1ed4
00031c 1ee5
00031d 1cf0
00031e ff93
00031f c004
000320 0ec2
000321 1ed3
000322 1ee4
000323 1ef5
000324 94f7
000325 94e7
000326 94d7
000327 94c7
000328 94b7
000329 94a7
00032a 9497
00032b 9487                      	M44	3
00032c ff64
00032d c007
00032e 0e92
00032f 1ea3
000330 1eb4
000331 1ec5
000332 1cd0
000333 1ce0
000334 1cf0
000335 ff74
000336 c006
000337 0ea2
000338 1eb3
000339 1ec4
00033a 1ed5
00033b 1ce0
00033c 1cf0
00033d ff84
00033e c005
00033f 0eb2
000340 1ec3
000341 1ed4
000342 1ee5
000343 1cf0
000344 ff94
000345 c004
000346 0ec2
000347 1ed3
000348 1ee4
000349 1ef5
00034a 94f7
00034b 94e7
00034c 94d7
00034d 94c7
00034e 94b7
00034f 94a7
000350 9497
000351 9487                      	M44	4
000352 ff65
000353 c007
000354 0e92
000355 1ea3
000356 1eb4
000357 1ec5
000358 1cd0
000359 1ce0
00035a 1cf0
00035b ff75
00035c c006
00035d 0ea2
00035e 1eb3
00035f 1ec4
000360 1ed5
000361 1ce0
000362 1cf0
000363 ff85
000364 c005
000365 0eb2
000366 1ec3
000367 1ed4
000368 1ee5
000369 1cf0
00036a ff95
00036b c004
00036c 0ec2
00036d 1ed3
00036e 1ee4
00036f 1ef5
000370 94f7
000371 94e7
000372 94d7
000373 94c7
000374 94b7
000375 94a7
000376 9497
000377 9487                      	M44	5
000378 ff66
000379 c007
00037a 0e92
00037b 1ea3
00037c 1eb4
00037d 1ec5
00037e 1cd0
00037f 1ce0
000380 1cf0
000381 ff76
000382 c006
000383 0ea2
000384 1eb3
000385 1ec4
000386 1ed5
000387 1ce0
000388 1cf0
000389 ff86
00038a c005
00038b 0eb2
00038c 1ec3
00038d 1ed4
00038e 1ee5
00038f 1cf0
000390 ff96
000391 c004
000392 0ec2
000393 1ed3
000394 1ee4
000395 1ef5
000396 94f7
000397 94e7
000398 94d7
000399 94c7
00039a 94b7
00039b 94a7
00039c 9497
00039d 9487                      	M44	6
00039e ff67
00039f c007
0003a0 0e92
0003a1 1ea3
0003a2 1eb4
0003a3 1ec5
0003a4 1cd0
0003a5 1ce0
0003a6 1cf0
0003a7 ff77
0003a8 c006
0003a9 0ea2
0003aa 1eb3
0003ab 1ec4
0003ac 1ed5
0003ad 1ce0
0003ae 1cf0
0003af ff87
0003b0 c005
0003b1 0eb2
0003b2 1ec3
0003b3 1ed4
0003b4 1ee5
0003b5 1cf0
0003b6 ff97
0003b7 c004
0003b8 0ec2
0003b9 1ed3
0003ba 1ee4
0003bb 1ef5
0003bc 94f7
0003bd 94e7
0003be 94d7
0003bf 94c7
0003c0 94b7
0003c1 94a7
0003c2 9497
0003c3 9487                      	M44	7
0003c4 9508                      	ret
                                 
                                 ; === signed multiplication ===		
0003c5 dc5c                      mul11s: rcall	mul11
0003c6 fd27                      	sbrc	a0,7
0003c7 1a96                      	sub	c1,b0
0003c8 fd67                      	sbrc	b0,7
0003c9 1a92                      	sub	c1,a0
0003ca 9508                      	ret
                                 
0003cb dcb5                      mul22s: rcall	mul22
0003cc ff37                      	sbrs	a1,7
0003cd c002                      	rjmp	PC+3
0003ce 1aa6
0003cf 0ab7                      	SUB2	c3,c2, b1,b0
0003d0 ff77                      	sbrs	b1,7
0003d1 c002                      	rjmp	PC+3	
0003d2 1aa2
0003d3 0ab3                      	SUB2	c3,c2, a1,a0
0003d4 9508                      	ret
                                 
0003d5 dded                      mul33s: rcall	mul33
0003d6 ff47                      	sbrs	a2,7
0003d7 c003                      	rjmp	PC+4
0003d8 1ab6
0003d9 0ac7
0003da 0ad8                      	SUB3	d1,d0,c3, b2,b1,b0
0003db ff87                      	sbrs	b2,7
0003dc c003                      	rjmp	PC+4
0003dd 1ab2
0003de 0ac3
0003df 0ad4                      	SUB3	d1,d0,c3, a2,a1,a0
0003e0 9508                      	ret
                                 
0003e1 dea9                      mul44s: rcall	mul44
0003e2 ff57                      	sbrs	a3,7
0003e3 c004                      	rjmp	PC+5
0003e4 1ac6
0003e5 0ad7
0003e6 0ae8
0003e7 0af9                      	SUB4	d3,d2,d1,d0, b3,b2,b1,b0
0003e8 ff97                      	sbrs	b3,7
0003e9 c004                      	rjmp	PC+5
0003ea 1ac2
0003eb 0ad3
0003ec 0ae4
0003ed 0af5                      	SUB4	d3,d2,d1,d0, a3,a2,a1,a0
0003ee 9508                      	ret
                                 
                                 ; === division ===
                                 .macro	D11
                                 	rol	c0
                                 	rol	d0
                                 	sub	d0,b0	; subtract b from remainder a
                                 	brcc	PC+2
                                 	add	d0,b0	; restore if negative
                                 .endmacro
0003ef 2e82                      div11:	mov	c0,a0	; load a into shift register
0003f0 18cc                      	sub	d0,d0	; clear c1 and carry=0
0003f1 1c88
0003f2 1ccc
0003f3 1ac6
0003f4 f408
0003f5 0ec6                      	D11
0003f6 1c88
0003f7 1ccc
0003f8 1ac6
0003f9 f408
0003fa 0ec6                      	D11	
0003fb 1c88
0003fc 1ccc
0003fd 1ac6
0003fe f408
0003ff 0ec6                      	D11
000400 1c88
000401 1ccc
000402 1ac6
000403 f408
000404 0ec6                      	D11	
000405 1c88
000406 1ccc
000407 1ac6
000408 f408
000409 0ec6                      	D11
00040a 1c88
00040b 1ccc
00040c 1ac6
00040d f408
00040e 0ec6                      	D11	
00040f 1c88
000410 1ccc
000411 1ac6
000412 f408
000413 0ec6                      	D11
000414 1c88
000415 1ccc
000416 1ac6
000417 f408
000418 0ec6                      	D11
000419 1c88                      	rol	c0
00041a 9480                      	com	c0	; invert the bits
00041b 9508                      	ret
                                 
                                 .macro	D22
                                 	rol	c0
                                 	rol	c1
                                 	rol	d0
                                 	rol	d1
                                 	sub	d0,b0	; subtract b from a
                                 	sbc	d1,b1
                                 	brcc	PC+3
                                 	add	d0,b0	; restore if negative
                                 	adc	d1,b1
                                 .endmacro
00041c 2e82
00041d 2e93                      div22:	MOV2	c1,c0, a1,a0 ; load a into shift register
00041e 18dd
00041f 24cc                      	CLR2	d1,d0
000420 1c88
000421 1c99
000422 1ccc
000423 1cdd
000424 1ac6
000425 0ad7
000426 f410
000427 0ec6
000428 1ed7                      	D22
000429 1c88
00042a 1c99
00042b 1ccc
00042c 1cdd
00042d 1ac6
00042e 0ad7
00042f f410
000430 0ec6
000431 1ed7                      	D22
000432 1c88
000433 1c99
000434 1ccc
000435 1cdd
000436 1ac6
000437 0ad7
000438 f410
000439 0ec6
00043a 1ed7                      	D22
00043b 1c88
00043c 1c99
00043d 1ccc
00043e 1cdd
00043f 1ac6
000440 0ad7
000441 f410
000442 0ec6
000443 1ed7                      	D22
000444 1c88
000445 1c99
000446 1ccc
000447 1cdd
000448 1ac6
000449 0ad7
00044a f410
00044b 0ec6
00044c 1ed7                      	D22
00044d 1c88
00044e 1c99
00044f 1ccc
000450 1cdd
000451 1ac6
000452 0ad7
000453 f410
000454 0ec6
000455 1ed7                      	D22
000456 1c88
000457 1c99
000458 1ccc
000459 1cdd
00045a 1ac6
00045b 0ad7
00045c f410
00045d 0ec6
00045e 1ed7                      	D22
00045f 1c88
000460 1c99
000461 1ccc
000462 1cdd
000463 1ac6
000464 0ad7
000465 f410
000466 0ec6
000467 1ed7                      	D22
000468 1c88
000469 1c99
00046a 1ccc
00046b 1cdd
00046c 1ac6
00046d 0ad7
00046e f410
00046f 0ec6
000470 1ed7                      	D22
000471 1c88
000472 1c99
000473 1ccc
000474 1cdd
000475 1ac6
000476 0ad7
000477 f410
000478 0ec6
000479 1ed7                      	D22
00047a 1c88
00047b 1c99
00047c 1ccc
00047d 1cdd
00047e 1ac6
00047f 0ad7
000480 f410
000481 0ec6
000482 1ed7                      	D22
000483 1c88
000484 1c99
000485 1ccc
000486 1cdd
000487 1ac6
000488 0ad7
000489 f410
00048a 0ec6
00048b 1ed7                      	D22
00048c 1c88
00048d 1c99
00048e 1ccc
00048f 1cdd
000490 1ac6
000491 0ad7
000492 f410
000493 0ec6
000494 1ed7                      	D22
000495 1c88
000496 1c99
000497 1ccc
000498 1cdd
000499 1ac6
00049a 0ad7
00049b f410
00049c 0ec6
00049d 1ed7                      	D22
00049e 1c88
00049f 1c99
0004a0 1ccc
0004a1 1cdd
0004a2 1ac6
0004a3 0ad7
0004a4 f410
0004a5 0ec6
0004a6 1ed7                      	D22
0004a7 1c88
0004a8 1c99
0004a9 1ccc
0004aa 1cdd
0004ab 1ac6
0004ac 0ad7
0004ad f410
0004ae 0ec6
0004af 1ed7                      	D22
0004b0 1c88
0004b1 1c99                      	ROL2	c1,c0	; last shift
0004b2 9490
0004b3 9480                      	COM2	c1,c0	; invert the bits
                                 .include	"Libraries\lcd.asm"			; include LCD driver routines
0004b4 9508                      
                                 ; purpose  LCD HD44780U library
                                 ; ATmega 128 and Atmel Studio 7.0 compliant
                                 
                                 ; === definitions ===
                                 .equ	LCD_IR	= 0x8000	; address LCD instruction reg
                                 .equ	LCD_DR	= 0xc000	; address LCD data register
                                 
                                 ; === subroutines ===
                                 LCD_wr_ir:
                                 ; in	w (byte to write to LCD IR)
0004b5 9030 8000                 	lds	u, LCD_IR		; read IR to check busy flag  (bit7)
0004b7 fc37
0004b8 cffc                      	JB1	u,7,LCD_wr_ir	; Jump if Bit=1 (still busy)
0004b9 d003                      	rcall	lcd_4us		; delay to increment DRAM addr counter
0004ba 9300 8000                 	sts	LCD_IR, w		; store w in IR
0004bc 9508                      	ret
                                 	
                                 lcd_4us:
0004bd d000                      	rcall	lcd_2us		; recursive call		
                                 lcd_2us:
0004be 0000                      	nop					; rcall(3) + nop(1) + ret(4) = 8 cycles (2us)
0004bf 9508                      	ret
                                 
                                 LCD:
                                 LCD_putc:
0004c0 302d
0004c1 f169                      	JK	a0,CR,LCD_cr	; Jump if a0=CR
0004c2 302a
0004c3 f1a9                      	JK	a0,LF,LCD_lf	; Jump if a0=LF
                                 LCD_wr_dr:
                                 ; in	a0 (byte to write to LCD DR)
0004c4 9100 8000                 	lds	w, LCD_IR		; read IR to check busy flag  (bit7)
0004c6 fd07
0004c7 cffc                      	JB1	w,7,LCD_wr_dr	; Jump if Bit=1 (still busy)
0004c8 dff4                      	rcall	lcd_4us		; delay to increment DRAM addr counter
0004c9 9320 c000                 	sts	LCD_DR, a0		; store a0 in DR
0004cb 9508                      	ret	
                                 	
0004cc e001
0004cd cfe7                      LCD_clear:		JW	LCD_wr_ir, 0b00000001		; clear display
0004ce e002
0004cf cfe5                      LCD_home:		JW	LCD_wr_ir, 0b00000010		; return home
0004d0 e100
0004d1 cfe3                      LCD_cursor_left:	JW	LCD_wr_ir, 0b00010000	; move cursor to left
0004d2 e104
0004d3 cfe1                      LCD_cursor_right:	JW	LCD_wr_ir, 0b00010100	; move cursor to right
0004d4 e108
0004d5 cfdf                      LCD_display_left:	JW	LCD_wr_ir, 0b00011000	; shifts display to left
0004d6 e10c
0004d7 cfdd                      LCD_display_right:	JW	LCD_wr_ir, 0b00011100	; shifts display to right
0004d8 e00d
0004d9 cfdb                      LCD_blink_on:		JW	LCD_wr_ir, 0b00001101	; Display=1,Cursor=0,Blink=1
0004da e00c
0004db cfd9                      LCD_blink_off:		JW	LCD_wr_ir, 0b00001100	; Display=1,Cursor=0,Blink=0
0004dc e00e
0004dd cfd7                      LCD_cursor_on:		JW	LCD_wr_ir, 0b00001110	; Display=1,Cursor=1,Blink=0
0004de e00c
0004df cfd5                      LCD_cursor_off:		JW	LCD_wr_ir, 0b00001100	; Display=1,Cursor=0,Blink=0
                                 		
                                 LCD_init:
0004e0 b705                      	in	w,MCUCR					; enable access to ext. SRAM
0004e1 6c00                      	sbr	w,(1<<SRE)+(1<<SRW10)
0004e2 bf05                      	out	MCUCR,w
0004e3 e001
0004e4 dfd0                      	CW	LCD_wr_ir, 0b00000001	; clear display
0004e5 e006
0004e6 dfce                      	CW	LCD_wr_ir, 0b00000110	; entry mode set (Inc=1, Shift=0)
0004e7 e00c
0004e8 dfcc                      	CW	LCD_wr_ir, 0b00001100	; Display=1,Cursor=0,Blink=0	
0004e9 e308
0004ea dfca                      	CW	LCD_wr_ir, 0b00111000	; 8bits=1, 2lines=1, 5x8dots=0
0004eb 9508                      	ret
                                 
                                 LCD_pos:
                                 ; in	a0 = position (0x00..0x0f first line, 0x40..0x4f second line)
0004ec 2f02                      	mov	w,a0
0004ed 6800                      	ori	w,0b10000000
0004ee cfc6                      	rjmp	LCD_wr_ir
                                 
                                 LCD_cr:
                                 ; moving the cursor to the beginning of the line (carriage return)
0004ef 9100 8000                 	lds	w, LCD_IR			; read IR to check busy flag  (bit7)
0004f1 fd07
0004f2 cffc                      	JB1	w,7,LCD_cr			; Jump if Bit=1 (still busy)
0004f3 7400                      	andi	w,0b01000000	; keep bit6 (begin of line 1/2)
0004f4 6800                      	ori	w,0b10000000		; write address command
0004f5 dfc7                      	rcall	lcd_4us			; delay to increment DRAM addr counter
0004f6 9300 8000                 	sts	LCD_IR,w			; store in IR
0004f8 9508                      	ret
                                 
                                 LCD_lf:
                                 ; moving the cursor to the beginning of the line 2 (line feed)
0004f9 932f                      	push	a0				; safeguard a0
0004fa e420                      	ldi	a0,$40				; load position $40 (begin of line 2)
0004fb dff0                      	rcall	LCD_pos			; set cursor position
0004fc 912f                      	pop	a0					; restore a0
                                 .include	"Libraries\wire1.asm"		; include Dallas 1-wire(R) routines
0004fd 9508                      
                                 ; purpose Dallas 1-wire(R) interface library
                                 
                                 ; === definitions ===
                                 .equ	DQ_port	= PORTE
                                 .equ	DQ_pin	= DQ
                                 
                                 .equ	DS18B20		= 0x28
                                 
                                 .equ	readROM		= 0x33
                                 .equ	matchROM	= 0x55
                                 .equ	skipROM		= 0xcc
                                 .equ	searchROM	= 0xf0
                                 .equ	alarmSearch	= 0xec
                                 
                                 .equ	writeScratchpad	= 0x4e
                                 .equ	readScratchpad	= 0xbe
                                 .equ	copyScratchpad	= 0x48
                                 .equ	convertT	= 0x44
                                 .equ	recallE2	= 0xb8
                                 .equ	readPowerSupply	= 0xb4
                                 
                                 ; === routines ===
                                 
                                 .macro	WIRE1	; t0,t1,t2
                                 	sbi	DQ_port-1,DQ_pin	; pull DQ low (DDR=1 output)
                                 	ldi	w,(@0+1)/2	
                                 	rcall	wire1_wait		; wait low time (t0)
                                 	cbi	DQ_port-1,DQ_pin	; release DQ (DDR=0 input)
                                 	ldi	w,(@1+1)/2	
                                 	rcall	wire1_wait		; wait high time (t1)
                                 	in	w,DQ_port-2			; sample line (PINx=PORTx-2)
                                 	bst	w,DQ_pin			; store result in T
                                 	ldi	w,(@2+1)/2	
                                 	rcall	wire1_wait		; wait separation time (t2)
                                 	ret
                                 	.endmacro	
                                 
                                 wire1_wait:
0004fe 950a                      	dec	w					; loop time 2usec
0004ff 0000                      	nop
000500 0000                      	nop
000501 0000                      	nop
000502 0000                      	nop
000503 0000                      	nop
000504 f7c9                      	brne	wire1_wait
000505 9508                      	ret
                                 
                                 wire1_init:
000506 981d                      	cbi	DQ_port,  DQ_pin	; PORT=0 low (for pull-down)
000507 9815                      	cbi	DQ_port-1,DQ_pin	; DDR=0 (input hi Z)
000508 9508                      	ret
                                 	
000509 9a15
00050a ef00
00050b dff2
00050c 9815
00050d e203
00050e dfef
00050f b101
000510 fb05
000511 ec0d
000512 dfeb
000513 9508                      wire1_reset:	WIRE1	480,70,410
000514 9a15
000515 e10c
000516 dfe7
000517 9815
000518 e002
000519 dfe4
00051a b101
00051b fb05
00051c e001
00051d dfe0
00051e 9508                      wire1_write0:	WIRE1	56,4,1
00051f 9a15
000520 e001
000521 dfdc
000522 9815
000523 e10e
000524 dfd9
000525 b101
000526 fb05
000527 e001
000528 dfd5
000529 9508                      wire1_write1:	WIRE1	1,59,1
00052a 9a15
00052b e001
00052c dfd1
00052d 9815
00052e e007
00052f dfce
000530 b101
000531 fb05
000532 e107
000533 dfca
000534 9508                      wire1_read1:	WIRE1	1,14,45
                                 	
                                 wire1_write:
000535 933f                      	push	a1
000536 e038                      	ldi	a1,8
000537 9527                      	ror	a0
                                 
000538 f410                      	brcc	PC+3				; if C=1 then wire1, else wire0
000539 dfe5                      	rcall	wire1_write1
00053a c001                      	rjmp	PC+2
00053b dfd8                      	rcall	wire1_write0
                                 
00053c 953a
00053d f7c9                      	DJNZ	a1,wire1_write+2	; dec and jump if not zero
00053e 913f                      	pop	a1	
00053f 9508                      	ret
                                 
                                 wire1_read:
000540 933f                      	push	a1
000541 e038                      	ldi	a1,8
000542 9527                      	ror	a0
000543 dfe6                      	rcall	wire1_read1			; returns result in T
000544 f927                      	bld	a0,7					; move T to MSb
000545 953a
000546 f7d9                      	DJNZ	a1,wire1_read+2		; dec and jump if not zero
000547 913f                      	pop	a1	
000548 9508                      	ret
                                 	
                                 wire1_crc:
000549 e109                      	ldi	w,0b00011001
00054a e048                      	ldi	a2,8
00054b 9527                      crc1:	ror	a0
00054c f408                      	brcc	PC+2
00054d 2730                      	eor	a1,w
00054e fb30                      	bst	a1,0
00054f 9537                      	ror	a1
000550 f937                      	bld	a1,7
000551 954a
000552 f7c1                      	DJNZ	a2,crc1
                                 .include	"Libraries\printf.asm"		; include formatted printing routines
000553 9508                      
                                 ; purpose library, formatted output generation
                                 ; author (c) R.Holzer (adapted MICRO210/EE208 A.Schmid)
                                 ; v2019.02 20180821 AxS supports SRAM input from 0x0260
                                 ;					through 0x02ff that should be reserved
                                 
                                 ; === description ===
                                 ; 
                                 ; The program "printf" interprets and prints formatted strings.
                                 ; The special formatting characters regognized are:
                                 ;
                                 ; FDEC	decimal number
                                 ; FHEX	hexadecimal number
                                 ; FBIN	binary number
                                 ; FFRAC	fixed fraction number
                                 ; FCHAR	single ASCII character
                                 ; FSTR	zero-terminated ASCII string
                                 ;	
                                 ; The special formatting characters are distinguished from normal 
                                 ; ASCII characters by having their bit7 set to 1.
                                 ;
                                 ; Signification of bit fields:
                                 ;
                                 ; b 	bytes		1..4 b bytes		2
                                 ; s 	sign		0(unsigned), 1(signed)	1
                                 ; i		integer digits	
                                 ; e 	base		2,,36			5
                                 ; dp 	dec. point	0..32			5
                                 ; $if	i=integer digits,  0=all digits,  1..15 digits 
                                 ;		f=fraction digits, 0=no fraction, 1..15 digits
                                 ;
                                 ; Formatting characters must be followed by an SRAM address (0..ff)
                                 ; that determines the origin of variables that must be printed (if any)
                                 ; FBIN,	sram
                                 ; FHEX,	sram
                                 ; FDEC,	sram
                                 ; FCHAR,sram
                                 ; FSTR,	sram
                                 ;
                                 ; The address 'sram' is a 1-byte constant. It addresses
                                 ; 	 0..1f	registers r0..r31, 
                                 ; 	20..3f	i/o ports, (need to be addressed with an offset of $20)
                                 ;	0x0260..0x02ff	SRAM
                                 ; Variables can be located into register and I/0s, and can also
                                 ; be stored into data SRAM at locations 0x0200 through 0x02ff. Any
                                 ; sram address higher than 0x0060 is assumed to be at (0x0260+address)
                                 ; from automatic address detection in _printf_formatted: and subsequent
                                 ; assignment to xh; xl keeps its value. Consequently, variables that are
                                 ; to be stored into SRAM and further printed by fprint must reside at
                                 ; 0x0200 up to 0x02ff, and must be addressed using a label. Usage: see
                                 ; file string1.asm, for example.
                                 
                                 ; The FFRAC formatting character must be followed by 
                                 ;	ONE sram address and 
                                 ;	TWO more formatting characters
                                 ; FFRAC,sram,dp,$if
                                 
                                 ; dp	decimal point position, 0=right, 32=left
                                 ; $if	format i.f, i=integer digits, f=fraction digits
                                 
                                 ; The special formatting characters use the following coding
                                 ;
                                 ; FDEC	11bb'iiis	i=0 all digits, i=1-7 digits
                                 ; FBIN	101i'iiis	i=0 8 digits,	i=1-7 digits
                                 ; FHEX	1001'iiis	i=0 8 digits,	i=1-7 digits
                                 ; FFRAC	1000'1bbs
                                 ; FCHAR	1000'0100
                                 ; FSTR	1000'0101
                                 ; FREP	1000'0110
                                 ; FFUNC	1000'0111
                                 ;	1000'0010
                                 ;	1000'0011
                                 ; FESC	1000'0000
                                 
                                 ; examples
                                 ; formatting string			printing
                                 ; "a=",FDEC,a,0				1-byte variable a, unsigned decimal
                                 ; "a=",FDEC2,a,0			2-byte variable a (a1,a0), unsigend
                                 ; "a=",FDEC|FSIGN,a,0		1-byte variable 1, signed decimal
                                 ; "n=",FBIN,PIND+$20,0		i/o port, binary, notice offset of $20
                                 ; "f=",FFRAC4|FSIGN,a,16,$88,0	4-byte signed fixed-point fraction
                                 ;				dec.point at 16, 8 int.digits, 8 frac.digits	
                                 ; "f=",FFRAC2,a,16,$18,0		2-byte unsigned fixed-point fraction
                                 ;				dec.point at 16, 1 int.digits, 8 frac.digits	
                                 ; "a=",FDEC|FDIG5|FSIGN,a,0	1-byte variable, 5-digit, decimal, signed
                                 ; "a=",FDEC|FDIG5,a,0		1-byte variable, 5-digit, decimal, unsigned
                                 
                                 ; === registers modified ===
                                 ; e0,e1	used to transmit address of putc routine
                                 ; zh,zl	used as pointer to prog-memory
                                 
                                 ; === constants ==============================================
                                 
                                 .equ	FDEC	= 0b11000000	; 1-byte variable
                                 .equ	FDEC2	= 0b11010000	; 2-byte variable
                                 .equ	FDEC3	= 0b11100000	; 3-byte variable
                                 .equ	FDEC4	= 0b11110000	; 4-byte variable
                                 
                                 .equ	FBIN	= 0b10100000
                                 .equ	FHEX	= 0b10010100	; 1-byte variable
                                 .equ	FHEX2	= 0b10011000	; 2-byte variable
                                 .equ	FHEX3	= 0b10011100	; 3-byte variable
                                 .equ	FHEX4	= 0b10010000	; 4-byte variable
                                 
                                 .equ	FFRAC	= 0b10001000	; 1-byte variable
                                 .equ	FFRAC2	= 0b10001010	; 2-byte variable
                                 .equ	FFRAC3	= 0b10001100	; 3-byte variable
                                 .equ	FFRAC4	= 0b10001110	; 4-byte variable
                                 
                                 .equ	FCHAR	= 0b10000100
                                 .equ	FSTR	= 0b10000101
                                 
                                 .equ	FSIGN	= 0b00000001
                                 
                                 .equ	FDIG1	= 1<<1
                                 .equ	FDIG2	= 2<<1
                                 .equ	FDIG3	= 3<<1	
                                 .equ	FDIG4	= 4<<1
                                 .equ	FDIG5	= 5<<1
                                 .equ	FDIG6	= 6<<1
                                 .equ	FDIG7	= 7<<1
                                 
                                 ; ===macro ====================================================
                                 
                                 .macro	PRINTF			; putc function (UART, LCD...)
                                 	ldi	w, low(@0)		; address of "putc" in e1:d0
                                 	mov	e0,w
                                 	ldi	w,high(@0)
                                 	mov	e1,w
                                 	rcall	_printf
                                 	.endmacro
                                 
                                 ; mod	y,z
                                 
                                 
                                 ; === routines ================================================
                                 
                                 _printf:
000554 91ff
000555 91ef                      	POPZ			; z points to begin of "string"
000556 0fee
000557 1fff                      	MUL2Z			; multiply Z by two, (word ptr -> byte ptr)
000558 93af
000559 93bf                      	PUSHX
                                 		
                                 _printf_read:
00055a 95c8                      	lpm				; places prog_mem(Z) into r0 (=c)
00055b 9631                      	adiw	zl,1	; increment pointer Z
00055c 2000                      	tst	r0			; test for ZERO (=end of string)
00055d f021                      	breq	_printf_end	; char=0 indicates end of ascii string
00055e f04a                      	brmi	_printf_formatted ; bit7=1 indicates formatting character
00055f 2d00                      	mov	w,r0
000560 d017                      	rcall	_putw	; display the character
000561 cff8                      	rjmp	_printf_read	; read next character in the string
                                 	
                                 _printf_end:
000562 9631                      	adiw	zl,1	; point to the next character
000563 95f6
000564 95e7                      	DIV2Z			; divide by 2 (byte ptr -> word ptr)
000565 91bf
000566 91af                      	POPX
000567 9409                      	ijmp			; return to instruction after "string"
                                 
                                 _printf_formatted:
                                 
                                 ; FDEC	11bb'iiis
                                 ; FBIN	101i'iiis
                                 ; FHEX	1001'iiis
                                 ; FFRAC	1000'1bbs
                                 ; FCHAR	1000'0100
                                 ; FSTR	1000'0101
                                 
000568 fa00                      	bst	r0,0		; store sign in T
000569 2d00                      	mov	w,r0		; store formatting character in w
00056a 95c8                      	lpm	
00056b 2da0                      	mov	xl,r0		; load x-pointer with SRAM address
00056c 36a0                      	cpi	xl,0x60
00056d f010                      	brlo rio_space
                                 dataram_space:		; variable originates from SRAM memory
00056e e0b2                      	ldi	xh,0x02		;>addresses are limited to 0x0260 through 0x02ff
00056f c001                      	rjmp space_detect_end	;>that enables automatic detection of the origin
                                 rio_space:			; variable originates from reg or I/O space 
000570 27bb                      	clr	xh			; clear high-byte, addresses are 0x0000 through 0x003f (0x005f)
                                 space_detect_end:
000571 9631                       	adiw	zl,1	; increment pointer Z
                                 
                                 ;	JB1	w,6,_putdec
                                 ;	JB1	w,5,_putbin
                                 ;	JB1	w,4,_puthex
                                 ;	JB1	w,3,_putfrac
000572 3804
000573 f079                      	JK	w,FCHAR,_putchar
000574 3805
000575 f081                      	JK	w,FSTR ,_putstr
000576 c015                      	rjmp	_putnum
                                 	
000577 cfe2                      	rjmp	_printf_read	
                                 
                                 ; === putc (put character) ===============================
                                 ; in	w	character to put
                                 ;	e1,e0	address of output routine (UART, LCD putc)
                                 _putw:
000578 932f
000579 93ff
00057a 93ef                      	PUSH3	a0,zh,zl
00057b 2de4
00057c 2df5
00057d 2f20                      	MOV3	a0,zh,zl, w,e1,e0
00057e 9509                      	icall			; indirect call to "putc"
00057f 91ef
000580 91ff
000581 912f                      	POP3	a0,zh,zl
000582 9508                      	ret
                                 
                                 ; === putchar (put character) ============================
                                 ; in	x	pointer to character to put
                                 _putchar:
000583 910c                      	ld	w,x
000584 dff3                      	rcall	_putw
000585 cfd4                      	rjmp	_printf_read
                                 	
                                 ; === putstr (put string) ================================
                                 ; in	x	pointer to ascii string
                                 ;	b3,b2	address of output routine (UART, LCD putc)
                                 _putstr:
000586 910d                      	ld	w,x+
000587 2300                      	tst	w
000588 f409                      	brne	PC+2
000589 cfd0                      	rjmp	_printf_read
00058a dfed                      	rcall	_putw
00058b cffa                      	rjmp	_putstr
                                 
                                 ; === putnum (dec/bin/hex/frac) ===========================
                                 ; in	x	pointer to SRAM variable to print
                                 ; 	r0	formatting character
                                 	
                                 _putnum:
00058c 935f
00058d 934f
00058e 933f
00058f 932f                      	PUSH4	a3,a2,a1,a0	; safeguard a
000590 939f
000591 938f
000592 937f
000593 936f                      	PUSH4	b3,b2,b1,b0	; safeguard b	
000594 912d
000595 913d
000596 914d
000597 915d                      	LDX4	a3,a2,a1,a0	; load operand to print into a
                                 
                                 ; FDEC	11bb'iiis
                                 ; FBIN	101i'iiis
                                 ; FHEX	1001'iiis
                                 ; FRACT	1000'1bbs
                                 
000598 fd06
000599 c006                      	JB1	w,6,_putdec
00059a fd05
00059b c00f                      	JB1	w,5,_putbin
00059c fd04
00059d c010                      	JB1	w,4,_puthex
00059e fd03
00059f c019                      	JB1	w,3,_putfrac
                                 
                                 ; FDEC	11bb'iiis
                                 _putdec:
0005a0 e06a                      	ldi	b0,10		; b0 = base (10)
                                 
0005a1 2f70                      	mov	b1,w
0005a2 9576                      	lsr	b1
0005a3 7077                      	andi	b1,0b111	
0005a4 9572                      	swap	b1		; b1 = format 0iii'0000 (integer digits)
0005a5 e080                      	ldi	b2,0		; b2 = dec. point position = 0 (right)
                                 	
0005a6 2f90                      	mov	b3,w
0005a7 9592                      	swap	b3
0005a8 7093                      	andi	b3,0b11
0005a9 9593                      	inc	b3			; b3 = number of bytes (1..4)
0005aa c01a                      	rjmp	_getnum	; get number of digits (iii)
                                 
                                 ; FBIN	101i'iiis	addr
                                 _putbin:	
0005ab e062                      	ldi	b0,2		; b0 = base (2)
0005ac e094                      	ldi	b3,4		; b3 = number of bytes (4)	
0005ad c003                      	rjmp	_getdig	; get number of digits (iii)
                                 
                                 ; FHEX	1001'iiis	addr
                                 _puthex:	
0005ae e160                      	ldi	b0,16		; b0 = base (16)
0005af e094                      	ldi	b3,4		; b3 = number of bytes (4)
0005b0 c000                      	rjmp	_getdig
                                 
                                 _getdig:
0005b1 2f70                      	mov	b1,w
0005b2 9576                      	lsr	b1
0005b3 7077                      	andi	b1,0b111
0005b4 f409                      	brne	PC+2
0005b5 e078                      	ldi	b1,8		; if b1=0 then 8-digits
0005b6 9572                      	swap	b1		; b1 = format 0iii'0000 (integer digits)
0005b7 e080                      	ldi	b2, 0		; b2 = dec. point position = 0 (right)
0005b8 c00c                      	rjmp	_getnum
                                 
                                 ; FFRAC	1000'1bbs	addr	 00dd'dddd, 	iiii'ffff
                                 	
                                 _putfrac:
0005b9 e06a                      	ldi	b0,10		; base=10	
0005ba 95c8                      	lpm
0005bb 2d80                      	mov	b2,r0		; load dec.point position
0005bc 9631                      	adiw	zl,1	; increment char pointer
0005bd 95c8                      	lpm
0005be 2d70                      	mov	b1,r0		; load ii.ff format
0005bf 9631                      	adiw	zl,1	; increment char pointer
                                 	
0005c0 2f90                      	mov	b3,w
0005c1 9595                      	asr	b3
0005c2 7093                      	andi	b3,0b11
0005c3 9593                      	inc	b3			; b3 = number of bytes (1..4)
                                 
0005c4 c000                      	rjmp	_getnum
                                 
                                 _getnum:
                                 ; in 	a	4-byte variable
                                 ; 	b3	number of bytes (1..4)
                                 ;	T	sign, 0=unsigned, 1=signed
                                 
0005c5 3094
0005c6 f081                      	JK	b3,4,_printf_4b
0005c7 3093
0005c8 f051                      	JK	b3,3,_printf_3b
0005c9 3092
0005ca f021                      	JK	b3,2,_printf_2b	
                                 	
                                 _printf_1b:			; sign extension
0005cb 2733                      	clr	a1
0005cc f416                      	brtc	PC+3	; T=1 sign extension
0005cd fd27                      	sbrc	a0,7
0005ce ef3f                      	ldi	a1,0xff
                                 _printf_2b:
0005cf 2744                      	clr	a2
0005d0 f416                      	brtc	PC+3	; T=1 sign extension	
0005d1 fd37                      	sbrc	a1,7
0005d2 ef4f                      	ldi	a2,0xff
                                 _printf_3b:	
0005d3 2755                      	clr	a3
0005d4 f416                      	brtc	PC+3	; T=1 sign extension
0005d5 fd47                      	sbrc	a2,7
0005d6 ef5f                      	ldi	a3,0xff
                                 _printf_4b:
                                 
0005d7 d009                      	rcall	_ftoa		; float to ascii
0005d8 916f
0005d9 917f
0005da 918f
0005db 919f                      	POP4	b3,b2,b1,b0	; restore b
0005dc 912f
0005dd 913f
0005de 914f
0005df 915f                      	POP4	a3,a2,a1,a0	; restore a
                                 	
0005e0 cf79                      	rjmp	_printf_read
                                 
                                 ; ===============================================
                                 ; func	ftoa
                                 ; converts a fixed-point fractional number to an ascii string
                                 ; author (c) Raphael Holzer
                                 ;
                                 ; in	a3-a0	variable to print
                                 ;	b0	base, 2 to 36, but usually decimal (10)
                                 ;	b1	number of digits to print ii.ff
                                 ; 	b2	position of the decimal point (0=right, 32=left)
                                 ;	T	sign (T=0 unsiged, T=1 signed)
                                 
                                 _ftoa:
0005e1 92cf                      	push	d0
0005e2 92bf
0005e3 92af
0005e4 929f
0005e5 928f                      	PUSH4	c3,c2,c1,c0	; c = fraction part, a = integer part
0005e6 18bb
0005e7 24aa
0005e8 2499
0005e9 2488                      	CLR4	c3,c2,c1,c0	; clear fraction part
                                 
0005ea f486                      	brtc	_ftoa_plus	; if T=0 then unsigned
0005eb 94e8                      	clt
0005ec 2355                      	tst	a3				; if MSb(a)=1 then a=-a
0005ed f46a                      	brpl	_ftoa_plus
0005ee 9468                      	set					; T=1 (minus)
0005ef 2377                      	tst	b1
0005f0 f009                      	breq	PC+2		; if b1=0 the print ALL digits
0005f1 5170                      	subi	b1,0x10		; decrease int digits
0005f2 9550
0005f3 9540
0005f4 9530
0005f5 9520
0005f6 ef0f
0005f7 1b20
0005f8 0b30
0005f9 0b40
0005fa 0b50                      	NEG4	a3,a2,a1,a0	; negate a
                                 _ftoa_plus:	
0005fb 2388                      	tst	b2				; b0=0 (only integer part)
0005fc f051                      	breq	_ftoa_int	
                                 _ftoa_shift:	
0005fd 9555
0005fe 9547
0005ff 9537
000600 9527                      	ASR4	a3,a2,a1,a0	; a = integer part	
000601 94b7
000602 94a7
000603 9497
000604 9487                      	ROR4	c3,c2,c1,c0	; c = fraction part
000605 958a
000606 f7b1                      	DJNZ	b2,_ftoa_shift
                                 _ftoa_int:
000607 937f                      	push	b1			; ii.ff (ii=int digits)
000608 9572                      	swap	b1
000609 707f                      	andi	b1,0x0f
                                 	
00060a e20e                      	ldi	w,'.'			; push decimal point
00060b 930f                      	push	w
                                 _ftoa_int1:
00060c d045                      	rcall	_div41		; int=int/10
00060d 2d0c                      	mov	w,d0			; d=reminder
00060e d030                      	rcall	_hex2asc
00060f 930f                      	push	w			; push rem(int/10)
000610 2700
000611 1720
000612 0730
000613 0740
000614 0750                      	TST4	a3,a2,a1,a0	; (int/10)=?
000615 f029                      	breq	_ftoa_space	; (int/10)=0 then finished
000616 2377                      	tst	b1
000617 f3a1                      	breq	_ftoa_int1	; if b1=0 then print ALL int-digits
000618 957a
000619 f791                      	DJNZ	b1,_ftoa_int1
00061a c007                      	rjmp	_ftoa_sign
                                 _ftoa_space:
00061b 2377                      	tst	b1				; if b1=0 then print ALL int-digits
00061c f029                      	breq	_ftoa_sign
00061d 957a                      	dec	b1
00061e f019                      	breq	_ftoa_sign
00061f e200                      	ldi	w,' '			; write spaces
000620 df57                      	rcall	_putw	
000621 cff9                      	rjmp	_ftoa_space
                                 _ftoa_sign:
000622 f416                      	brtc	PC+3		; if T=1 then write 'minus'
000623 e20d                      	ldi	w,'-'
000624 df53                      	rcall	_putw
                                 _ftoa_int3:
000625 910f                      	pop	w
000626 320e                      	cpi	w,'.'
000627 f011                      	breq	PC+3
000628 df4f                      	rcall	_putw
000629 cffb                      	rjmp	_ftoa_int3
                                 
00062a 917f                      	pop	b1				; ii.ff (ff=frac digits)
00062b 707f                      	andi	b1,0x0f
00062c 2377                      	tst	b1
00062d f059                      	breq	_ftoa_end
                                 _ftoa_point:	
00062e df49                      	rcall	_putw		; write decimal point
00062f 2d28
000630 2d39
000631 2d4a
000632 2d5b                      	MOV4	a3,a2,a1,a0, c3,c2,c1,c0		
                                 _ftoa_frac:
000633 d011                      	rcall	_mul41		; d.frac=10*frac
000634 2d0c                      	mov	w,d0
000635 d009                      	rcall	_hex2asc
000636 df41                      	rcall	_putw
000637 957a
000638 f7d1                      	DJNZ	b1,_ftoa_frac
                                 _ftoa_end:
000639 908f
00063a 909f
00063b 90af
00063c 90bf                      	POP4	c3,c2,c1,c0
00063d 90cf                      	pop	d0
00063e 9508                      	ret
                                 
                                 ; === hexadecimal to ascii ===
                                 ; in	w
                                 _hex2asc:
00063f 300a                      	cpi	w,10
000640 f410                      	brsh	PC+3
000641 5d00                      	addi	w,'0'
000642 9508                      	ret
000643 5a09                      	addi	w,('a'-10)
000644 9508                      	ret
                                 
                                 ; === multiply 4byte*1byte ===
                                 ; funct mul41
                                 ; multiplies a3-a0 (4-byte) by b0 (1-byte)
                                 ; author (c) Raphael Holzer, EPFL
                                 ; 
                                 ; in	a3..a0	multiplicand (argument to multiply)
                                 ;	b0	multiplier
                                 ; out	a3..a0	result
                                 ; 	d0	result MSB (byte 4)
                                 ;
000645 24cc                      _mul41:	clr	d0			; clear byte4 of result
000646 e200                      	ldi	w,32			; load bit counter
000647 9488                      __m41:	clc				; clear carry
000648 fd20                      	sbrc	a0,0		; skip addition if LSB=0
000649 0ec6                      	add	d0,b0			; add b to MSB of a
00064a 94c7
00064b 9557
00064c 9547
00064d 9537
00064e 9527                      	ROR5	d0,a3,a2,a1,a0	; shift-right c, LSB (of b) into carry
00064f 950a
000650 f7b1                      	DJNZ	w,__m41		; Decrement and Jump if bit-count Not Zero
000651 9508                      	ret
                                 
                                 ; === divide 4byte/1byte ===
                                 ; func div41
                                 ; in	a0..a3 	divident (argument to divide)
                                 ;	b0 	divider
                                 ; out	a0..a3 	result 
                                 ;	d0	reminder
                                 ;
000652 24cc                      _div41:	clr	d0			; d will contain the remainder
000653 e200                      	ldi	w,32			; load bit counter
000654 1f22
000655 1f33
000656 1f44
000657 1f55
000658 1ccc                      __d41:	ROL5	d0,a3,a2,a1,a0	; shift carry into result c
000659 1ac6                      	sub	d0, b0			; subtract b from remainder
00065a f408                      	brcc	PC+2	
00065b 0ec6                      	add	d0, b0			; restore if remainder became negative
00065c 950a
00065d f7b1                      	DJNZ	w,__d41		; Decrement and Jump if bit-count Not Zero
00065e 1f22
00065f 1f33
000660 1f44
000661 1f55                      	ROL4	a3,a2,a1,a0	; last shift (carry into result c)
000662 9550
000663 9540
000664 9530
000665 9520                      	COM4	a3,a2,a1,a0	; complement result
000666 9508                      	ret
                                 .include	"moteur.asm"	
                                 
                                  * moteur.asm
                                  *
                                  *  Created: 20.04.2021 13:55:16
                                  *   Author: Administrateur
                                  */ 
                                 .include	"macro_projet.asm"
                                 
                                 .macro		DIV22B
                                 	bst		@1,7
                                 	lsr		@1
                                 	ror		@0
                                 	bld		@1,7	
                                 .endmacro
                                 
                                 .macro		COM2B
                                 	ldi		w, 0xff
                                 	eor		@0, w
                                 	eor		@1, w
                                 	ldi		w, 1
                                 	add		@0, w
                                 	clr		w
                                 	adc		@1, w
                                 .endmacro
                                 
                                 .macro 		ANGLEC			; in: registers @1:@0 which are a temperature in C, out: @1:@0 angle corresponding, mod: w, _w
                                 	bst		@1, 7			;save msb sign
                                 	mov		w, @0
                                 	mov		_w, @1
                                 	lsl		w				;mult by 2
                                 	rol		_w		
                                 	add		@0, w
                                 	adc		@1, _w
                                 	lsr		@1				;div by 2: (2*x+x)/2 = 1.5x
                                 	ror		@0
                                 	bld		@1, 7			;load back msb
                                 	ldi		w, 0b11010000	;add 45 
                                 	add		@0, w
                                 	ldi		w, 0b10
                                 	adc		@1, w
                                 .endmacro	
                                 
                                 .macro ANGLEF	; in: registers @1:@0 which are a temperature in C, out: @1:@0 angle corresponding, mod: w, _w
                                 	ANGLEC	@0, @1
                                 	COM2B	@0, @1
                                 	subi	@0, 0b11000000
                                 	ldi		w, 0b11
                                 	sbc		@1, w
                                 .endmacro
                                 
                                 .macro CHECK_MENU_LIMIT	
                                 	mov		w, m			;load m in w
                                 	andi	w, 0b00001011	;use a mask to keep only the bits 0,1,3
                                 	cpi		w, 0b00001000	;see if we are in the the correct sub menu
                                 	breq	PC+2			
                                 	jmp		affichage		;we are in the wrong sub menu
                                 
                                 .equ	max_speed = 2000			
                                 .equ	min_speed = 1000
                                 
                                 motor_reset:
000667 ef0f
000668 bb07                      	OUTI	DDRB,0xff		; configure portC to output
000669 9508                      	ret			
                                 	
                                 ; turn_moteur -----------------
                                 ;this routine execute a certain rotation of an angle
                                 ;in a1:a0 angle in byte
                                 ;mod:
                                 turn_moteur:
00066a 98c4                      	P0	PORTB,SERVO1
                                 	
00066b 2f02                      	mov		w, a0
00066c 2f13                      	mov		_w, a1
00066d fb37
00066e 9536
00066f 9527
000670 f937                      	DIV22B	a0, a1
000671 0f20                      	add		a0, w
000672 1f31                      	adc		a1, _w
000673 fb37
000674 9536
000675 9527
000676 f937                      	DIV22B	a0, a1
                                 
000677 fd37                      	sbrc	a1, 7
000678 c014                      	rjmp	negative_angle	
                                 
                                 positive_angle:
                                 ;	shift right 4X
000679 fb37
00067a 9536
00067b 9527
00067c f937                      	DIV22B	a0, a1
00067d fb37
00067e 9536
00067f 9527
000680 f937                      	DIV22B	a0, a1
000681 fb37
000682 9536
000683 9527
000684 f937                      	DIV22B	a0, a1
000685 fb37
000686 9536
000687 9527
000688 f937                      	DIV22B	a0, a1
000689 2f62                      	mov		b0, a0
                                 
00068a ed20                      	ldi		a0, low(max_speed)
00068b e037                      	ldi		a1, high(max_speed)
00068c c01b                      	rjmp	check_zero
                                 
                                 negative_angle:
00068d ef0f
00068e 2720
00068f 2730
000690 e001
000691 0f20
000692 2700
000693 1f30                      	COM2B	a0,a1
                                 	;	shift right 4X
000694 fb37
000695 9536
000696 9527
000697 f937                      	DIV22B	a0, a1
000698 fb37
000699 9536
00069a 9527
00069b f937                      	DIV22B	a0, a1
00069c fb37
00069d 9536
00069e 9527
00069f f937                      	DIV22B	a0, a1
0006a0 fb37
0006a1 9536
0006a2 9527
0006a3 f937                      	DIV22B	a0, a1
0006a4 2f62                      	mov		b0, a0
0006a5 ee28                      	ldi		a0, low(min_speed)
0006a6 e033                      	ldi		a1, high(min_speed)
0006a7 c000                      	rjmp	check_zero	
                                 
                                 ; in a1:a0, a2 out void, mod a2,w
                                 ; purpose execute arbitrary rotation
                                 check_zero:
0006a8 ec00
0006a9 2e40
0006aa e004
0006ab 2e50
0006ac dea7                      	PRINTF LCD
0006ad 620a
0006ae a03d
0006af 0016                      	.db LF, "b=", FBIN, b, 0
                                 
0006b0 3060                      	cpi		b0,0
0006b1 f0c1                      	breq	stop
                                 store_value:
0006b2 9280 1070                 	sts		0x1070, c0
0006b4 9290 1072                 	sts		0x1072, c1
                                 motor_loop:
0006b6 d003                      	rcall	servoreg_pulse
0006b7 956a                      	dec		b0
0006b8 f7e9                      	brne	motor_loop
                                 
0006b9 c010                      	rjmp	stop
                                 
                                 ; servoreg_pulse, in a1,a0, out servo port, mod a3,a2
                                 ; purpose generates pulse of length a1,a0
                                 servoreg_pulse:
0006ba e209
0006bb 2e30
0006bc e609
0006bd 943a
0006be f7f1
0006bf 943a
0006c0 950a
0006c1 f7d9                      	WAIT_US	20000
0006c2 2f42
0006c3 2f53                      	MOV2	a3,a2, a1,a0
0006c4 9ac4                      	P1		PORTB,SERVO1		; pin=1	
                                 lpssp01:	
0006c5 5041
0006c6 4050                      	SUBI2	a3,a2,0x1
0006c7 f7e9                      	brne	lpssp01
0006c8 98c4                      	P0		PORTB,SERVO1		; pin=0
0006c9 9508                      	ret
                                 
                                 stop:
0006ca 9508                      
                                 ; routine called to reset 1-wire<
                                 temp_reset:
0006cb de3a                      	rcall	wire1_init				;init. 1-wire interface
0006cc de3c                      	rcall	wire1_reset
0006cd eb28
0006ce de66                      	CA		wire1_write,recallE2	;recall the th and conf. from EEPROM
                                 
0006cf d06c                      	rcall	load_t_eeprom
                                 
0006d0 e020                      	ldi		a0,0
0006d1 e030                      	ldi		a1,0
0006d2 9320 1070                 	sts		0x1070, a0
0006d4 9330 1072                 	sts		0x1072, a1
                                 
0006d6 df90                      	rcall	motor_reset
                                 
0006d7 9508                      	ret
                                 
                                 ; routine used to update temperature
                                 update_temp:
                                 
0006d8 de30                      	rcall	wire1_reset				; send a reset pulse
0006d9 ec2c
0006da de5a                      	CA		wire1_write, skipROM	; skip ROM identification
0006db e424
0006dc de58                      	CA		wire1_write, convertT	; initiate temp conversion
0006dd ee0e
0006de 2e30
0006df e003
0006e0 930f
0006e1 923f
0006e2 e300
0006e3 2e30
0006e4 e006
0006e5 943a
0006e6 f7f1
0006e7 943a
0006e8 950a
0006e9 f7d9
0006ea 903f
0006eb 910f
0006ec 943a
0006ed f791
0006ee 950a
0006ef f781                      	WAIT_MS	750						; wait 750 msec
                                 	
0006f0 de18                      	rcall	wire1_reset				; send a reset pulse
0006f1 ec2c
0006f2 de42                      	CA		wire1_write, skipROM
0006f3 eb2e
0006f4 de40                      	CA		wire1_write, readScratchpad	
0006f5 de4a                      	rcall	wire1_read				; read temperature LSB
0006f6 2e82                      	mov		c0,a0
0006f7 de48                      	rcall	wire1_read				; read temperature MSB
0006f8 2f32                      	mov		a1,a0
0006f9 2d28                      	mov		a0,c0
                                 
0006fa fb37
0006fb 2f02
0006fc 2f13
0006fd 0f00
0006fe 1f11
0006ff 0f20
000700 1f31
000701 9536
000702 9527
000703 f937
000704 ed00
000705 0f20
000706 e002
000707 1f30                      	ANGLEC	a0,a1
000708 2e82                      	mov		c0, a0
000709 2e93                      	mov		c1, a1
                                 
00070a 9160 1070                 	lds		b0, 0x1070
00070c 9170 1072                 	lds		b1, 0x1072
00070e 1b26                      	sub		a0, b0
00070f 0b37                      	sbc		a1, b1
                                 	
                                 	;rcall turn_moteur
                                 
                                 	;rcall	wire1_reset
                                 	;CA		wire1_write, skipROM
                                 	;CA		wire1_write,alarmSearch
                                 	;rcall	wire1_read	
                                 	;mov		r16, a0
                                 	;out		PORTB,r16
                                 
000710 9508                      	ret
                                 
                                 
                                 save_t_eeprom:
000711 e0b0                      	ldi xh, high(th_eep)
000712 e0a1                      	ldi xl, low(th_eep)
000713 9120 0200                 	lds a0, th_addr
000715 d0c6                      	rcall	eeprom_store
                                 
000716 e0b0                      	ldi xh, high(tl_eep)
000717 e0a2                      	ldi xl, low(tl_eep)
000718 9120 0201                 	lds a0, tl_addr
00071a d0c1                      	rcall	eeprom_store
                                 
00071b fc62                      	sbrc m,2
00071c c015                      	rjmp conv_to_c
                                 
00071d 90c0 0200                 	lds d0, th_addr
00071f 90d0 0201                 	lds d1, tl_addr
                                 
                                 back_to_save:
000721 dde7                      	rcall	wire1_reset			; send a reset pulse
000722 ec2c
000723 de11                      	CA		wire1_write, skipROM
000724 e42e
000725 de0f                      	CA		wire1_write, writeScratchpad
000726 2d2c                      	mov		a0,d0
000727 de0d                      	rcall 	wire1_write
000728 2d2d                      	mov		a0,d1
000729 de0b                      	rcall 	wire1_write
00072a e72f                      	ldi		a0,0b01111111
00072b de09                      	rcall 	wire1_write
                                 
00072c dddc                      	rcall	wire1_reset
00072d ec2c
00072e de06                      	CA		wire1_write, skipROM
00072f e428
000730 de04                      	CA		wire1_write, copyScratchpad
000731 9508                      	ret
                                 conv_to_c:
000732 9120 0200                 	lds a0, th_addr
000734 d026                      	rcall fahr_to_c
000735 932f                      	push a0
000736 9120 0201                 	lds a0, tl_addr
000738 d022                      	rcall fahr_to_c
000739 2ed2                      	mov d1,a0
00073a 90cf                      	pop d0
00073b cfe5                      	rjmp back_to_save
                                 
                                 load_t_eeprom:
00073c e0b0                      	ldi xh, high(th_eep)
00073d e0a1                      	ldi xl, low(th_eep)
00073e d0ab                      	rcall eeprom_load
00073f 2ec2                      	mov d0,a0
000740 e0b0                      	ldi xh, high(tl_eep)
000741 e0a2                      	ldi xl, low(tl_eep)
000742 d0a7                      	rcall eeprom_load
000743 2ed2                      	mov d1,a0
                                 
000744 92c0 0200                 	sts th_addr, d0
000746 92d0 0201                 	sts tl_addr, d1
000748 9508                      	ret
                                 
                                 ; in a0
                                 cel_to_f:
000749 fb27                      	bst		a0,7
00074a 3020                      	cpi		a0, 0
00074b f412                      	brpl	mul_c_f
                                 
                                 ; a0 is negative, we take its absolute value
00074c 9520                      	com a0
00074d 5f2f                      	subi a0, (-1)
                                 
                                 mul_c_f:
00074e e069                      	ldi b0, 9
00074f d8d2                      	rcall mul11
000750 2d28                      	mov a0,c0
000751 2d39                      	mov a1,c1
000752 e065                      	ldi b0, 5
000753 2777                      	clr b1
000754 dcc7                      	rcall div22
                                 	
000755 2d28                      	mov a0,c0
000756 f416                      	brtc	add_c_f
                                 
                                 ; a0 is turned back into a negative number
000757 9520                      	com a0
000758 5f2f                      	subi a0, (-1)
                                 
                                 add_c_f:
000759 5e20                      	subi a0, (-32) ; a0 : T in F
00075a 9508                      	ret
                                 
                                 ; in a0
                                 fahr_to_c:
00075b 5220                      	subi a0, 32 
                                 
00075c fb27                      	bst		a0,7
00075d 3020                      	cpi		a0, 0
00075e f412                      	brpl	mul_f_c
                                 
                                 ; a0 is negative, we take its absolute value
00075f 9520                      	com a0
000760 5f2f                      	subi a0, (-1)
                                 
                                 mul_f_c:
000761 e065                      	ldi b0, 5
000762 d8bf                      	rcall mul11
000763 2d28                      	mov a0,c0
000764 2d39                      	mov a1,c1
000765 e069                      	ldi b0, 9
000766 2777                      	clr b1
000767 dcb4                      	rcall div22
                                 	
000768 2d28                      	mov a0,c0
000769 f416                      	brtc	end_f_c
                                 
                                 ; a0 is turned back into a negative number
00076a 9520                      	com a0
00076b 5f2f                      	subi a0, (-1)
                                 
                                 end_f_c:
                                 .include	"remote.asm"
00076c 9508                      
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\remote.asm(2): warning: float->int cast, truncated
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\main.asm(19): 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\remote.asm' included form here
                                 .equ	T2 = 14906*(1+0.034)			; start timout, T2 = (14906 + (14906 * Terr2)) 
                                 							;>with Terr2 = 4.2% observed with the oscilloscope
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\remote.asm(4): warning: float->int cast, truncated
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\main.asm(19): 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\remote.asm' included form here
                                 .equ	T1 = 1125*(1+0.036)			; bit period, T1 = (1125 + (1125 * Terr1)) with 
                                 							;>Terr1 = 6.% observed with the oscilloscope
                                 
                                 read_remote:	
00076d 1b77
00076e 2766                      	CLR2	b1,b0			; clear 2-byte register
00076f 1b33
000770 2722                      	CLR2	a1,a0
000771 e180                      	ldi		b2,16			; load bit-counter
000772 9907
000773 cffe                      	WP1		PINF,IR			; Wait if Pin=1 
000774 94f8                      	cli						; The NEC signals as to be read without interrupt
000775 e404
000776 2e30
000777 e501
000778 943a
000779 f7f1
00077a 943a
00077b 950a
00077c f7d9                      	WAIT_US	T2				; wait for timeout
00077d 9488                      	clc						; clearing carry
                                 	
                                 addr: 
                                 	;INVP	PORTB,1
00077e 9907
00077f 9408
000780 9b07
000781 9488                      	P2C		PINF,IR			; move Pin to Carry (P2C, 4 cycles)
000782 1f66
000783 1f77                      	ROL2	b1,b0			; roll carry into 2-byte reg (ROL2, 2 cycles)
000784 fd60                      	sbrc	b0,0			; (branch not taken, 1 cycle; taken 2 cycles)
000785 c00c                      	rjmp	rdz_a			; (rjmp, 2 cycles)
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\Libraries\macros.asm(221): warning: float->int cast, truncated
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\remote.asm(22): macro 'WAIT_US' called here
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\main.asm(19): 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\remote.asm' included form here
000786 e00a
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\Libraries\macros.asm(223): warning: float->int cast, truncated
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\remote.asm(22): macro 'WAIT_US' called here
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\main.asm(19): 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\remote.asm' included form here
000787 2e30
000788 e007
000789 943a
00078a f7f1
00078b 943a
00078c 950a
00078d f7d9                      	WAIT_US	(T1 - 4.75)
00078e 958a
00078f f771                      	DJNZ	b2,addr			; Decrement and Jump if Not Zero (true, 2 cycles; false, 1 cycle)
000790 940c 079c                 	jmp		next_a			; (jmp, 3 cycles)
                                 rdz_a:							; read a zero
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\Libraries\macros.asm(221): warning: float->int cast, truncated
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\remote.asm(26): macro 'WAIT_US' called here
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\main.asm(19): 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\remote.asm' included form here
000792 e10a
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\Libraries\macros.asm(223): warning: float->int cast, truncated
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\remote.asm(26): macro 'WAIT_US' called here
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\main.asm(19): 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\remote.asm' included form here
000793 2e30
000794 e00d
000795 943a
000796 f7f1
000797 943a
000798 950a
000799 f7d9                      	WAIT_US	(2*T1 - 5.75)
00079a 958a
00079b f711                      	DJNZ	b2,addr			; Decrement and Jump if Not Zero
                                 
                                 next_a: 
00079c 2ec6
00079d 2ed7                      	MOV2	d1,d0, b1, b0	; store current address
00079e 2f26
00079f 2f37                      	MOV2	a1,a0,b1,b0
0007a0 e180                      	ldi		b2,16			; load bit-counter
0007a1 9488                      	clc
0007a2 1b77
0007a3 2766                      	CLR2	b1,b0
                                 
                                 data: 
                                 	;INVP	PORTB,1
0007a4 9907
0007a5 9408
0007a6 9b07
0007a7 9488                      	P2C		PINF,IR			
0007a8 1f66
0007a9 1f77                      	ROL2	b1,b0			
0007aa fd60                      	sbrc	b0,0			
0007ab c00c                      	rjmp	rdz_d			
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\Libraries\macros.asm(221): warning: float->int cast, truncated
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\remote.asm(42): macro 'WAIT_US' called here
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\main.asm(19): 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\remote.asm' included form here
0007ac e00a
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\Libraries\macros.asm(223): warning: float->int cast, truncated
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\remote.asm(42): macro 'WAIT_US' called here
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\main.asm(19): 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\remote.asm' included form here
0007ad 2e30
0007ae e007
0007af 943a
0007b0 f7f1
0007b1 943a
0007b2 950a
0007b3 f7d9                      	WAIT_US	(T1 - 4.75)
0007b4 958a
0007b5 f771                      	DJNZ	b2,data			
0007b6 940c 07c2                 	jmp		next_b		
                                 		
                                 rdz_d:							
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\Libraries\macros.asm(221): warning: float->int cast, truncated
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\remote.asm(47): macro 'WAIT_US' called here
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\main.asm(19): 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\remote.asm' included form here
0007b8 e10a
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\Libraries\macros.asm(223): warning: float->int cast, truncated
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\remote.asm(47): macro 'WAIT_US' called here
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\main.asm(19): 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\remote.asm' included form here
0007b9 2e30
0007ba e00d
0007bb 943a
0007bc f7f1
0007bd 943a
0007be 950a
0007bf f7d9                      	WAIT_US	(2*T1 - 5.75)
0007c0 958a
0007c1 f711                      	DJNZ	b2,data				
                                 
                                 next_b:
0007c2 2ee6
0007c3 2ef7                      	MOV2	d3,d2,b1, b0	; store current command
                                 
                                  data_proc01:				; detect repeated code
0007c4 ef0f
0007c5 16f0                      	_CPI		d3, 0xff
0007c6 f459                      	brne	data_proc02
0007c7 ef0f
0007c8 16e0                      	_CPI		d2, 0xff
0007c9 f441                      	brne	data_proc02
0007ca ef0f
0007cb 16d0                      	_CPI		d1, 0xff 
0007cc f429                      	brne	data_proc02
0007cd ef0f
0007ce 16c0                      	_CPI		d0, 0xff
0007cf f411                      	brne	data_proc02 
                                 
                                 display_repeat:
0007d0 e060                      	ldi		b0, 0
0007d1 9508                      	ret
                                 
                                 data_proc02:				; detect transmission error
0007d2 94d0                      	com		d1
0007d3 10cd                      	cpse	d0, d1
0007d4 f429                      	brne	display_error
0007d5 94f0                      	com		d3
0007d6 10ef                      	cpse	d2, d3
0007d7 f411                      	brne	display_error
                                 
                                 display_correct:	
0007d8 9560                      	com		b0
0007d9 9508                      	ret						
                                 
                                 display_error:
0007da e060                      	ldi		b0, 0
                                 .include	"Libraries\eeprom.asm"
0007db 9508                      
                                 ; purpose library, internal EEPROM
                                 
                                 eeprom_store:
                                 ; in:	xh:xl 	EEPROM address
                                 ;	a0	EEPROM data byte to store
                                 
0007dc 99e1                      	sbic	EECR,EEWE	; skip if EEWE=0 (wait it EEWE=1)
0007dd cffe                      	rjmp	PC-1		; jump back to previous address
0007de bbae                      	out	EEARL,xl		; load EEPROM address low	
0007df bbbf                      	out	EEARH,xh		; load EEPROM address high
0007e0 bb2d                      	out	EEDR,a0			; set EEPROM data register
0007e1 f01f                      	brie	eeprom_cli	; if I=1 then temporarily disable interrupts
0007e2 9ae2                      	sbi	EECR,EEMWE		; set EEPROM Master Write Enable
0007e3 9ae1                      	sbi	EECR,EEWE		; set EEPROM Write Enable
0007e4 9508                      	ret	
                                 eeprom_cli:
0007e5 94f8                      	cli					; disable interrupts
0007e6 9ae2                      	sbi	EECR,EEMWE		; set EEPROM Master Write Enable
0007e7 9ae1                      	sbi	EECR,EEWE		; set EEPROM Write Enable
0007e8 9478                      	sei					; enable interrupts
0007e9 9508                      	ret
                                 
                                 eeprom_load:
                                 ; in:	xh:xl 	EEPROM address
                                 ; out:	a0	EEPROM data byte to load
                                 
0007ea 99e1                      	sbic	EECR,EEWE	; skip if EEWE=0 (wait it EEWE=1)
0007eb cffe                      	rjmp	PC-1		; jump back to previous address
0007ec bbae                      	out	EEARL,xl	
0007ed bbbf                      	out	EEARH,xh
0007ee 9ae0                      	sbi	EECR,EERE		; set EEPROM Read Enable
0007ef b32d                      	in	a0,EEDR			; read data register of EEPROM
                                 .include	"affichage.asm"
0007f0 9508                      
0007f1 dcda                      	rcall	LCD_clear
0007f2 dcdb                      	rcall	LCD_home
                                 
0007f3 2d16                      	mov		_w, m			;load m in _w
0007f4 7013                      	andi	_w, 0b11		;select the two last bits of m 
0007f5 e000
0007f6 1710                      	_CPI	_w, 0		
0007f7 f159                      	breq	menu_set_temp	;if their are 00 -> menu set temp
0007f8 e001
0007f9 1710                      	_CPI	_w, 1		
0007fa f1e1                      	breq	menu_temp		;if their are 01 ->	menu temp
0007fb e002
0007fc 1710                      	_CPI	_w, 2
0007fd f091                      	breq	menu_music		;if their are 10 ->	menu music
0007fe e003
0007ff 1710                      	_CPI	_w, 3
000800 f0c9                      	breq	menu_jeu		;if their are 11 -> menu jeu
                                 
000801 ec00
000802 2e40
000803 e004
000804 2e50
000805 dd4e                      	PRINTF LCD
000806 6543
000807 6d20
000808 6e65
000809 2075
00080a 7365
00080b 2074
00080c 6166
00080d 7875
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\affichage.asm(17): warning: .cseg .db misalignment - padding zero byte
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\main.asm(21): 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\affichage.asm' included form here
00080e 0000                      	.db		"Ce menu est faux",0
                                 
00080f c0a0                      	rjmp	main
                                 
                                 menu_music:			;affiche music
000810 ec00
000811 2e40
000812 e004
000813 2e50
000814 dd3f                      	PRINTF	LCD
000815 754d
000816 6973
000817 0063                      	.db		"Music",0
000818 940c 08b0                 	jmp		main
                                 
                                 menu_jeu:			;affiche jeu
00081a ec00
00081b 2e40
00081c e004
00081d 2e50
00081e dd35                      	PRINTF	LCD
00081f 654a
000820 0075                      	.db		"Jeu",0
000821 940c 08b0                 	jmp		main
                                 
                                 menu_set_temp:		;affiche temp lim
000823 fc63                      	sbrc	m,3
000824 c043                      	rjmp	print_limit
                                 
000825 ec00
000826 2e40
000827 e004
000828 2e50
000829 dd2a                      	PRINTF LCD
00082a 6554
00082b 706d
00082c 7265
00082d 7461
00082e 7275
00082f 7365
000830 6c0a
000831 6d69
000832 7469
000833 7365
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\affichage.asm(36): warning: .cseg .db misalignment - padding zero byte
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\main.asm(21): 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\affichage.asm' included form here
000834 0000                      	.db		"Temperatures",LF,"limites",0
000835 940c 08b0                 	jmp		main
                                 
                                 menu_temp:			;affiche temp	
000837 fc63                      	sbrc	m,3
000838 c00d                      	rjmp	degre
                                 
000839 ec00
00083a 2e40
00083b e004
00083c 2e50
00083d dd16                      	PRINTF LCD
00083e 6554
00083f 706d
000840 7265
000841 7461
000842 7275
000843 0065                      	.db		"Temperature",0
000844 940c 08b0                 	jmp		main
                                 
                                 ; ==== Menu choix unite temperature ====
                                 degre:
000846 ec00
000847 2e40
000848 e004
000849 2e50
00084a dd09                      	PRINTF	LCD
00084b 6544
00084c 7267
00084d 2065
00084e 0a3a
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\affichage.asm(50): warning: .cseg .db misalignment - padding zero byte
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\main.asm(21): 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\affichage.asm' included form here
00084f 0000                      	.db		"Degre :",LF,0
                                 
000850 fc62                      	sbrc	m,2
000851 c00a                      	rjmp	print_f
                                 
                                 print_c:			;affiche Celsius
000852 ec00
000853 2e40
000854 e004
000855 2e50
000856 dcfd                      	PRINTF	LCD
000857 6543
000858 736c
000859 7569
00085a 0073                      	.db		"Celsius",0
00085b c054                      	rjmp	main
                                 
                                 print_f:			;affiche Fahrenheit
00085c ec00
00085d 2e40
00085e e004
00085f 2e50
000860 dcf3                      	PRINTF	LCD
000861 6146
000862 7268
000863 6e65
000864 6568
000865 7469
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\affichage.asm(62): warning: .cseg .db misalignment - padding zero byte
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\main.asm(21): 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\affichage.asm' included form here
000866 0000                      	.db		"Fahrenheit",0
000867 c048                      	rjmp	main
                                 
                                 
                                 ; ==== Menu limite temperature====
                                 print_limit:		;affiche Limite
000868 9130 0202                 	lds		r19, unit_addr
00086a 9110 0200                 	lds		r17, th_addr
00086c 9120 0201                 	lds		r18, tl_addr
00086e ec00
00086f 2e40
000870 e004
000871 2e50
000872 dce1                      	PRINTF	LCD
000873 6854
000874 203a
000875 11c1
000876 2020
000877 3a75
000878 13c0
000879 540a
00087a 3a6c
00087b c120
00087c 0012                      	.db		"Th: ",FDEC|FSIGN,17,"  u:",FDEC,19,LF,"Tl: ",FDEC|FSIGN,18,0
                                 
00087d 940c 087f                 	jmp		display_cursor
                                 
                                 display_cursor:		;show in which sub menu we are: <
00087f e400                      	ldi		w, 0x40
000880 e02f                      	ldi		a0, 0x0f
000881 fc64                      	sbrc	m, 4
000882 0f20                      	add		a0, w
000883 dc68                      	rcall	LCD_pos
000884 e32c                      	ldi		a0, '<'
000885 dc3a                      	rcall	LCD_putc
000886 940c 08b0                 
                                 ovf0:
000888 930f                      	push	 w
000889 931f                      	push	_w
00088a 932f                      	push	a0
00088b 933f                      	push	a1
00088c 936f                      	push	b0
00088d 937f                      	push	b1
00088e b61f                      	in		_sreg,SREG
00088f de48                      	rcall	update_temp
000890 be1f                      	out		SREG,_sreg
000891 917f                      	pop		b1
000892 916f                      	pop		b0
000893 913f                      	pop		a1
000894 912f                      	pop		a0
000895 911f                      	pop		_w
000896 910f                      	pop		w
000897 9518                      	reti
                                 
                                 reset:	
000898 ef0f
000899 bf0d
00089a e100
00089b bf0e                      	LDSP	RAMEND			; load stack pointer (SP)
00089c ef0f
00089d bb07                      	OUTI	DDRB, 0xff
                                 	
00089e e0b0                      	ldi xh, high(m_eep_addr)
00089f e0a0                      	ldi xl, low(m_eep_addr)
0008a0 df49                      	rcall eeprom_load
0008a1 2e62                      	mov m,a0
                                 
0008a2 e001                      	ldi		w,1
0008a3 9300 0202                 	sts		unit_addr,w
                                 
0008a5 de25                      	rcall	temp_reset	
0008a6 dc39                      	rcall	LCD_init		; initialize LCD
                                 
0008a7 e008
0008a8 bf00                      	OUTI	ASSR, (1<<AS0)	; clock from TOSC1 (external)
0008a9 e007
0008aa bf03                      	OUTI	TCCR0,7			; CS0=7 CK/1024
0008ab e001
0008ac bf07                      	OUTI	TIMSK, 1<<TOIE0
0008ad 9478                      	sei		
0008ae de29                      	rcall	update_temp
                                 
0008af cf41                      	rjmp	affichage
                                 
                                 
                                 main:
0008b0 ba68                      	out PORTB, m
0008b1 debb                      	rcall	read_remote
0008b2 9478                      	sei
                                 
0008b3 3060                      	cpi		b0,0
0008b4 f009                      	breq	error
                                 
0008b5 c001                      	rjmp	gestion_bouton
                                 
                                 error:
0008b6 cff9                      	rjmp	main
                                 
                                 
                                 gestion_bouton:				;button code to their function
0008b7 3262                      	cpi		b0, 0x22		
0008b8 f131                      	breq	mode_button		;>|
0008b9 3c62                      	cpi		b0, 0xC2		
0008ba f051                      	breq	next_menu		;>>|
0008bb 3062                      	cpi		b0, 0x02
0008bc f099                      	breq	previous_menu	;|<<
0008bd 3968                      	cpi		b0, 0x98
0008be f121                      	breq	switch_button	;double arrow
0008bf 3960                      	cpi		b0, 0x90
0008c0 f161                      	breq	plus_button		;+
0008c1 3a68                      	cpi		b0, 0xa8
0008c2 f199                      	breq	minus_button	;-
                                 
0008c3 940c 0913                 	jmp		num_pad_buttons
                                 
                                 next_menu:					;change menu (two last bits of m) to the right
0008c5 fc63                      	sbrc	m,3				;enter in the sub menu 
0008c6 c014                      	rjmp	change_sub
                                 
0008c7 2d16                      	mov		_w, m			;save the m register in _w
0008c8 7013                      	andi	_w, 0b00000011	;save the two la bits of m and clear the other
0008c9 5f1f                      	subi	_w, -1			;change the two last bits of m by adding 1: 00-01-10-11-00-...
0008ca 7013                      	andi	_w, 0b00000011	;save the two last bits of m and clear the other
0008cb ef0c
0008cc 2260                      	_ANDI	m, 0b11111100	;clear the two lastbits of m with a mask
0008cd 0e61                      	add		m,_w			;assemble the unmodified part with the last two bits
0008ce 940c 0947                 	jmp		save_m_eeprom
                                 
                                 previous_menu:				;change menu (two last bits of m) to the left
0008d0 fc63                      	sbrc	m,3				;enter in the sub menu 
0008d1 c009                      	rjmp	change_sub
                                 
0008d2 2d16                      	mov		_w, m			;save the m register in _w 
0008d3 7013                      	andi	_w, 0b00000011	;save the two la bits of m and clear the other
0008d4 5011                      	subi	_w, 1			;change the two last bits of register m by substracting 1: 00-11-10-01-00-...
0008d5 7013                      	andi	_w, 0b00000011	;save the two last bits of m and clear the other 
0008d6 ef0c
0008d7 2260                      	_ANDI	m, 0b11111100	;clear the two lastbits of m with a mask
0008d8 0e61                      	add		m,_w			;assemble the unmodified part with the last two bits
0008d9 940c 0947                 	jmp		save_m_eeprom
                                 
                                 change_sub:					;change the sub menu (4th bit of m)
0008db e100                      	ldi		w, 0b00010000	;load the 4th bit in w
0008dc 2660                      	eor		m, w			;change the 4th bit of m
0008dd 940c 0947                 	jmp		save_m_eeprom
                                 
                                 mode_button:				;enter or exit the sub menu (3rd bit of m)
0008df e008                      	ldi		w, 0b00001000	;load the 3rd bit in w
0008e0 2660                      	eor		m, w			;change the 3rd bit of m
0008e1 940c 0947                 	jmp		save_m_eeprom
                                 
                                 switch_button:				;choose btw Celcius and Fahrenheit
0008e3 2d06                      	mov		w, m			;load m in w
0008e4 700b                      	andi	w, 0b00001011	;use a mask to keep only the bits 0,1,3
0008e5 3009                      	cpi		w, 0b00001001	;see if we are in the the correct sub menu
0008e6 f009                      	breq	PC+2			
0008e7 940c 07f1                 	jmp		affichage		;we are in the wrong sub menu
0008e9 e004                      	ldi		w, 0b00000100	;correct sub menu, load the 2nd bit in w
0008ea 2660                      	eor		m, w			;modify the 2nd bit of m
0008eb 940c 0947                 	jmp		save_m_eeprom
                                 
                                 plus_button:					;button used to increase the temp value
0008ed 2d06
0008ee 700b
0008ef 3008
0008f0 f009
0008f1 940c 07f1                 	CHECK_MENU_LIMIT
0008f3 9100 0202                 	lds		w, unit_addr
0008f5 c00b                      	rjmp	change_temp
                                 
                                 minus_button:					;button used to lower the temp value
0008f6 2d06
0008f7 700b
0008f8 3008
0008f9 f009
0008fa 940c 07f1                 	CHECK_MENU_LIMIT
0008fc 9100 0202                 	lds		w, unit_addr
0008fe 9500                      	com		w					;start reversing bits
0008ff 5f0f                      	subi	w, (-1)				;add 1 so that all bits are inverted
000900 c000                      	rjmp	change_temp
                                 
                                 change_temp:
000901 fc64                      	sbrc	m, 4
000902 c003                      	rjmp	load_tl
                                 
000903 9120 0200                 	lds		a0, th_addr
000905 c002                      	rjmp	new_t
                                 
                                 load_tl:
000906 9120 0201                 	lds		a0, tl_addr
                                 
                                 new_t:
000908 0f20                      	add		a0, w
                                 
000909 fc64                      	sbrc	m,4
00090a c003                      	rjmp	store_tl
                                 
00090b 9320 0200                 	sts		th_addr,a0
00090d c002                      	rjmp	save_t
                                 
                                 store_tl:
00090e 9320 0201                 	sts		tl_addr,a0
                                 
                                 save_t:
000910 de00                      	rcall	save_t_eeprom
000911 940c 07f1                 	jmp		affichage
                                 
                                 
                                 num_pad_buttons:				;button code to their function
000913 2d06
000914 700b
000915 3008
000916 f009
000917 940c 07f1                 	CHECK_MENU_LIMIT
000919 3360                      	cpi		b0, 0x30
00091a f0a1                      	breq	button_one		;1
00091b 3168                      	cpi		b0, 0x18
00091c f0a1                      	breq	button_two		;2
00091d 376a                      	cpi		b0, 0x7a
00091e f0a1                      	breq	button_three	;3
00091f 3160                      	cpi		b0, 0x10
000920 f0a1                      	breq	button_four		;4
000921 3368                      	cpi		b0, 0x38
000922 f0a1                      	breq	button_five		;5
000923 356a                      	cpi		b0, 0x5a
000924 f0a1                      	breq	button_six		;6
000925 3462                      	cpi		b0, 0x42
000926 f0a1                      	breq	button_seven	;7
000927 346a                      	cpi		b0, 0x4a
000928 f0a1                      	breq	button_eight	;8
000929 3562                      	cpi		b0, 0x52
00092a f0a1                      	breq	button_nine		;9
00092b 3668                      	cpi		b0, 0x68
00092c f0a1                      	breq	button_zero		;0
                                 
00092d 940c 07f1                 	jmp		affichage
                                 
                                 button_one:							;button used to change to 1 the unit to add/remove at the temp lim
00092f e001                      	ldi		w,1
000930 c012                      	rjmp	change_unit
                                 
                                 button_two:							;button used to change to 2 the unit to add/remove at the temp lim
000931 e002                      	ldi		w,2
000932 c010                      	rjmp	change_unit
                                 
                                 button_three:						;button used to change to 3 the unit to add/remove at the temp lim
000933 e003                      	ldi		w,3
000934 c00e                      	rjmp	change_unit
                                 	
                                 button_four:						;button used to change to 4 the unit to add/remove at the temp lim
000935 e004                      	ldi		w,4
000936 c00c                      	rjmp	change_unit
                                 
                                 button_five:						;button used to change to 5 the unit to add/remove at the temp lim
000937 e005                      	ldi		w,5
000938 c00a                      	rjmp	change_unit
                                 
                                 button_six:							;button used to change to 6 the unit to add/remove at the temp lim
000939 e006                      	ldi		w,6
00093a c008                      	rjmp	change_unit
                                 
                                 button_seven:						;button used to change to 7 the unit to add/remove at the temp lim
00093b e007                      	ldi		w,7
00093c c006                      	rjmp	change_unit
                                 
                                 button_eight:						;button used to change to 8 the unit to add/remove at the temp lim
00093d e008                      	ldi		w,8
00093e c004                      	rjmp	change_unit
                                 
                                 button_nine:						;button used to change to 9 the unit to add/remove at the temp lim
00093f e009                      	ldi		w,9
000940 c002                      	rjmp	change_unit
                                 
                                 button_zero:						;button used to change to 10 the unit to add/remove at the temp lim
000941 e00a                      	ldi		w,10
000942 c000                      	rjmp	change_unit
                                 
                                 change_unit:						;change the value of the unit in the address
000943 9300 0202                 	sts		unit_addr, w
000945 940c 07f1                 	jmp		affichage
                                 
                                 save_m_eeprom:
000947 e0b0                      	ldi xh, high(m_eep_addr)
000948 e0a0                      	ldi xl, low(m_eep_addr)
000949 2d26                      	mov a0,m
00094a de91                      	rcall	eeprom_store


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega128" register use summary:
x  :   6 y  :   0 z  :   0 r0 :  99 r1 :   2 r2 :   0 r3 :  27 r4 :  11 
r5 :  11 r6 :  26 r7 :   0 r8 : 114 r9 : 150 r10: 142 r11: 145 r12: 190 
r13: 138 r14:  46 r15:  48 r16: 256 r17:  24 r18: 232 r19: 193 r20: 102 
r21:  51 r22: 159 r23: 108 r24:  32 r25:  25 r26:  12 r27:  12 r28:   0 
r29:   0 r30:  11 r31:   6 
Registers used: 29 out of 35 (82.9%)

"ATmega128" instruction use summary:
.lds  :   0 .sts  :   0 adc   : 324 add   : 146 adiw  :   5 and   :   2 
andi  :  16 asr   :   2 bclr  :   0 bld   :  13 brbc  :   0 brbs  :   0 
brcc  :  27 brcs  :   0 break :   0 breq  :  42 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   1 brlo  :   1 brlt  :   0 brmi  :   1 
brne  :  39 brpl  :   3 brsh  :   1 brtc  :   7 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :  19 call  :   0 cbi   :   8 cbr   :   0 
clc   :   5 clh   :   0 cli   :   2 cln   :   0 clr   :  46 cls   :   0 
clt   :   1 clv   :   0 clz   :   0 com   :  19 cp    :   9 cpc   :   3 
cpi   :  34 cpse  :   2 dec   :  38 elpm  :   0 eor   :   6 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   1 ijmp  :   1 in    :   7 inc   :   2 
jmp   :  24 ld    :   6 ldd   :   0 ldi   : 160 lds   :  18 lpm   :  12 
lsl   :   2 lsr   :  14 mov   :  89 movw  :   0 mul   :   0 muls  :   0 
mulsu :   0 neg   :   0 nop   :   6 or    :   0 ori   :   2 out   :  15 
pop   :  34 push  :  33 rcall :  96 ret   :  49 reti  :   1 rjmp  : 183 
rol   :  98 ror   : 284 sbc   :  32 sbci  :   1 sbi   :  10 sbic  :   5 
sbis  :   2 sbiw  :   0 sbr   :   1 sbrc  :  33 sbrs  : 110 sec   :   2 
seh   :   0 sei   :   3 sen   :   0 ser   :   0 ses   :   0 set   :   1 
sev   :   0 sez   :   0 sleep :   0 spm   :   0 st    :   0 std   :   0 
sts   :  13 sub   :  48 subi  :  13 swap  :   4 tst   :   8 wdr   :   0 

Instructions used: 68 out of 114 (59.6%)

"ATmega128" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x00129a   4584    118   4702  131072   3.6%
[.dseg] 0x000100 0x000100      0      0      0    4096   0.0%
[.eseg] 0x000000 0x000000      0      0      0    4096   0.0%

Assembly complete, 0 errors, 14 warnings

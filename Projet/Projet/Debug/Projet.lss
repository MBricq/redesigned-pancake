
AVRASM ver. 2.2.8  C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\main.asm Sat May 29 15:03:37 2021

[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.1.130\avrasm\inc\m128def.inc'
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\main.asm(6): Including file 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\Libraries\macros.asm'
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\main.asm(7): Including file 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\Libraries\definitions.asm'
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\main.asm(36): Including file 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\temp.asm'
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\temp.asm(4): Including file 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\Libraries\math_speed.asm'
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\temp.asm(5): Including file 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\Libraries\lcd.asm'
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\temp.asm(6): Including file 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\Libraries\wire1.asm'
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\temp.asm(7): Including file 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\Libraries\printf.asm'
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\temp.asm(8): Including file 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\macro_projet.asm'
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\main.asm(37): Including file 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\remote.asm'
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\remote.asm(4): Including file 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\musique.asm'
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\musique.asm(4): Including file 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\Libraries/sound.asm'
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\main.asm(38): Including file 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\Libraries\eeprom.asm'
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\main.asm(39): Including file 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\affichage.asm'
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\main.asm(40): Including file 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\ir_button.asm'
[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.1.130\avrasm\inc\m128def.inc'
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\main.asm(6): Including file 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\Libraries\macros.asm'
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\main.asm(7): Including file 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\Libraries\definitions.asm'
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\main.asm(36): Including file 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\temp.asm'
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\temp.asm(4): Including file 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\Libraries\math_speed.asm'
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\temp.asm(5): Including file 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\Libraries\lcd.asm'
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\temp.asm(6): Including file 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\Libraries\wire1.asm'
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\temp.asm(7): Including file 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\Libraries\printf.asm'
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\temp.asm(8): Including file 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\macro_projet.asm'
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\main.asm(37): Including file 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\remote.asm'
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\remote.asm(4): Including file 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\musique.asm'
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\musique.asm(4): Including file 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\Libraries/sound.asm'
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\main.asm(38): Including file 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\Libraries\eeprom.asm'
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\main.asm(39): Including file 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\affichage.asm'
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\main.asm(40): Including file 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\ir_button.asm'
                                 
                                 ; file main.asm   target ATmega128L-4MHz-STK300
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega128.xml ***********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m128def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega128
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega128
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M128DEF_INC_
                                 #define _M128DEF_INC_
                                 
                                 
                                 #pragma partinc 0
                                 
                                 ; ***** SPECIFY DEVICE ***************************************************
                                 .device ATmega128
                                 #pragma AVRPART ADMIN PART_NAME ATmega128
                                 .equ	SIGNATURE_000	= 0x1e
                                 .equ	SIGNATURE_001	= 0x97
                                 .equ	SIGNATURE_002	= 0x02
                                 
                                 #pragma AVRPART CORE CORE_VERSION V2E
                                 
                                 
                                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                                 ; NOTE:
                                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                                 ; and cannot be used with IN/OUT instructions
                                 .equ	UCSR1C	= 0x9d	; MEMORY MAPPED
                                 .equ	UDR1	= 0x9c	; MEMORY MAPPED
                                 .equ	UCSR1A	= 0x9b	; MEMORY MAPPED
                                 .equ	UCSR1B	= 0x9a	; MEMORY MAPPED
                                 .equ	UBRR1H	= 0x98	; MEMORY MAPPED
                                 .equ	UBRR1L	= 0x99	; MEMORY MAPPED
                                 .equ	UCSR0C	= 0x95	; MEMORY MAPPED
                                 .equ	UBRR0H	= 0x90	; MEMORY MAPPED
                                 .equ	TCCR3C	= 0x8c	; MEMORY MAPPED
                                 .equ	TCCR3A	= 0x8b	; MEMORY MAPPED
                                 .equ	TCCR3B	= 0x8a	; MEMORY MAPPED
                                 .equ	TCNT3L	= 0x88	; MEMORY MAPPED
                                 .equ	TCNT3H	= 0x89	; MEMORY MAPPED
                                 .equ	OCR3AL	= 0x86	; MEMORY MAPPED
                                 .equ	OCR3AH	= 0x87	; MEMORY MAPPED
                                 .equ	OCR3BL	= 0x84	; MEMORY MAPPED
                                 .equ	OCR3BH	= 0x85	; MEMORY MAPPED
                                 .equ	OCR3CL	= 0x82	; MEMORY MAPPED
                                 .equ	OCR3CH	= 0x83	; MEMORY MAPPED
                                 .equ	ICR3L	= 0x80	; MEMORY MAPPED
                                 .equ	ICR3H	= 0x81	; MEMORY MAPPED
                                 .equ	ETIMSK	= 0x7d	; MEMORY MAPPED
                                 .equ	ETIFR	= 0x7c	; MEMORY MAPPED
                                 .equ	TCCR1C	= 0x7a	; MEMORY MAPPED
                                 .equ	OCR1CL	= 0x78	; MEMORY MAPPED
                                 .equ	OCR1CH	= 0x79	; MEMORY MAPPED
                                 .equ	TWCR	= 0x74	; MEMORY MAPPED
                                 .equ	TWDR	= 0x73	; MEMORY MAPPED
                                 .equ	TWAR	= 0x72	; MEMORY MAPPED
                                 .equ	TWSR	= 0x71	; MEMORY MAPPED
                                 .equ	TWBR	= 0x70	; MEMORY MAPPED
                                 .equ	OSCCAL	= 0x6f	; MEMORY MAPPED
                                 .equ	XMCRA	= 0x6d	; MEMORY MAPPED
                                 .equ	XMCRB	= 0x6c	; MEMORY MAPPED
                                 .equ	EICRA	= 0x6a	; MEMORY MAPPED
                                 .equ	SPMCSR	= 0x68	; MEMORY MAPPED
                                 .equ	PORTG	= 0x65	; MEMORY MAPPED
                                 .equ	DDRG	= 0x64	; MEMORY MAPPED
                                 .equ	PING	= 0x63	; MEMORY MAPPED
                                 .equ	PORTF	= 0x62	; MEMORY MAPPED
                                 .equ	DDRF	= 0x61	; MEMORY MAPPED
                                 .equ	SREG	= 0x3f
                                 .equ	SPL	= 0x3d
                                 .equ	SPH	= 0x3e
                                 .equ	XDIV	= 0x3c
                                 .equ	RAMPZ	= 0x3b
                                 .equ	EICRB	= 0x3a
                                 .equ	EIMSK	= 0x39
                                 .equ	EIFR	= 0x38
                                 .equ	TIMSK	= 0x37
                                 .equ	TIFR	= 0x36
                                 .equ	MCUCR	= 0x35
                                 .equ	MCUCSR	= 0x34
                                 .equ	TCCR0	= 0x33
                                 .equ	TCNT0	= 0x32
                                 .equ	OCR0	= 0x31
                                 .equ	ASSR	= 0x30
                                 .equ	TCCR1A	= 0x2f
                                 .equ	TCCR1B	= 0x2e
                                 .equ	TCNT1L	= 0x2c
                                 .equ	TCNT1H	= 0x2d
                                 .equ	OCR1AL	= 0x2a
                                 .equ	OCR1AH	= 0x2b
                                 .equ	OCR1BL	= 0x28
                                 .equ	OCR1BH	= 0x29
                                 .equ	ICR1L	= 0x26
                                 .equ	ICR1H	= 0x27
                                 .equ	TCCR2	= 0x25
                                 .equ	TCNT2	= 0x24
                                 .equ	OCR2	= 0x23
                                 .equ	OCDR	= 0x22
                                 .equ	WDTCR	= 0x21
                                 .equ	SFIOR	= 0x20
                                 .equ	EEARL	= 0x1e
                                 .equ	EEARH	= 0x1f
                                 .equ	EEDR	= 0x1d
                                 .equ	EECR	= 0x1c
                                 .equ	PORTA	= 0x1b
                                 .equ	DDRA	= 0x1a
                                 .equ	PINA	= 0x19
                                 .equ	PORTB	= 0x18
                                 .equ	DDRB	= 0x17
                                 .equ	PINB	= 0x16
                                 .equ	PORTC	= 0x15
                                 .equ	DDRC	= 0x14
                                 .equ	PINC	= 0x13
                                 .equ	PORTD	= 0x12
                                 .equ	DDRD	= 0x11
                                 .equ	PIND	= 0x10
                                 .equ	SPDR	= 0x0f
                                 .equ	SPSR	= 0x0e
                                 .equ	SPCR	= 0x0d
                                 .equ	UDR0	= 0x0c
                                 .equ	UCSR0A	= 0x0b
                                 .equ	UCSR0B	= 0x0a
                                 .equ	UBRR0L	= 0x09
                                 .equ	ACSR	= 0x08
                                 .equ	ADMUX	= 0x07
                                 .equ	ADCSRA	= 0x06
                                 .equ	ADCH	= 0x05
                                 .equ	ADCL	= 0x04
                                 .equ	PORTE	= 0x03
                                 .equ	DDRE	= 0x02
                                 .equ	PINE	= 0x01
                                 .equ	PINF	= 0x00
                                 
                                 
                                 ; ***** BIT DEFINITIONS **************************************************
                                 
                                 ; ***** ANALOG_COMPARATOR ************
                                 ; SFIOR - Special Function IO Register
                                 .equ	ACME	= 3	; Analog Comparator Multiplexer Enable
                                 
                                 ; ACSR - Analog Comparator Control And Status Register
                                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                                 .equ	ACO	= 5	; Analog Compare Output
                                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                                 .equ	ACD	= 7	; Analog Comparator Disable
                                 
                                 
                                 ; ***** SPI **************************
                                 ; SPDR - SPI Data Register
                                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                                 
                                 ; SPSR - SPI Status Register
                                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                                 .equ	WCOL	= 6	; Write Collision Flag
                                 .equ	SPIF	= 7	; SPI Interrupt Flag
                                 
                                 ; SPCR - SPI Control Register
                                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                                 .equ	CPHA	= 2	; Clock Phase
                                 .equ	CPOL	= 3	; Clock polarity
                                 .equ	MSTR	= 4	; Master/Slave Select
                                 .equ	DORD	= 5	; Data Order
                                 .equ	SPE	= 6	; SPI Enable
                                 .equ	SPIE	= 7	; SPI Interrupt Enable
                                 
                                 
                                 ; ***** TWI **************************
                                 ; TWBR - TWI Bit Rate register
                                 .equ	I2BR	= TWBR	; For compatibility
                                 .equ	TWBR0	= 0	; 
                                 .equ	TWBR1	= 1	; 
                                 .equ	TWBR2	= 2	; 
                                 .equ	TWBR3	= 3	; 
                                 .equ	TWBR4	= 4	; 
                                 .equ	TWBR5	= 5	; 
                                 .equ	TWBR6	= 6	; 
                                 .equ	TWBR7	= 7	; 
                                 
                                 ; TWCR - TWI Control Register
                                 .equ	I2CR	= TWCR	; For compatibility
                                 .equ	TWIE	= 0	; TWI Interrupt Enable
                                 .equ	I2IE	= TWIE	; For compatibility
                                 .equ	TWEN	= 2	; TWI Enable Bit
                                 .equ	I2EN	= TWEN	; For compatibility
                                 .equ	ENI2C	= TWEN	; For compatibility
                                 .equ	TWWC	= 3	; TWI Write Collition Flag
                                 .equ	I2WC	= TWWC	; For compatibility
                                 .equ	TWSTO	= 4	; TWI Stop Condition Bit
                                 .equ	I2STO	= TWSTO	; For compatibility
                                 .equ	TWSTA	= 5	; TWI Start Condition Bit
                                 .equ	I2STA	= TWSTA	; For compatibility
                                 .equ	TWEA	= 6	; TWI Enable Acknowledge Bit
                                 .equ	I2EA	= TWEA	; For compatibility
                                 .equ	TWINT	= 7	; TWI Interrupt Flag
                                 .equ	I2INT	= TWINT	; For compatibility
                                 
                                 ; TWSR - TWI Status Register
                                 .equ	I2SR	= TWSR	; For compatibility
                                 .equ	TWPS0	= 0	; TWI Prescaler
                                 .equ	TWS0	= TWPS0	; For compatibility
                                 .equ	I2GCE	= TWPS0	; For compatibility
                                 .equ	TWPS1	= 1	; TWI Prescaler
                                 .equ	TWS1	= TWPS1	; For compatibility
                                 .equ	TWS3	= 3	; TWI Status
                                 .equ	I2S3	= TWS3	; For compatibility
                                 .equ	TWS4	= 4	; TWI Status
                                 .equ	I2S4	= TWS4	; For compatibility
                                 .equ	TWS5	= 5	; TWI Status
                                 .equ	I2S5	= TWS5	; For compatibility
                                 .equ	TWS6	= 6	; TWI Status
                                 .equ	I2S6	= TWS6	; For compatibility
                                 .equ	TWS7	= 7	; TWI Status
                                 .equ	I2S7	= TWS7	; For compatibility
                                 
                                 ; TWDR - TWI Data register
                                 .equ	I2DR	= TWDR	; For compatibility
                                 .equ	TWD0	= 0	; TWI Data Register Bit 0
                                 .equ	TWD1	= 1	; TWI Data Register Bit 1
                                 .equ	TWD2	= 2	; TWI Data Register Bit 2
                                 .equ	TWD3	= 3	; TWI Data Register Bit 3
                                 .equ	TWD4	= 4	; TWI Data Register Bit 4
                                 .equ	TWD5	= 5	; TWI Data Register Bit 5
                                 .equ	TWD6	= 6	; TWI Data Register Bit 6
                                 .equ	TWD7	= 7	; TWI Data Register Bit 7
                                 
                                 ; TWAR - TWI (Slave) Address register
                                 .equ	I2AR	= TWAR	; For compatibility
                                 .equ	TWGCE	= 0	; TWI General Call Recognition Enable Bit
                                 .equ	TWA0	= 1	; TWI (Slave) Address register Bit 0
                                 .equ	TWA1	= 2	; TWI (Slave) Address register Bit 1
                                 .equ	TWA2	= 3	; TWI (Slave) Address register Bit 2
                                 .equ	TWA3	= 4	; TWI (Slave) Address register Bit 3
                                 .equ	TWA4	= 5	; TWI (Slave) Address register Bit 4
                                 .equ	TWA5	= 6	; TWI (Slave) Address register Bit 5
                                 .equ	TWA6	= 7	; TWI (Slave) Address register Bit 6
                                 
                                 
                                 ; ***** USART0 ***********************
                                 ; UDR0 - USART I/O Data Register
                                 .equ	UDR00	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR01	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR02	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR03	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR04	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR05	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR06	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR07	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR0A - USART Control and Status Register A
                                 .equ	MPCM0	= 0	; Multi-processor Communication Mode
                                 .equ	U2X0	= 1	; Double the USART transmission speed
                                 .equ	UPE0	= 2	; Parity Error
                                 .equ	DOR0	= 3	; Data overRun
                                 .equ	FE0	= 4	; Framing Error
                                 .equ	UDRE0	= 5	; USART Data Register Empty
                                 .equ	TXC0	= 6	; USART Transmitt Complete
                                 .equ	RXC0	= 7	; USART Receive Complete
                                 
                                 ; UCSR0B - USART Control and Status Register B
                                 .equ	TXB80	= 0	; Transmit Data Bit 8
                                 .equ	RXB80	= 1	; Receive Data Bit 8
                                 .equ	UCSZ02	= 2	; Character Size
                                 .equ	UCSZ2	= UCSZ02	; For compatibility
                                 .equ	TXEN0	= 3	; Transmitter Enable
                                 .equ	RXEN0	= 4	; Receiver Enable
                                 .equ	UDRIE0	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE0	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE0	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR0C - USART Control and Status Register C
                                 .equ	UCPOL0	= 0	; Clock Polarity
                                 .equ	UCSZ00	= 1	; Character Size
                                 .equ	UCSZ01	= 2	; Character Size
                                 .equ	USBS0	= 3	; Stop Bit Select
                                 .equ	UPM00	= 4	; Parity Mode Bit 0
                                 .equ	UPM01	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL0	= 6	; USART Mode Select
                                 
                                 ; UBRR0H - USART Baud Rate Register Hight Byte
                                 .equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 .equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 .equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 .equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR0L - USART Baud Rate Register Low Byte
                                 .equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                                 .equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                                 .equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                                 .equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                                 .equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                                 .equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                                 .equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                                 .equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** USART1 ***********************
                                 ; UDR1 - USART I/O Data Register
                                 .equ	UDR10	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR11	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR12	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR13	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR14	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR15	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR16	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR17	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR1A - USART Control and Status Register A
                                 .equ	MPCM1	= 0	; Multi-processor Communication Mode
                                 .equ	U2X1	= 1	; Double the USART transmission speed
                                 .equ	UPE1	= 2	; Parity Error
                                 .equ	DOR1	= 3	; Data overRun
                                 .equ	FE1	= 4	; Framing Error
                                 .equ	UDRE1	= 5	; USART Data Register Empty
                                 .equ	TXC1	= 6	; USART Transmitt Complete
                                 .equ	RXC1	= 7	; USART Receive Complete
                                 
                                 ; UCSR1B - USART Control and Status Register B
                                 .equ	TXB81	= 0	; Transmit Data Bit 8
                                 .equ	RXB81	= 1	; Receive Data Bit 8
                                 .equ	UCSZ12	= 2	; Character Size
                                 .equ	TXEN1	= 3	; Transmitter Enable
                                 .equ	RXEN1	= 4	; Receiver Enable
                                 .equ	UDRIE1	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE1	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE1	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR1C - USART Control and Status Register C
                                 .equ	UCPOL1	= 0	; Clock Polarity
                                 .equ	UCSZ10	= 1	; Character Size
                                 .equ	UCSZ11	= 2	; Character Size
                                 .equ	USBS1	= 3	; Stop Bit Select
                                 .equ	UPM10	= 4	; Parity Mode Bit 0
                                 .equ	UPM11	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL1	= 6	; USART Mode Select
                                 
                                 ; UBRR1H - USART Baud Rate Register Hight Byte
                                 ;.equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 ;.equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 ;.equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 ;.equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR1L - USART Baud Rate Register Low Byte
                                 ;.equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                                 ;.equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                                 ;.equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                                 ;.equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                                 ;.equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                                 ;.equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                                 ;.equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                                 ;.equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** CPU **************************
                                 ; SREG - Status Register
                                 .equ	SREG_C	= 0	; Carry Flag
                                 .equ	SREG_Z	= 1	; Zero Flag
                                 .equ	SREG_N	= 2	; Negative Flag
                                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                                 .equ	SREG_S	= 4	; Sign Bit
                                 .equ	SREG_H	= 5	; Half Carry Flag
                                 .equ	SREG_T	= 6	; Bit Copy Storage
                                 .equ	SREG_I	= 7	; Global Interrupt Enable
                                 
                                 ; MCUCR - MCU Control Register
                                 .equ	IVCE	= 0	; Interrupt Vector Change Enable
                                 .equ	IVSEL	= 1	; Interrupt Vector Select
                                 .equ	SM2	= 2	; Sleep Mode Select
                                 .equ	SM0	= 3	; Sleep Mode Select
                                 .equ	SM1	= 4	; Sleep Mode Select
                                 .equ	SE	= 5	; Sleep Enable
                                 .equ	SRW10	= 6	; External SRAM Wait State Select
                                 .equ	SRE	= 7	; External SRAM Enable
                                 
                                 ; XMCRA - External Memory Control Register A
                                 .equ	SRW11	= 1	; Wait state select bit upper page
                                 .equ	SRW00	= 2	; Wait state select bit lower page
                                 .equ	SRW01	= 3	; Wait state select bit lower page
                                 .equ	SRL0	= 4	; Wait state page limit
                                 .equ	SRL1	= 5	; Wait state page limit
                                 .equ	SRL2	= 6	; Wait state page limit
                                 
                                 ; XMCRB - External Memory Control Register B
                                 .equ	XMM0	= 0	; External Memory High Mask
                                 .equ	XMM1	= 1	; External Memory High Mask
                                 .equ	XMM2	= 2	; External Memory High Mask
                                 .equ	XMBK	= 7	; External Memory Bus Keeper Enable
                                 
                                 ; OSCCAL - Oscillator Calibration Value
                                 .equ	CAL0	= 0	; Oscillator Calibration Value
                                 .equ	CAL1	= 1	; Oscillator Calibration Value
                                 .equ	CAL2	= 2	; Oscillator Calibration Value
                                 .equ	CAL3	= 3	; Oscillator Calibration Value
                                 .equ	CAL4	= 4	; Oscillator Calibration Value
                                 .equ	CAL5	= 5	; Oscillator Calibration Value
                                 .equ	CAL6	= 6	; Oscillator Calibration Value
                                 .equ	CAL7	= 7	; Oscillator Calibration Value
                                 
                                 ; XDIV - XTAL Divide Control Register
                                 .equ	XDIV0	= 0	; XTAl Divide Select Bit 0
                                 .equ	XDIV1	= 1	; XTAl Divide Select Bit 1
                                 .equ	XDIV2	= 2	; XTAl Divide Select Bit 2
                                 .equ	XDIV3	= 3	; XTAl Divide Select Bit 3
                                 .equ	XDIV4	= 4	; XTAl Divide Select Bit 4
                                 .equ	XDIV5	= 5	; XTAl Divide Select Bit 5
                                 .equ	XDIV6	= 6	; XTAl Divide Select Bit 6
                                 .equ	XDIVEN	= 7	; XTAL Divide Enable
                                 
                                 ; MCUCSR - MCU Control And Status Register
                                 .equ	PORF	= 0	; Power-on reset flag
                                 .equ	EXTRF	= 1	; External Reset Flag
                                 .equ	BORF	= 2	; Brown-out Reset Flag
                                 .equ	WDRF	= 3	; Watchdog Reset Flag
                                 .equ	JTRF	= 4	; JTAG Reset Flag
                                 .equ	JTD	= 7	; JTAG Interface Disable
                                 
                                 ; RAMPZ - RAM Page Z Select Register
                                 .equ	RAMPZ0	= 0	; RAM Page Z Select Register Bit 0
                                 
                                 
                                 ; ***** BOOT_LOAD ********************
                                 ; SPMCSR - Store Program Memory Control Register
                                 .equ	SPMCR	= SPMCSR	; For compatibility
                                 .equ	SPMEN	= 0	; Store Program Memory Enable
                                 .equ	PGERS	= 1	; Page Erase
                                 .equ	PGWRT	= 2	; Page Write
                                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                                 .equ	RWWSRE	= 4	; Read While Write section read enable
                                 .equ	ASRE	= RWWSRE	; For compatibility
                                 .equ	RWWSB	= 6	; Read While Write Section Busy
                                 .equ	ASB	= RWWSB	; For compatibility
                                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                                 
                                 
                                 ; ***** JTAG *************************
                                 ; OCDR - On-Chip Debug Related Register in I/O Memory
                                 .equ	OCDR0	= 0	; On-Chip Debug Register Bit 0
                                 .equ	OCDR1	= 1	; On-Chip Debug Register Bit 1
                                 .equ	OCDR2	= 2	; On-Chip Debug Register Bit 2
                                 .equ	OCDR3	= 3	; On-Chip Debug Register Bit 3
                                 .equ	OCDR4	= 4	; On-Chip Debug Register Bit 4
                                 .equ	OCDR5	= 5	; On-Chip Debug Register Bit 5
                                 .equ	OCDR6	= 6	; On-Chip Debug Register Bit 6
                                 .equ	OCDR7	= 7	; On-Chip Debug Register Bit 7
                                 .equ	IDRD	= OCDR7	; For compatibility
                                 
                                 ; MCUCSR - MCU Control And Status Register
                                 ;.equ	JTRF	= 4	; JTAG Reset Flag
                                 ;.equ	JTD	= 7	; JTAG Interface Disable
                                 
                                 
                                 ; ***** MISC *************************
                                 ; SFIOR - Special Function IO Register
                                 .equ	PSR321	= 0	; Prescaler Reset Timer/Counter3, Timer/Counter2, and Timer/Counter1
                                 .equ	PSR1	= PSR321	; For compatibility
                                 .equ	PSR2	= PSR321	; For compatibility
                                 .equ	PSR3	= PSR321	; For compatibility
                                 .equ	PSR0	= 1	; Prescaler Reset Timer/Counter0
                                 .equ	PUD	= 2	; Pull Up Disable
                                 ;.equ	ACME	= 3	; Analog Comparator Multiplexer Enable
                                 .equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** EXTERNAL_INTERRUPT ***********
                                 ; EICRA - External Interrupt Control Register A
                                 .equ	ISC00	= 0	; External Interrupt Sense Control Bit
                                 .equ	ISC01	= 1	; External Interrupt Sense Control Bit
                                 .equ	ISC10	= 2	; External Interrupt Sense Control Bit
                                 .equ	ISC11	= 3	; External Interrupt Sense Control Bit
                                 .equ	ISC20	= 4	; External Interrupt Sense Control Bit
                                 .equ	ISC21	= 5	; External Interrupt Sense Control Bit
                                 .equ	ISC30	= 6	; External Interrupt Sense Control Bit
                                 .equ	ISC31	= 7	; External Interrupt Sense Control Bit
                                 
                                 ; EICRB - External Interrupt Control Register B
                                 .equ	ISC40	= 0	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC41	= 1	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC50	= 2	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC51	= 3	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC60	= 4	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC61	= 5	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC70	= 6	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC71	= 7	; External Interrupt 7-4 Sense Control Bit
                                 
                                 ; EIMSK - External Interrupt Mask Register
                                 .equ	GICR	= EIMSK	; For compatibility
                                 .equ	GIMSK	= EIMSK	; For compatibility
                                 .equ	INT0	= 0	; External Interrupt Request 0 Enable
                                 .equ	INT1	= 1	; External Interrupt Request 1 Enable
                                 .equ	INT2	= 2	; External Interrupt Request 2 Enable
                                 .equ	INT3	= 3	; External Interrupt Request 3 Enable
                                 .equ	INT4	= 4	; External Interrupt Request 4 Enable
                                 .equ	INT5	= 5	; External Interrupt Request 5 Enable
                                 .equ	INT6	= 6	; External Interrupt Request 6 Enable
                                 .equ	INT7	= 7	; External Interrupt Request 7 Enable
                                 
                                 ; EIFR - External Interrupt Flag Register
                                 .equ	GIFR	= EIFR	; For compatibility
                                 .equ	INTF0	= 0	; External Interrupt Flag 0
                                 .equ	INTF1	= 1	; External Interrupt Flag 1
                                 .equ	INTF2	= 2	; External Interrupt Flag 2
                                 .equ	INTF3	= 3	; External Interrupt Flag 3
                                 .equ	INTF4	= 4	; External Interrupt Flag 4
                                 .equ	INTF5	= 5	; External Interrupt Flag 5
                                 .equ	INTF6	= 6	; External Interrupt Flag 6
                                 .equ	INTF7	= 7	; External Interrupt Flag 7
                                 
                                 
                                 ; ***** EEPROM ***********************
                                 ; EEDR - EEPROM Data Register
                                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                                 
                                 ; EECR - EEPROM Control Register
                                 .equ	EERE	= 0	; EEPROM Read Enable
                                 .equ	EEWE	= 1	; EEPROM Write Enable
                                 .equ	EEMWE	= 2	; EEPROM Master Write Enable
                                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                                 
                                 
                                 ; ***** PORTA ************************
                                 ; PORTA - Port A Data Register
                                 .equ	PORTA0	= 0	; Port A Data Register bit 0
                                 .equ	PA0	= 0	; For compatibility
                                 .equ	PORTA1	= 1	; Port A Data Register bit 1
                                 .equ	PA1	= 1	; For compatibility
                                 .equ	PORTA2	= 2	; Port A Data Register bit 2
                                 .equ	PA2	= 2	; For compatibility
                                 .equ	PORTA3	= 3	; Port A Data Register bit 3
                                 .equ	PA3	= 3	; For compatibility
                                 .equ	PORTA4	= 4	; Port A Data Register bit 4
                                 .equ	PA4	= 4	; For compatibility
                                 .equ	PORTA5	= 5	; Port A Data Register bit 5
                                 .equ	PA5	= 5	; For compatibility
                                 .equ	PORTA6	= 6	; Port A Data Register bit 6
                                 .equ	PA6	= 6	; For compatibility
                                 .equ	PORTA7	= 7	; Port A Data Register bit 7
                                 .equ	PA7	= 7	; For compatibility
                                 
                                 ; DDRA - Port A Data Direction Register
                                 .equ	DDA0	= 0	; Data Direction Register, Port A, bit 0
                                 .equ	DDA1	= 1	; Data Direction Register, Port A, bit 1
                                 .equ	DDA2	= 2	; Data Direction Register, Port A, bit 2
                                 .equ	DDA3	= 3	; Data Direction Register, Port A, bit 3
                                 .equ	DDA4	= 4	; Data Direction Register, Port A, bit 4
                                 .equ	DDA5	= 5	; Data Direction Register, Port A, bit 5
                                 .equ	DDA6	= 6	; Data Direction Register, Port A, bit 6
                                 .equ	DDA7	= 7	; Data Direction Register, Port A, bit 7
                                 
                                 ; PINA - Port A Input Pins
                                 .equ	PINA0	= 0	; Input Pins, Port A bit 0
                                 .equ	PINA1	= 1	; Input Pins, Port A bit 1
                                 .equ	PINA2	= 2	; Input Pins, Port A bit 2
                                 .equ	PINA3	= 3	; Input Pins, Port A bit 3
                                 .equ	PINA4	= 4	; Input Pins, Port A bit 4
                                 .equ	PINA5	= 5	; Input Pins, Port A bit 5
                                 .equ	PINA6	= 6	; Input Pins, Port A bit 6
                                 .equ	PINA7	= 7	; Input Pins, Port A bit 7
                                 
                                 
                                 ; ***** PORTB ************************
                                 ; PORTB - Port B Data Register
                                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                                 .equ	PB0	= 0	; For compatibility
                                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                                 .equ	PB1	= 1	; For compatibility
                                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                                 .equ	PB2	= 2	; For compatibility
                                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                                 .equ	PB3	= 3	; For compatibility
                                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                                 .equ	PB4	= 4	; For compatibility
                                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                                 .equ	PB5	= 5	; For compatibility
                                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                                 .equ	PB6	= 6	; For compatibility
                                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                                 .equ	PB7	= 7	; For compatibility
                                 
                                 ; DDRB - Port B Data Direction Register
                                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                                 
                                 ; PINB - Port B Input Pins
                                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                                 
                                 
                                 ; ***** PORTC ************************
                                 ; PORTC - Port C Data Register
                                 .equ	PORTC0	= 0	; Port C Data Register bit 0
                                 .equ	PC0	= 0	; For compatibility
                                 .equ	PORTC1	= 1	; Port C Data Register bit 1
                                 .equ	PC1	= 1	; For compatibility
                                 .equ	PORTC2	= 2	; Port C Data Register bit 2
                                 .equ	PC2	= 2	; For compatibility
                                 .equ	PORTC3	= 3	; Port C Data Register bit 3
                                 .equ	PC3	= 3	; For compatibility
                                 .equ	PORTC4	= 4	; Port C Data Register bit 4
                                 .equ	PC4	= 4	; For compatibility
                                 .equ	PORTC5	= 5	; Port C Data Register bit 5
                                 .equ	PC5	= 5	; For compatibility
                                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                                 .equ	PC6	= 6	; For compatibility
                                 .equ	PORTC7	= 7	; Port C Data Register bit 7
                                 .equ	PC7	= 7	; For compatibility
                                 
                                 ; DDRC - Port C Data Direction Register
                                 .equ	DDC0	= 0	; Port C Data Direction Register bit 0
                                 .equ	DDC1	= 1	; Port C Data Direction Register bit 1
                                 .equ	DDC2	= 2	; Port C Data Direction Register bit 2
                                 .equ	DDC3	= 3	; Port C Data Direction Register bit 3
                                 .equ	DDC4	= 4	; Port C Data Direction Register bit 4
                                 .equ	DDC5	= 5	; Port C Data Direction Register bit 5
                                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                                 .equ	DDC7	= 7	; Port C Data Direction Register bit 7
                                 
                                 ; PINC - Port C Input Pins
                                 .equ	PINC0	= 0	; Port C Input Pins bit 0
                                 .equ	PINC1	= 1	; Port C Input Pins bit 1
                                 .equ	PINC2	= 2	; Port C Input Pins bit 2
                                 .equ	PINC3	= 3	; Port C Input Pins bit 3
                                 .equ	PINC4	= 4	; Port C Input Pins bit 4
                                 .equ	PINC5	= 5	; Port C Input Pins bit 5
                                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                                 .equ	PINC7	= 7	; Port C Input Pins bit 7
                                 
                                 
                                 ; ***** PORTD ************************
                                 ; PORTD - Port D Data Register
                                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                                 .equ	PD0	= 0	; For compatibility
                                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                                 .equ	PD1	= 1	; For compatibility
                                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                                 .equ	PD2	= 2	; For compatibility
                                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                                 .equ	PD3	= 3	; For compatibility
                                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                                 .equ	PD4	= 4	; For compatibility
                                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                                 .equ	PD5	= 5	; For compatibility
                                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                                 .equ	PD6	= 6	; For compatibility
                                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                                 .equ	PD7	= 7	; For compatibility
                                 
                                 ; DDRD - Port D Data Direction Register
                                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                                 
                                 ; PIND - Port D Input Pins
                                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                                 
                                 
                                 ; ***** PORTE ************************
                                 ; PORTE - Data Register, Port E
                                 .equ	PORTE0	= 0	; 
                                 .equ	PE0	= 0	; For compatibility
                                 .equ	PORTE1	= 1	; 
                                 .equ	PE1	= 1	; For compatibility
                                 .equ	PORTE2	= 2	; 
                                 .equ	PE2	= 2	; For compatibility
                                 .equ	PORTE3	= 3	; 
                                 .equ	PE3	= 3	; For compatibility
                                 .equ	PORTE4	= 4	; 
                                 .equ	PE4	= 4	; For compatibility
                                 .equ	PORTE5	= 5	; 
                                 .equ	PE5	= 5	; For compatibility
                                 .equ	PORTE6	= 6	; 
                                 .equ	PE6	= 6	; For compatibility
                                 .equ	PORTE7	= 7	; 
                                 .equ	PE7	= 7	; For compatibility
                                 
                                 ; DDRE - Data Direction Register, Port E
                                 .equ	DDE0	= 0	; 
                                 .equ	DDE1	= 1	; 
                                 .equ	DDE2	= 2	; 
                                 .equ	DDE3	= 3	; 
                                 .equ	DDE4	= 4	; 
                                 .equ	DDE5	= 5	; 
                                 .equ	DDE6	= 6	; 
                                 .equ	DDE7	= 7	; 
                                 
                                 ; PINE - Input Pins, Port E
                                 .equ	PINE0	= 0	; 
                                 .equ	PINE1	= 1	; 
                                 .equ	PINE2	= 2	; 
                                 .equ	PINE3	= 3	; 
                                 .equ	PINE4	= 4	; 
                                 .equ	PINE5	= 5	; 
                                 .equ	PINE6	= 6	; 
                                 .equ	PINE7	= 7	; 
                                 
                                 
                                 ; ***** PORTF ************************
                                 ; PORTF - Data Register, Port F
                                 .equ	PORTF0	= 0	; 
                                 .equ	PF0	= 0	; For compatibility
                                 .equ	PORTF1	= 1	; 
                                 .equ	PF1	= 1	; For compatibility
                                 .equ	PORTF2	= 2	; 
                                 .equ	PF2	= 2	; For compatibility
                                 .equ	PORTF3	= 3	; 
                                 .equ	PF3	= 3	; For compatibility
                                 .equ	PORTF4	= 4	; 
                                 .equ	PF4	= 4	; For compatibility
                                 .equ	PORTF5	= 5	; 
                                 .equ	PF5	= 5	; For compatibility
                                 .equ	PORTF6	= 6	; 
                                 .equ	PF6	= 6	; For compatibility
                                 .equ	PORTF7	= 7	; 
                                 .equ	PF7	= 7	; For compatibility
                                 
                                 ; DDRF - Data Direction Register, Port F
                                 .equ	DDF0	= 0	; 
                                 .equ	DDF1	= 1	; 
                                 .equ	DDF2	= 2	; 
                                 .equ	DDF3	= 3	; 
                                 .equ	DDF4	= 4	; 
                                 .equ	DDF5	= 5	; 
                                 .equ	DDF6	= 6	; 
                                 .equ	DDF7	= 7	; 
                                 
                                 ; PINF - Input Pins, Port F
                                 .equ	PINF0	= 0	; 
                                 .equ	PINF1	= 1	; 
                                 .equ	PINF2	= 2	; 
                                 .equ	PINF3	= 3	; 
                                 .equ	PINF4	= 4	; 
                                 .equ	PINF5	= 5	; 
                                 .equ	PINF6	= 6	; 
                                 .equ	PINF7	= 7	; 
                                 
                                 
                                 ; ***** PORTG ************************
                                 ; PORTG - Data Register, Port G
                                 .equ	PORTG0	= 0	; 
                                 .equ	PG0	= 0	; For compatibility
                                 .equ	PORTG1	= 1	; 
                                 .equ	PG1	= 1	; For compatibility
                                 .equ	PORTG2	= 2	; 
                                 .equ	PG2	= 2	; For compatibility
                                 .equ	PORTG3	= 3	; 
                                 .equ	PG3	= 3	; For compatibility
                                 .equ	PORTG4	= 4	; 
                                 .equ	PG4	= 4	; For compatibility
                                 
                                 ; DDRG - Data Direction Register, Port G
                                 .equ	DDG0	= 0	; 
                                 .equ	DDG1	= 1	; 
                                 .equ	DDG2	= 2	; 
                                 .equ	DDG3	= 3	; 
                                 .equ	DDG4	= 4	; 
                                 
                                 ; PING - Input Pins, Port G
                                 .equ	PING0	= 0	; 
                                 .equ	PING1	= 1	; 
                                 .equ	PING2	= 2	; 
                                 .equ	PING3	= 3	; 
                                 .equ	PING4	= 4	; 
                                 
                                 
                                 ; ***** TIMER_COUNTER_0 **************
                                 ; TCCR0 - Timer/Counter Control Register
                                 .equ	CS00	= 0	; Clock Select 0
                                 .equ	CS01	= 1	; Clock Select 1
                                 .equ	CS02	= 2	; Clock Select 2
                                 .equ	WGM01	= 3	; Waveform Generation Mode 1
                                 .equ	CTC0	= WGM01	; For compatibility
                                 .equ	COM00	= 4	; Compare match Output Mode 0
                                 .equ	COM01	= 5	; Compare Match Output Mode 1
                                 .equ	WGM00	= 6	; Waveform Generation Mode 0
                                 .equ	PWM0	= WGM00	; For compatibility
                                 .equ	FOC0	= 7	; Force Output Compare
                                 
                                 ; TCNT0 - Timer/Counter Register
                                 .equ	TCNT0_0	= 0	; 
                                 .equ	TCNT0_1	= 1	; 
                                 .equ	TCNT0_2	= 2	; 
                                 .equ	TCNT0_3	= 3	; 
                                 .equ	TCNT0_4	= 4	; 
                                 .equ	TCNT0_5	= 5	; 
                                 .equ	TCNT0_6	= 6	; 
                                 .equ	TCNT0_7	= 7	; 
                                 
                                 ; OCR0 - Output Compare Register
                                 .equ	OCR0_0	= 0	; 
                                 .equ	OCR0_1	= 1	; 
                                 .equ	OCR0_2	= 2	; 
                                 .equ	OCR0_3	= 3	; 
                                 .equ	OCR0_4	= 4	; 
                                 .equ	OCR0_5	= 5	; 
                                 .equ	OCR0_6	= 6	; 
                                 .equ	OCR0_7	= 7	; 
                                 
                                 ; ASSR - Asynchronus Status Register
                                 .equ	TCR0UB	= 0	; Timer/Counter Control Register 0 Update Busy
                                 .equ	OCR0UB	= 1	; Output Compare register 0 Busy
                                 .equ	TCN0UB	= 2	; Timer/Counter0 Update Busy
                                 .equ	AS0	= 3	; Asynchronus Timer/Counter 0
                                 
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
                                 .equ	OCIE0	= 1	; Timer/Counter0 Output Compare Match Interrupt register
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag register
                                 .equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
                                 .equ	OCF0	= 1	; Output Compare Flag 0
                                 
                                 ; SFIOR - Special Function IO Register
                                 ;.equ	PSR0	= 1	; Prescaler Reset Timer/Counter0
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** TIMER_COUNTER_1 **************
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	TOIE1	= 2	; Timer/Counter1 Overflow Interrupt Enable
                                 .equ	OCIE1B	= 3	; Timer/Counter1 Output CompareB Match Interrupt Enable
                                 .equ	OCIE1A	= 4	; Timer/Counter1 Output CompareA Match Interrupt Enable
                                 .equ	TICIE1	= 5	; Timer/Counter1 Input Capture Interrupt Enable
                                 
                                 ; ETIMSK - Extended Timer/Counter Interrupt Mask Register
                                 .equ	OCIE1C	= 0	; Timer/Counter 1, Output Compare Match C Interrupt Enable
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag register
                                 .equ	TOV1	= 2	; Timer/Counter1 Overflow Flag
                                 .equ	OCF1B	= 3	; Output Compare Flag 1B
                                 .equ	OCF1A	= 4	; Output Compare Flag 1A
                                 .equ	ICF1	= 5	; Input Capture Flag 1
                                 
                                 ; ETIFR - Extended Timer/Counter Interrupt Flag register
                                 .equ	OCF1C	= 0	; Timer/Counter 1, Output Compare C Match Flag
                                 
                                 ; SFIOR - Special Function IO Register
                                 ;.equ	PSR321	= 0	; Prescaler Reset, T/C3, T/C2, T/C1
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 ; TCCR1A - Timer/Counter1 Control Register A
                                 .equ	WGM10	= 0	; Waveform Generation Mode Bit 0
                                 .equ	PWM10	= WGM10	; For compatibility
                                 .equ	WGM11	= 1	; Waveform Generation Mode Bit 1
                                 .equ	PWM11	= WGM11	; For compatibility
                                 .equ	COM1C0	= 2	; Compare Output Mode 1C, bit 0
                                 .equ	COM1C1	= 3	; Compare Output Mode 1C, bit 1
                                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                                 .equ	COM1A0	= 6	; Compare Ouput Mode 1A, bit 0
                                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 ; TCCR1B - Timer/Counter1 Control Register B
                                 .equ	CS10	= 0	; Clock Select bit 0
                                 .equ	CS11	= 1	; Clock Select 1 bit 1
                                 .equ	CS12	= 2	; Clock Select1 bit 2
                                 .equ	WGM12	= 3	; Waveform Generation Mode
                                 .equ	CTC10	= WGM12	; For compatibility
                                 .equ	WGM13	= 4	; Waveform Generation Mode
                                 .equ	CTC11	= WGM13	; For compatibility
                                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                                 
                                 ; TCCR1C - Timer/Counter1 Control Register C
                                 .equ	FOC1C	= 5	; Force Output Compare for channel C
                                 .equ	FOC1B	= 6	; Force Output Compare for channel B
                                 .equ	FOC1A	= 7	; Force Output Compare for channel A
                                 
                                 
                                 ; ***** TIMER_COUNTER_2 **************
                                 ; TCCR2 - Timer/Counter Control Register
                                 .equ	CS20	= 0	; Clock Select
                                 .equ	CS21	= 1	; Clock Select
                                 .equ	CS22	= 2	; Clock Select
                                 .equ	WGM21	= 3	; Waveform Generation Mode
                                 .equ	CTC2	= WGM21	; For compatibility
                                 .equ	COM20	= 4	; Compare Match Output Mode
                                 .equ	COM21	= 5	; Compare Match Output Mode
                                 .equ	WGM20	= 6	; Wafeform Generation Mode
                                 .equ	PWM2	= WGM20	; For compatibility
                                 .equ	FOC2	= 7	; Force Output Compare
                                 
                                 ; TCNT2 - Timer/Counter Register
                                 .equ	TCNT2_0	= 0	; Timer/Counter Register Bit 0
                                 .equ	TCNT2_1	= 1	; Timer/Counter Register Bit 1
                                 .equ	TCNT2_2	= 2	; Timer/Counter Register Bit 2
                                 .equ	TCNT2_3	= 3	; Timer/Counter Register Bit 3
                                 .equ	TCNT2_4	= 4	; Timer/Counter Register Bit 4
                                 .equ	TCNT2_5	= 5	; Timer/Counter Register Bit 5
                                 .equ	TCNT2_6	= 6	; Timer/Counter Register Bit 6
                                 .equ	TCNT2_7	= 7	; Timer/Counter Register Bit 7
                                 
                                 ; OCR2 - Output Compare Register
                                 .equ	OCR2_0	= 0	; Output Compare Register Bit 0
                                 .equ	OCR2_1	= 1	; Output Compare Register Bit 1
                                 .equ	OCR2_2	= 2	; Output Compare Register Bit 2
                                 .equ	OCR2_3	= 3	; Output Compare Register Bit 3
                                 .equ	OCR2_4	= 4	; Output Compare Register Bit 4
                                 .equ	OCR2_5	= 5	; Output Compare Register Bit 5
                                 .equ	OCR2_6	= 6	; Output Compare Register Bit 6
                                 .equ	OCR2_7	= 7	; Output Compare Register Bit 7
                                 
                                 ; TIMSK - 
                                 .equ	TOIE2	= 6	; 
                                 .equ	OCIE2	= 7	; 
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag Register
                                 .equ	TOV2	= 6	; Timer/Counter2 Overflow Flag
                                 .equ	OCF2	= 7	; Output Compare Flag 2
                                 
                                 
                                 ; ***** TIMER_COUNTER_3 **************
                                 ; ETIMSK - Extended Timer/Counter Interrupt Mask Register
                                 .equ	OCIE3C	= 1	; Timer/Counter3, Output Compare Match Interrupt Enable
                                 .equ	TOIE3	= 2	; Timer/Counter3 Overflow Interrupt Enable
                                 .equ	OCIE3B	= 3	; Timer/Counter3 Output CompareB Match Interrupt Enable
                                 .equ	OCIE3A	= 4	; Timer/Counter3 Output CompareA Match Interrupt Enable
                                 .equ	TICIE3	= 5	; Timer/Counter3 Input Capture Interrupt Enable
                                 
                                 ; ETIFR - Extended Timer/Counter Interrupt Flag register
                                 .equ	OCF3C	= 1	; Timer/Counter3 Output Compare C Match Flag
                                 .equ	TOV3	= 2	; Timer/Counter3 Overflow Flag
                                 .equ	OCF3B	= 3	; Output Compare Flag 1B
                                 .equ	OCF3A	= 4	; Output Compare Flag 1A
                                 .equ	ICF3	= 5	; Input Capture Flag 1
                                 
                                 ; SFIOR - Special Function IO Register
                                 ;.equ	PSR321	= 0	; Prescaler Reset, T/C3, T/C2, T/C1
                                 ;.equ	PSR1	= PSR321	; For compatibility
                                 ;.equ	PSR2	= PSR321	; For compatibility
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 ; TCCR3A - Timer/Counter3 Control Register A
                                 .equ	WGM30	= 0	; Waveform Generation Mode Bit 0
                                 .equ	PWM30	= WGM30	; For compatibility
                                 .equ	WGM31	= 1	; Waveform Generation Mode Bit 1
                                 .equ	PWM31	= WGM31	; For compatibility
                                 .equ	COM3C0	= 2	; Compare Output Mode 3C, bit 0
                                 .equ	COM3C1	= 3	; Compare Output Mode 3C, bit 1
                                 .equ	COM3B0	= 4	; Compare Output Mode 3B, bit 0
                                 .equ	COM3B1	= 5	; Compare Output Mode 3B, bit 1
                                 .equ	COM3A0	= 6	; Comparet Ouput Mode 3A, bit 0
                                 .equ	COM3A1	= 7	; Compare Output Mode 3A, bit 1
                                 
                                 ; TCCR3B - Timer/Counter3 Control Register B
                                 .equ	CS30	= 0	; Clock Select 3 bit 0
                                 .equ	CS31	= 1	; Clock Select 3 bit 1
                                 .equ	CS32	= 2	; Clock Select3 bit 2
                                 .equ	WGM32	= 3	; Waveform Generation Mode
                                 .equ	CTC30	= WGM32	; For compatibility
                                 .equ	WGM33	= 4	; Waveform Generation Mode
                                 .equ	CTC31	= WGM33	; For compatibility
                                 .equ	ICES3	= 6	; Input Capture 3 Edge Select
                                 .equ	ICNC3	= 7	; Input Capture 3  Noise Canceler
                                 
                                 ; TCCR3C - Timer/Counter3 Control Register C
                                 .equ	FOC3C	= 5	; Force Output Compare for channel C
                                 .equ	FOC3B	= 6	; Force Output Compare for channel B
                                 .equ	FOC3A	= 7	; Force Output Compare for channel A
                                 
                                 ; TCNT3L - Timer/Counter3 Low Byte
                                 .equ	TCN3L0	= 0	; Timer/Counter 3 bit 0
                                 .equ	TCN3L1	= 1	; Timer/Counter 3 bit 1
                                 .equ	TCN3L2	= 2	; Timer/Counter 3 bit 2
                                 .equ	TCN3L3	= 3	; Timer/Counter 3 bit 3
                                 .equ	TCN3L4	= 4	; Timer/Counter 3 bit 4
                                 .equ	TCN3L5	= 5	; Timer/Counter 3 bit 5
                                 .equ	TCN3L6	= 6	; Timer/Counter 3 bit 6
                                 .equ	TCN3L7	= 7	; Timer/Counter 3 bit 7
                                 
                                 
                                 ; ***** WATCHDOG *********************
                                 ; WDTCR - Watchdog Timer Control Register
                                 .equ	WDTCSR	= WDTCR	; For compatibility
                                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                                 .equ	WDE	= 3	; Watch Dog Enable
                                 .equ	WDCE	= 4	; Watchdog Change Enable
                                 .equ	WDTOE	= WDCE	; For compatibility
                                 
                                 
                                 ; ***** AD_CONVERTER *****************
                                 ; ADMUX - The ADC multiplexer Selection Register
                                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                                 .equ	MUX4	= 4	; Analog Channel and Gain Selection Bits
                                 .equ	ADLAR	= 5	; Left Adjust Result
                                 .equ	REFS0	= 6	; Reference Selection Bit 0
                                 .equ	REFS1	= 7	; Reference Selection Bit 1
                                 
                                 ; ADCSRA - The ADC Control and Status register
                                 .equ	ADCSR	= ADCSRA	; For compatibility
                                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                                 .equ	ADIE	= 3	; ADC Interrupt Enable
                                 .equ	ADIF	= 4	; ADC Interrupt Flag
                                 .equ	ADFR	= 5	; ADC  Free Running Select
                                 .equ	ADSC	= 6	; ADC Start Conversion
                                 .equ	ADEN	= 7	; ADC Enable
                                 
                                 ; ADCH - ADC Data Register High Byte
                                 .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                                 .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                                 .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                                 .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                                 .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                                 .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                                 .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                                 .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                                 
                                 ; ADCL - ADC Data Register Low Byte
                                 .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                                 .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                                 .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                                 .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                                 .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                                 .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                                 .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                                 .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                                 
                                 
                                 
                                 ; ***** LOCKSBITS ********************************************************
                                 .equ	LB1	= 0	; Lock bit
                                 .equ	LB2	= 1	; Lock bit
                                 .equ	BLB01	= 2	; Boot Lock bit
                                 .equ	BLB02	= 3	; Boot Lock bit
                                 .equ	BLB11	= 4	; Boot lock bit
                                 .equ	BLB12	= 5	; Boot lock bit
                                 
                                 
                                 ; ***** FUSES ************************************************************
                                 ; LOW fuse bits
                                 .equ	CKSEL0	= 0	; Select Clock Source
                                 .equ	CKSEL1	= 1	; Select Clock Source
                                 .equ	CKSEL2	= 2	; Select Clock Source
                                 .equ	CKSEL3	= 3	; Select Clock Source
                                 .equ	SUT0	= 4	; Select start-up time
                                 .equ	SUT1	= 5	; Select start-up time
                                 .equ	BODEN	= 6	; Brown out detector enable
                                 .equ	BODLEVEL	= 7	; Brown out detector trigger level
                                 
                                 ; HIGH fuse bits
                                 .equ	BOOTRST	= 0	; Select Reset Vector
                                 .equ	BOOTSZ0	= 1	; Select Boot Size
                                 .equ	BOOTSZ1	= 2	; Select Boot Size
                                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                                 .equ	CKOPT	= 4	; Oscillator Options
                                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                                 .equ	JTAGEN	= 6	; Enable JTAG
                                 .equ	OCDEN	= 7	; Enable OCD
                                 
                                 ; EXTENDED fuse bits
                                 .equ	WDTON	= 0	; Watchdog timer always on
                                 .equ	M103C	= 1	; ATmega103 compatibility mode
                                 
                                 
                                 
                                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                                 .def	XH	= r27
                                 .def	XL	= r26
                                 .def	YH	= r29
                                 .def	YL	= r28
                                 .def	ZH	= r31
                                 .def	ZL	= r30
                                 
                                 
                                 
                                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                                 .equ	FLASHEND	= 0xffff	; Note: Word address
                                 .equ	IOEND	= 0x00ff
                                 .equ	SRAM_START	= 0x0100
                                 .equ	SRAM_SIZE	= 4096
                                 .equ	RAMEND	= 0x10ff
                                 .equ	XRAMEND	= 0xffff
                                 .equ	E2END	= 0x0fff
                                 .equ	EEPROMEND	= 0x0fff
                                 .equ	EEADRBITS	= 12
                                 #pragma AVRPART MEMORY PROG_FLASH 131072
                                 #pragma AVRPART MEMORY EEPROM 4096
                                 #pragma AVRPART MEMORY INT_SRAM SIZE 4096
                                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x100
                                 
                                 
                                 
                                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                                 .equ	NRWW_START_ADDR	= 0xf000
                                 .equ	NRWW_STOP_ADDR	= 0xffff
                                 .equ	RWW_START_ADDR	= 0x0
                                 .equ	RWW_STOP_ADDR	= 0xefff
                                 .equ	PAGESIZE	= 128
                                 .equ	FIRSTBOOTSTART	= 0xfe00
                                 .equ	SECONDBOOTSTART	= 0xfc00
                                 .equ	THIRDBOOTSTART	= 0xf800
                                 .equ	FOURTHBOOTSTART	= 0xf000
                                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                                 
                                 
                                 
                                 ; ***** INTERRUPT VECTORS ************************************************
                                 .equ	INT0addr	= 0x0002	; External Interrupt Request 0
                                 .equ	INT1addr	= 0x0004	; External Interrupt Request 1
                                 .equ	INT2addr	= 0x0006	; External Interrupt Request 2
                                 .equ	INT3addr	= 0x0008	; External Interrupt Request 3
                                 .equ	INT4addr	= 0x000a	; External Interrupt Request 4
                                 .equ	INT5addr	= 0x000c	; External Interrupt Request 5
                                 .equ	INT6addr	= 0x000e	; External Interrupt Request 6
                                 .equ	INT7addr	= 0x0010	; External Interrupt Request 7
                                 .equ	OC2addr	= 0x0012	; Timer/Counter2 Compare Match
                                 .equ	OVF2addr	= 0x0014	; Timer/Counter2 Overflow
                                 .equ	ICP1addr	= 0x0016	; Timer/Counter1 Capture Event
                                 .equ	OC1Aaddr	= 0x0018	; Timer/Counter1 Compare Match A
                                 .equ	OC1Baddr	= 0x001a	; Timer/Counter Compare Match B
                                 .equ	OVF1addr	= 0x001c	; Timer/Counter1 Overflow
                                 .equ	OC0addr	= 0x001e	; Timer/Counter0 Compare Match
                                 .equ	OVF0addr	= 0x0020	; Timer/Counter0 Overflow
                                 .equ	SPIaddr	= 0x0022	; SPI Serial Transfer Complete
                                 .equ	URXC0addr	= 0x0024	; USART0, Rx Complete
                                 .equ	UDRE0addr	= 0x0026	; USART0 Data Register Empty
                                 .equ	UTXC0addr	= 0x0028	; USART0, Tx Complete
                                 .equ	ADCCaddr	= 0x002a	; ADC Conversion Complete
                                 .equ	ERDYaddr	= 0x002c	; EEPROM Ready
                                 .equ	ACIaddr	= 0x002e	; Analog Comparator
                                 .equ	OC1Caddr	= 0x0030	; Timer/Counter1 Compare Match C
                                 .equ	ICP3addr	= 0x0032	; Timer/Counter3 Capture Event
                                 .equ	OC3Aaddr	= 0x0034	; Timer/Counter3 Compare Match A
                                 .equ	OC3Baddr	= 0x0036	; Timer/Counter3 Compare Match B
                                 .equ	OC3Caddr	= 0x0038	; Timer/Counter3 Compare Match C
                                 .equ	OVF3addr	= 0x003a	; Timer/Counter3 Overflow
                                 .equ	URXC1addr	= 0x003c	; USART1, Rx Complete
                                 .equ	UDRE1addr	= 0x003e	; USART1, Data Register Empty
                                 .equ	UTXC1addr	= 0x0040	; USART1, Tx Complete
                                 .equ	TWIaddr	= 0x0042	; 2-wire Serial Interface
                                 .equ	SPMRaddr	= 0x0044	; Store Program Memory Read
                                 
                                 .equ	INT_VECTORS_SIZE	= 70	; size in words
                                 
                                 #endif  /* _M128DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 ; purpose runs the main loop of the program, calling each parts
                                 
                                 ; ==== Include Libraries ==== 
                                 
                                 .include	"Libraries\macros.asm"		; include macro definitions
                                 
                                 ; purpose library, general-purpose macros
                                 ; author (c) R.Holzer (adapted MICRO210/EE208 A.Schmid)
                                 ; v2019.01 20180820 AxS
                                 
                                 ; ==============
                                 ; 	pointers
                                 ; ==============
                                 
                                 ; --- loading an immediate into a pointer XYZ,SP ---
                                 .macro 	LDIX	; sram
                                 	ldi	xl, low(@0)
                                 	ldi	xh,high(@0)
                                 	.endmacro	
                                 .macro 	LDIY	; sram	
                                 	ldi	yl, low(@0)
                                 	ldi	yh,high(@0)
                                 	.endmacro	
                                 .macro 	LDIZ	; sram
                                 	ldi	zl, low(@0)
                                 	ldi	zh,high(@0)
                                 	
                                 	.endmacro
                                 .macro	LDZD	; sram, reg	; sram+reg -> Z
                                 	mov	zl,@1
                                 	clr	zh
                                 	subi	zl, low(-@0)
                                 	sbci	zh,high(-@0)
                                 	.endmacro
                                 .macro	LDSP	; sram
                                 	ldi	r16, low(@0)
                                 	out	spl,r16
                                 	ldi	r16,high(@0)
                                 	out	sph,r16
                                 	.endmacro
                                 
                                 ; --- load/store SRAM addr into pointer XYZ ---	
                                 .macro 	LDSX	; sram
                                 	lds	xl,@0
                                 	lds	xh,@0+1
                                 	.endmacro
                                 .macro 	LDSY	; sram
                                 	lds	yl,@0
                                 	lds	yh,@0+1
                                 	.endmacro
                                 .macro 	LDSZ	; sram
                                 	lds	zl,@0
                                 	lds	zh,@0+1
                                 	.endmacro
                                 .macro 	STSX	; sram
                                 	sts	@0,  xl
                                 	sts	@0+1,xh
                                 	.endmacro	
                                 .macro 	STSY	; sram
                                 	sts	@0,  yl
                                 	sts	@0+1,yh
                                 	.endmacro
                                 .macro 	STSZ	; sram
                                 	sts	@0,  zl
                                 	sts	@0+1,zh
                                 	.endmacro	
                                 
                                 ; --- push/pop pointer XYZ ---
                                 .macro	PUSHX			; push X
                                 	push	xl
                                 	push	xh
                                 	.endmacro
                                 .macro	POPX			; pop X
                                 	pop	xh
                                 	pop	xl
                                 	.endmacro
                                 	
                                 .macro	PUSHY			; push Y
                                 	push	yl
                                 	push	yh
                                 	.endmacro
                                 .macro	POPY			; pop Y
                                 	pop	yh
                                 	pop	yl
                                 	.endmacro
                                 
                                 .macro	PUSHZ			; push Z
                                 	push	zl
                                 	push	zh
                                 	.endmacro
                                 .macro	POPZ			; pop Z
                                 	pop	zh
                                 	pop	zl
                                 	.endmacro
                                 
                                 ; --- multiply/divide Z ---	
                                 .macro	MUL2Z			; multiply Z by 2
                                 	lsl	zl
                                 	rol	zh
                                 	.endmacro
                                 .macro	DIV2Z			; divide Z by 2
                                 	lsr	zh
                                 	ror	zl
                                 	.endmacro
                                 
                                 ; --- add register to pointer XYZ ---	
                                 .macro	ADDX	;reg		; x <- y+reg
                                 	add	xl,@0
                                 	brcc	PC+2
                                 	subi	xh,-1		; add carry
                                 	.endmacro
                                 .macro	ADDY	;reg		; y <- y+reg
                                 	add	yl,@0
                                 	brcc	PC+2
                                 	subi	yh,-1		; add carry
                                 	.endmacro
                                 .macro	ADDZ	;reg		; z <- z+reg
                                 	add	zl,@0
                                 	brcc	PC+2
                                 	subi	zh,-1		; add carry
                                 	.endmacro
                                 
                                 ; ===================
                                 ; 	miscellaneous
                                 ; ===================
                                 
                                 ; --- output/store (regular I/O space) immediate value ---
                                 .macro	OUTI	; port,k	output immediate value to port
                                 	ldi	w,@1
                                 	out	@0,w
                                 	.endmacro
                                 
                                 ; --- output/store (extended I/O space) immediate value ---
                                 .macro OUTEI	; port,k    output immediate value to port
                                 	ldi	w,@1
                                 	sts	@0,w
                                 	.endmacro
                                 
                                 ; --- add immediate value ---
                                 .macro	ADDI
                                 	subi	@0,-@1
                                 	.endmacro
                                 .macro	ADCI
                                 	sbci	@0,-@1
                                 	.endmacro
                                 
                                 ; --- inc/dec with range limitation ---
                                 .macro	INC_LIM	; reg,limit
                                 	cpi	@0,@1
                                 	brlo	PC+3
                                 	ldi	@0,@1	
                                 	rjmp	PC+2
                                 	inc	@0
                                 	.endmacro
                                 
                                 .macro	DEC_LIM	; reg,limit
                                 	cpi	@0,@1
                                 	breq	PC+5
                                 	brlo	PC+3
                                 	dec	@0
                                 	rjmp	PC+2
                                 	ldi	@0,@1
                                 	.endmacro
                                 
                                 ; --- inc/dec with cyclic range ---
                                 .macro	INC_CYC	; reg,low,high
                                 	cpi	@0,@2
                                 	brsh	_low	; reg>=high then reg=low
                                 	cpi	@0,@1
                                 	brlo	_low	; reg< low  then reg=low
                                 	inc	@0
                                 	rjmp	_done
                                 _low:	ldi	@0,@1
                                 _done:	
                                     .endmacro
                                 	
                                 .macro	DEC_CYC	; reg,low,high
                                 	cpi	@0,@1
                                 	breq	_high	; reg=low then reg=high
                                 	brlo	_high	; reg<low then reg=high
                                 	dec	@0	
                                 	cpi	@0,@2
                                 	brsh	_high	; reg>=high then high
                                 	rjmp	_done
                                 _high:	ldi	@0,@2
                                 _done:	
                                 	.endmacro
                                 
                                 .macro	INCDEC	;port,b1,b2,reg,low,high
                                 	sbic	@0,@1
                                 	rjmp	PC+6
                                 
                                 	cpi	@3,@5
                                 	brlo	PC+3
                                 	ldi	@3,@4	
                                 	rjmp	PC+2
                                 	inc	@3
                                 
                                 	sbic	@0,@2
                                 	rjmp	PC+7
                                 	
                                 	cpi	@3,@4
                                 	breq	PC+5
                                 	brlo	PC+3
                                 	dec	@3
                                 	rjmp	PC+2
                                 	ldi	@3,@5
                                 	.endmacro		
                                 
                                 ; --- wait loops ---
                                 ; wait 10...196608 cycles
                                 .macro	WAIT_C	; k
                                 	ldi	w,  low((@0-7)/3)
                                 	mov	u,w			; u=LSB
                                 	ldi	w,high((@0-7)/3)+1	; w=MSB
                                 	dec	u
                                 	brne	PC-1
                                 	dec	u
                                 	dec	w
                                 	brne	PC-4
                                 	.endmacro
                                 
                                 ; wait micro-seconds (us)
                                 ; us = x*3*1000'000/clock)	==> x=us*clock/3000'000
                                 .macro	WAIT_US ; k
                                 	ldi	w, low((clock/1000*@0/3000)-1)
                                 	mov	u,w
                                 	ldi	w,high((clock/1000*@0/3000)-1)+1 ; set up: 3 cyles
                                 	dec	u
                                 	brne	PC-1		; inner loop: 3 cycles
                                 	dec	u		; adjustment for outer loop
                                 	dec	w
                                 	brne	PC-4
                                 	.endmacro
                                 
                                 ; wait mili-seconds (ms)
                                 .macro	WAIT_MS ; k
                                 	ldi	w, low(@0)
                                 	mov	u,w		; u = LSB	
                                 	ldi	w,high(@0)+1	; w = MSB
                                 wait_ms:
                                 	push	w		; wait 1000 usec
                                 	push	u
                                 	ldi	w, low((clock/3000)-5)	
                                 	mov	u,w
                                 	ldi	w,high((clock/3000)-5)+1
                                 	dec	u
                                 	brne	PC-1		; inner loop: 3 cycles
                                 	dec	u		; adjustment for outer loop
                                 	dec	w
                                 	brne	PC-4
                                 	pop	u
                                 	pop	w
                                 	
                                 	dec	u
                                 	brne	wait_ms
                                 	dec	w
                                 	brne	wait_ms
                                 	.endmacro
                                 
                                 ; --- conditional jumps/calls ---
                                 .macro	JC0			; jump if carry=0
                                 	brcs	PC+2	
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	JC1			; jump if carry=1
                                 	brcc	PC+2	
                                 	rjmp	@0
                                 	.endmacro
                                 
                                 .macro	JK	; reg,k,addr	; jump if reg=k
                                 	cpi	@0,@1
                                 	breq	@2
                                 	.endmacro
                                 .macro	_JK	; reg,k,addr	; jump if reg=k
                                 	cpi	@0,@1
                                 	brne	PC+2
                                 	rjmp	@2
                                 	.endmacro	
                                 .macro	JNK	; reg,k,addr	; jump if not(reg=k)
                                 	cpi	@0,@1
                                 	brne	@2
                                 	.endmacro 
                                 
                                 .macro	CK	; reg,k,addr	; call if reg=k
                                 	cpi	@0,@1
                                 	brne	PC+2
                                 	rcall	@2
                                 	.endmacro
                                 .macro	CNK	; reg,k,addr	; call if not(reg=k)
                                 	cpi	@0,@1
                                 	breq	PC+2
                                 	rcall	@2
                                 	.endmacro 
                                 
                                 .macro	JSK	; sram,k,addr	; jump if sram=k
                                 	lds	w,@0
                                 	cpi	w,@1
                                 	breq	@2
                                 	.endmacro 
                                 .macro	JSNK	; sram,k,addr	; jump if not(sram=k)
                                 	lds	w,@0
                                 	cpi	w,@1
                                 	brne	@2
                                 	.endmacro
                                 
                                 ; --- loops ---
                                 .macro	DJNZ	; reg,addr	; decr and jump if not zero
                                 	dec	@0
                                 	brne	@1
                                 	.endmacro
                                 .macro	DJNK	; reg,k,addr	; decr and jump if not k
                                 	dec	@0
                                 	cpi	@0,@1
                                 	brne	@2
                                 	.endmacro
                                 
                                 .macro	IJNZ	; reg,addr	; inc and jump if not zero
                                 	inc	@0
                                 	brne	@1
                                 	.endmacro
                                 .macro	IJNK	; reg,k,addr	; inc and jump if not k
                                 	inc	@0
                                 	cpi	@0,@1
                                 	brne	@2
                                 	.endmacro
                                 .macro	_IJNK	; reg,k,addr	; inc and jump if not k
                                 	inc	@0
                                 	ldi	w,@1
                                 	cp	@0,w
                                 	brne	@2
                                 	.endmacro
                                 
                                 .macro	ISJNK	; sram,k,addr	; inc sram and jump if not k
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	cpi	w,@1
                                 	brne	@2
                                 	.endmacro
                                 .macro	_ISJNK	; sram,k,addr	; inc sram and jump if not k
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	cpi	w,@1
                                 	breq	PC+2	
                                 	rjmp	@2
                                 	.endmacro
                                 
                                 .macro	DSJNK	; sram,k,addr	; dec sram and jump if not k
                                 	lds	w,@0
                                 	dec	w
                                 	sts	@0,w
                                 	cpi	w,@1
                                 	brne	@2
                                 	.endmacro
                                 
                                 ; --- table lookup ---
                                 .macro	LOOKUP	;reg, index,tbl
                                 	push	ZL
                                 	push	ZH
                                 	mov	zl,@1		; move index into z
                                 	clr	zh
                                 	subi	zl, low(-2*@2)	; add base address of table
                                 	sbci	zh,high(-2*@2)	
                                 	lpm			; load program memory (into r0)
                                 	mov	@0,r0
                                 	pop	ZH
                                 	pop	ZL
                                 	.endmacro
                                 
                                 .macro	LOOKUP2	;r1,r0, index,tbl
                                 	mov	zl,@2		; move index into z
                                 	clr	zh
                                 	lsl	zl		; multiply by 2
                                 	rol	zh
                                 	subi	zl, low(-2*@3)	; add base address of table
                                 	sbci	zh,high(-2*@3)
                                 	lpm			; get LSB byte
                                 	mov	w,r0		; temporary store LSB in w
                                 	adiw	zl,1		; increment Z
                                 	lpm			; get MSB byte
                                 	mov	@0,r0		; mov MSB to res1
                                 	mov	@1,w		; mov LSB to res0
                                 	.endmacro
                                 
                                 .macro	LOOKUP4	;r3,r2,r1,r0, index,tbl
                                 	mov	zl,@4		; move index into z
                                 	clr	zh
                                 	lsl	zl		; multiply by 2
                                 	rol	zh
                                 	lsl	zl		; multiply by 2
                                 	rol	zh	
                                 	subi	zl, low(-2*@5)	; add base address of table
                                 	sbci	zh,high(-2*@5)
                                 	lpm
                                 	mov	@1,r0		; load high word LSB
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@0,r0		; load high word MSB
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@3,r0		; load low word LSB		
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@2,r0		; load low word MSB
                                 	.endmacro
                                 
                                 .macro	LOOKDOWN ;reg,index,tbl
                                 	ldi	ZL, low(2*@2)	; load table address
                                 	ldi	ZH,high(2*@2)
                                 	clr	@1
                                 loop:	lpm
                                 	cp	r0,@0
                                 	breq	found
                                 	inc	@1
                                 	adiw	ZL,1
                                 	tst	r0
                                 	breq	notfound
                                 	rjmp	loop
                                 notfound:
                                 	ldi	@1,-1
                                 found:	
                                 	.endmacro
                                 
                                 ; --- branch table ---
                                 .macro	C_TBL	; reg,tbl
                                 	ldi	ZL, low(2*@1)
                                 	ldi	ZH,high(2*@1)
                                 	lsl	@0
                                 	add	ZL,@0
                                 	brcc	PC+2
                                 	inc	ZH
                                 	lpm
                                 	push	r0
                                 	lpm
                                 	mov	zh,r0
                                 	pop	zl
                                 	icall
                                 	.endmacro
                                 .macro	J_TBL	; reg,tbl	
                                 	ldi	ZL, low(2*@1)
                                 	ldi	ZH,high(2*@1)
                                 	lsl	@0
                                 	add	ZL,@0
                                 	brcc	PC+2
                                 	inc	ZH
                                 	lpm
                                 	push	r0
                                 	lpm
                                 	mov	zh,r0
                                 	pop	zl	
                                 	ijmp
                                 	.endmacro
                                 
                                 .macro	BRANCH	; reg		; branching using the stack
                                 	ldi	w, low(tbl)
                                 	add	w,@0
                                 	push	w
                                 	ldi	w,high(tbl)
                                 	brcc	PC+2
                                 	inc	w
                                 	push	w
                                 	ret
                                 tbl:
                                 	.endmacro	
                                 
                                 ; --- multiply/division ---
                                 .macro	DIV2	; reg
                                 	lsr	@0
                                 	.endmacro
                                 .macro	DIV4	; reg
                                 	lsr	@0
                                 	lsr	@0
                                 	.endmacro	
                                 .macro	DIV8	; reg
                                 	lsr	@0
                                 	lsr	@0
                                 	lsr	@0
                                 	.endmacro
                                 	
                                 .macro	MUL2	; reg
                                 	lsl	@0
                                 	.endmacro
                                 .macro	MUL4	; reg
                                 	lsl	@0
                                 	lsl	@0
                                 	.endmacro
                                 .macro	MUL8	; reg
                                 	lsl	@0
                                 	lsl	@0
                                 	lsl	@0
                                 	.endmacro
                                 
                                 ; ====================================
                                 ; 	extending existing instructios
                                 ; ====================================
                                 
                                 ; --- immediate ops with r0..r15 ---
                                 .macro	_ADDI
                                 	ldi	w,@1
                                 	add	@0,w
                                 	.endmacro
                                 .macro	_ADCI
                                 	ldi	w,@1
                                 	adc	@0,w
                                 	.endmacro
                                 .macro	_SUBI
                                 	ldi	w,@1
                                 	sub	@0,w
                                 	.endmacro
                                 .macro	_SBCI
                                 	ldi	w,@1
                                 	sbc	@0,w
                                 	.endmacro
                                 .macro	_ANDI
                                 	ldi	w,@1
                                 	and	@0,w
                                 	.endmacro
                                 .macro	_ORI
                                 	ldi	w,@1
                                 	or	@0,w
                                 	.endmacro
                                 .macro	_EORI
                                 	ldi	w,@1
                                 	eor	@0,w
                                 	.endmacro
                                 .macro	_SBR
                                 	ldi	w,@1
                                 	or	@0,w
                                 	.endmacro
                                 .macro	_CBR
                                 	ldi	w,~@1
                                 	and	@0,w
                                 	.endmacro
                                 .macro	_CPI
                                 	ldi	w,@1
                                 	cp	@0,w
                                 	.endmacro
                                 .macro	_LDI
                                 	ldi	w,@1
                                 	mov	@0,w
                                 	.endmacro
                                 
                                 ; --- bit access for port p32..p63 ---
                                 .macro	_SBI
                                 	in	w,@0
                                 	ori	w,1<<@1
                                 	out	@0,w
                                 	.endmacro
                                 .macro	_CBI
                                 	in	w,@0
                                 	andi	w,~(1<<@1)
                                 	out	@0,w
                                 	.endmacro
                                 	
                                 ; --- extending branch distance to +/-2k ---
                                 .macro	_BREQ
                                 	brne	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRNE
                                 	breq	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRCS
                                 	brcc	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRCC
                                 	brcs	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRSH
                                 	brlo	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRLO
                                 	brsh	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRMI
                                 	brpl	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRPL
                                 	brmi	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRGE
                                 	brlt	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRLT
                                 	brge	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRHS
                                 	brhc	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRHC
                                 	brhs	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRTS
                                 	brtc	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRTC
                                 	brts	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRVS
                                 	brvc	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRVC
                                 	brvs	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRIE
                                 	brid	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRID
                                 	brie	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 
                                 ; ====================
                                 ; 	bit operations
                                 ; ====================
                                 
                                 ; --- moving bits ---
                                 .macro	MOVB	; reg1,b1, reg2,b2	; reg1,bit1 <- reg2,bit2
                                 	bst	@2,@3
                                 	bld	@0,@1
                                 	.endmacro
                                 .macro	OUTB	; port1,b1, reg2,b2	; port1,bit1 <- reg2,bit2
                                 	sbrs	@2,@3
                                 	cbi	@0,@1
                                 	sbrc	@2,@3
                                 	sbi	@0,@1
                                 	.endmacro
                                 .macro	INB	; reg1,b1, port2,b2	; reg1,bit1 <- port2,bit2
                                 	sbis	@2,@3
                                 	cbr	@0,1<<@1
                                 	sbic	@2,@3
                                 	sbr	@0,1<<@1
                                 	.endmacro
                                 
                                 .macro	Z2C				; zero to carry
                                 	sec
                                 	breq	PC+2	; (Z=1)
                                 	clc
                                 	.endmacro
                                 .macro	Z2INVC				; zero to inverse carry
                                 	sec
                                 	brne	PC+2	; (Z=0)
                                 	clc
                                 	.endmacro
                                 
                                 .macro	C2Z				; carry to zero
                                 	sez
                                 	brcs	PC+2	; (C=1)
                                 	clz
                                 	.endmacro
                                 
                                 .macro	B2C	; reg,b			; bit to carry
                                 	sbrc	@0,@1
                                 	sec
                                 	sbrs	@0,@1
                                 	clc
                                 	.endmacro
                                 .macro	C2B	; reg,b			; carry to bit
                                 	brcc	PC+2
                                 	sbr	@0,(1<<@1)
                                 	brcs	PC+2
                                 	cbr	@0,(1<<@1)
                                 	.endmacro
                                 .macro	P2C	; port,b		; port to carry
                                 	sbic	@0,@1
                                 	sec
                                 	sbis	@0,@1
                                 	clc
                                 	.endmacro
                                 .macro	C2P	; port,b		; carry to port
                                 	brcc	PC+2
                                 	sbi	@0,@1
                                 	brcs	PC+2
                                 	cbi	@0,@1
                                 	.endmacro
                                 
                                 ; --- inverting bits ---
                                 .macro	INVB	; reg,bit		; inverse reg,bit
                                 	ldi	w,(1<<@1)
                                 	eor	@0,w
                                 	.endmacro
                                 .macro	INVP	; port,bit		; inverse port,bit	
                                 	sbis	@0,@1
                                 	rjmp	PC+3
                                 	cbi	@0,@1
                                 	rjmp	PC+2
                                 	sbi	@0,@1
                                 	.endmacro
                                 .macro	INVC				; inverse carry	
                                 	brcs	PC+3
                                 	sec
                                 	rjmp	PC+2
                                 	clc
                                 	.endmacro
                                 
                                 ; --- setting a single bit ---
                                 .macro	SETBIT	; reg(0..7)
                                 ; in	reg (0..7)
                                 ; out	reg with bit (0..7) set to 1.
                                 ; 0=00000001
                                 ; 1=00000010
                                 ; ...
                                 ; 7=10000000
                                 	mov	w,@0
                                 	clr	@0
                                 	inc	@0
                                 	andi	w,0b111	
                                 	breq	PC+4
                                 	lsl	@0
                                 	dec	w
                                 	brne	PC-2
                                 	.endmacro
                                 
                                 ; --- logical operations with masks ---
                                 .macro	MOVMSK	; reg1,reg2,mask	; reg1 <- reg2 (mask)
                                 	ldi	w,~@2	
                                 	and	@0,w
                                 	ldi	w,@2
                                 	and	@1,w	
                                 	or	@0,@1
                                 	.endmacro	
                                 .macro	ANDMSK	; reg1,reg2,mask	; reg1 <- ret 1 AND reg2 (mask)		
                                 	mov	w,@1
                                 	ori	w,~@2
                                 	and	@0,w
                                 	.endmacro	
                                 .macro	ORMSK	; reg1,reg2,mask	; reg1 <- ret 1 AND reg2 (mask)		
                                 	mov	w,@1
                                 	andi	w,@2
                                 	or	@0,w
                                 	.endmacro
                                 	
                                 ; --- logical operations on bits ---
                                 .macro	ANDB	; r1,b1, r2,b2, r3,b3	; reg1,b1 <- reg2,b2 AND reg3,b3
                                 	set
                                 	sbrs	@4,@5	
                                 	clt
                                 	sbrs	@2,@3	
                                 	clt
                                 	bld	@0,@1
                                 	.endmacro
                                 .macro	ORB	; r1,b1, r2,b2, r3,b3	; reg1.b1 <- reg2.b2 OR reg3.b3
                                 	clt
                                 	sbrc	@4,@5	
                                 	set
                                 	sbrc	@2,@3	
                                 	set
                                 	bld	@0,@1
                                 	.endmacro
                                 .macro	EORB	; r1,b1, r2,b2, r3,b3	; reg1.b1 <- reg2.b2 XOR reg3.b3
                                 	sbrc	@4,@5
                                 	rjmp	f1
                                 f0:	bst	@2,@3	
                                 	rjmp	PC+4
                                 f1:	set
                                 	sbrc	@0,@1
                                 	clt
                                 	bld	@0,@0	
                                 	.endmacro
                                 	
                                 ; --- operations based on register bits ---
                                 .macro	FB0	; reg,bit		; bit=0
                                 	cbr	@0,1<<@1
                                 	.endmacro
                                 .macro	FB1	; reg,bit		; bit=1
                                 	sbr	@0,1<<@1
                                 	.endmacro
                                 .macro	_FB0	; reg,bit		; bit=0
                                 	ldi	w,~(1<<@1)
                                 	and	@0,w
                                 	.endmacro
                                 .macro	_FB1	; reg,bit		; bit=1
                                 	ldi	w,1<<@1
                                 	or	@0,w
                                 	.endmacro
                                 .macro	SB0	; reg,bit,addr		; skip if bit=0
                                 	sbrc	@0,@1
                                 	.endmacro
                                 .macro	SB1	; reg,bit,addr		; skip if bit=1
                                 	sbrs	@0,@1
                                 	.endmacro
                                 .macro	JB0	; reg,bit,addr		; jump if bit=0
                                 	sbrs	@0,@1
                                 	rjmp	@2
                                 	.endmacro
                                 .macro	JB1	; reg,bit,addr		; jump if bit=1
                                 	sbrc	@0,@1
                                 	rjmp	@2
                                 	.endmacro
                                 .macro	CB0	; reg,bit,addr		; call if bit=0
                                 	sbrs	@0,@1
                                 	rcall	@2
                                 	.endmacro
                                 .macro	CB1	; reg,bit,addr		; call if bit=1
                                 	sbrc	@0,@1
                                 	rcall	@2
                                 	.endmacro
                                 .macro	WB0	; reg,bit		; wait if bit=0
                                 	sbrs	@0,@1
                                 	rjmp	PC-1
                                 	.endmacro
                                 .macro	WB1	; reg,bit		; wait if bit=1
                                 	sbrc	@0,@1
                                 	rjmp	PC-1
                                 	.endmacro
                                 .macro	RB0	; reg,bit		; return if bit=0
                                 	sbrs	@0,@1
                                 	ret
                                 	.endmacro
                                 .macro	RB1	; reg,bit		; return if bit=1
                                 	sbrc	@0,@1
                                 	ret
                                 	.endmacro
                                 
                                 ; wait if bit=0 with timeout
                                 ; if timeout (in units of 5 cyc) then jump to addr
                                 .macro	WB0T	; reg,bit,timeout,addr
                                 	ldi	w,@2+1
                                 	dec	w	; 1 cyc
                                 	breq	@3	; 1 cyc
                                 	sbrs	@0,@1	; 1 cyc
                                 	rjmp	PC-3	; 2 cyc = 5 cycles
                                 	.endmacro
                                 
                                 ; wait if bit=1 with timeout
                                 ; if timeout (in units of 5 cyc) then jump to addr	
                                 .macro	WB1T	; reg,bit,timeout,addr
                                 	ldi	w,@2+1
                                 	dec	w	; 1 cyc
                                 	breq	@3	; 1 cyc
                                 	sbrc	@0,@1	; 1 cyc
                                 	rjmp	PC-3	; 2 cyc = 5 cycles
                                 	.endmacro	
                                 	
                                 ; --- operations based on port bits ---
                                 .macro	P0	; port,bit		; port=0
                                 	cbi	@0,@1
                                 	.endmacro
                                 .macro	P1	; port,bit		; port=1
                                 	sbi	@0,@1
                                 	.endmacro
                                 .macro	SP0	; port,bit		; skip if port=0
                                 	sbic	@0,@1
                                 	.endmacro
                                 .macro	SP1	; port,bit		; skip if port=1
                                 	sbis	@0,@1
                                 	.endmacro
                                 .macro	JP0	; port,bit,addr		; jump if port=0
                                 	sbis	@0,@1
                                 	rjmp	@2
                                 	.endmacro
                                 .macro	JP1	; port,bit,addr		; jump if port=1
                                 	sbic	@0,@1
                                 	rjmp	@2
                                 	.endmacro
                                 .macro	CP0	; port,bit,addr		; call if port=0
                                 	sbis	@0,@1
                                 	rcall	@2
                                 	.endmacro
                                 .macro	CP1	; port,bit,addr		; call if port=1
                                 	sbic	@0,@1
                                 	rcall	@2
                                 	.endmacro
                                 .macro	WP0	; port,bit		; wait if port=0
                                 	sbis	@0,@1
                                 	rjmp	PC-1
                                 	.endmacro
                                 .macro	WP1	; port,bit		; wait if port=1
                                 	sbic	@0,@1
                                 	rjmp	PC-1
                                 	.endmacro
                                 .macro	RP0	; port,bit		; return if port=0
                                 	sbis	@0,@1
                                 	ret
                                 	.endmacro
                                 .macro	RP1	; port,bit		; return if port=1
                                 	sbic	@0,@1
                                 	ret
                                 	.endmacro
                                 
                                 ; wait if port=0 with timeout
                                 ; if timeout (in units of 5 cyc) then jump to addr
                                 .macro	WP0T	; port,bit,timeout,addr
                                 	ldi	w,@2+1
                                 	dec	w	; 1 cyc
                                 	breq	@3	; 1 cyc
                                 	sbis	@0,@1	; 1 cyc
                                 	rjmp	PC-3	; 2 cyc = 5 cycles
                                 	.endmacro
                                 
                                 ; wait if port=1 with timeout
                                 ; if timeout (in units of 5 cyc) then jump to addr	
                                 .macro	WP1T	; port,bit,timeout,addr
                                 	ldi	w,@2+1
                                 	dec	w	; 1 cyc
                                 	breq	@3	; 1 cyc
                                 	sbic	@0,@1	; 1 cyc
                                 	rjmp	PC-3	; 2 cyc = 5 cycles
                                 	.endmacro	
                                 
                                 ; ===========================
                                 ; 	multi-byte operations
                                 ; ===========================
                                 
                                 .macro	SWAP4			; swap 2 variables
                                 	mov	w ,@0
                                 	mov	@0,@4
                                 	mov	@4,w
                                 	mov	w ,@1
                                 	mov	@1,@5
                                 	mov	@5,w
                                 	mov	w ,@2
                                 	mov	@2,@6
                                 	mov	@6,w
                                 	mov	w ,@3
                                 	mov	@3,@7
                                 	mov	@7,w
                                 	.endmacro
                                 .macro	SWAP3
                                 	mov	w ,@0
                                 	mov	@0,@3
                                 	mov	@3,w
                                 	mov	w ,@1
                                 	mov	@1,@4
                                 	mov	@4,w
                                 	mov	w ,@2
                                 	mov	@2,@5
                                 	mov	@5,w
                                 	.endmacro
                                 .macro	SWAP2
                                 	mov	w ,@0
                                 	mov	@0,@2
                                 	mov	@2,w
                                 	mov	w ,@1
                                 	mov	@1,@3
                                 	mov	@3,w
                                 	.endmacro
                                 .macro	SWAP1
                                 	mov	w ,@0
                                 	mov	@0,@1
                                 	mov	@1,w
                                 	.endmacro
                                 
                                 .macro	LDX4	;r..r0		; load from (x+)
                                 	ld	@3,x+
                                 	ld	@2,x+	
                                 	ld	@1,x+
                                 	ld	@0,x+
                                 	.endmacro
                                 .macro	LDX3	;r..r0
                                 	ld	@2,x+	
                                 	ld	@1,x+
                                 	ld	@0,x+
                                 	.endmacro
                                 .macro	LDX2	;r..r0	
                                 	ld	@1,x+
                                 	ld	@0,x+
                                 	.endmacro
                                 	
                                 .macro	LDY4	;r..r0		; load from (y+)
                                 	ld	@3,y+
                                 	ld	@2,y+	
                                 	ld	@1,y+
                                 	ld	@0,y+
                                 	.endmacro
                                 .macro	LDY3	;r..r0
                                 	ld	@2,y+	
                                 	ld	@1,y+
                                 	ld	@0,y+
                                 	.endmacro
                                 .macro	LDY2	;r..r0	
                                 	ld	@1,y+
                                 	ld	@0,y+
                                 	.endmacro
                                 
                                 .macro	LDZ4	;r..r0		; load from (z+)
                                 	ld	@3,z+
                                 	ld	@2,z+	
                                 	ld	@1,z+
                                 	ld	@0,z+
                                 	.endmacro
                                 .macro	LDZ3	;r..r0
                                 	ld	@2,z+	
                                 	ld	@1,z+
                                 	ld	@0,z+
                                 	.endmacro
                                 .macro	LDZ2	;r..r0
                                 	ld	@1,z+
                                 	ld	@0,z+
                                 	.endmacro
                                 
                                 .macro	STX4	;r..r0		; store to (x+)
                                 	st	x+,@3
                                 	st	x+,@2	
                                 	st	x+,@1
                                 	st	x+,@0
                                 	.endmacro
                                 .macro	STX3	;r..r0
                                 	st	x+,@2	
                                 	st	x+,@1
                                 	st	x+,@0
                                 	.endmacro
                                 .macro	STX2	;r..r0
                                 	st	x+,@1
                                 	st	x+,@0
                                 	.endmacro
                                 	
                                 .macro	STY4	;r..r0		; store to (y+)
                                 	st	y+,@3
                                 	st	y+,@2	
                                 	st	y+,@1
                                 	st	y+,@0
                                 	.endmacro
                                 .macro	STY3	;r..r0
                                 	st	y+,@2	
                                 	st	y+,@1
                                 	st	y+,@0
                                 	.endmacro
                                 .macro	STY2	;r..r0	
                                 	st	y+,@1
                                 	st	y+,@0
                                 	.endmacro
                                 	
                                 .macro	STZ4	;r..r0		; store to (z+)
                                 	st	z+,@3
                                 	st	z+,@2	
                                 	st	z+,@1
                                 	st	z+,@0
                                 	.endmacro	
                                 .macro	STZ3	;r..r0
                                 	st	z+,@2	
                                 	st	z+,@1
                                 	st	z+,@0
                                 	.endmacro	
                                 .macro	STZ2	;r..r0	
                                 	st	z+,@1
                                 	st	z+,@0
                                 	.endmacro	
                                 	
                                 .macro	STI4	;addr,k		; store immediate
                                 	ldi	w,  low(@1)
                                 	sts	@0+0,w
                                 	ldi	w, high(@1)
                                 	sts	@0+1,w
                                 	ldi	w,byte3(@1)
                                 	sts	@0+2,w
                                 	ldi	w,byte4(@1)
                                 	sts	@0+3,w	
                                 	.endmacro	
                                 .macro	STI3	;addr,k
                                 	ldi	w,  low(@1)
                                 	sts	@0+0,w
                                 	ldi	w, high(@1)
                                 	sts	@0+1,w
                                 	ldi	w,byte3(@1)
                                 	sts	@0+2,w
                                 	.endmacro	
                                 .macro	STI2	;addr,k
                                 	ldi	w,  low(@1)
                                 	sts	@0+0,w
                                 	ldi	w, high(@1)
                                 	sts	@0+1,w
                                 	.endmacro
                                 .macro	STI	;addr,k
                                 	ldi	w,@1
                                 	sts	@0,w
                                 	.endmacro
                                 
                                 .macro	INC4			; increment
                                 	ldi	w,0xff
                                 	sub	@3,w
                                 	sbc	@2,w
                                 	sbc	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 .macro	INC3
                                 	ldi	w,0xff
                                 	sub	@2,w
                                 	sbc	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 .macro	INC2
                                 	ldi	w,0xff
                                 	sub	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 
                                 .macro	DEC4			; decrement
                                 	ldi	w,0xff
                                 	add	@3,w
                                 	adc	@2,w
                                 	adc	@1,w
                                 	adc	@0,w
                                 	.endmacro
                                 .macro	DEC3
                                 	ldi	w,0xff
                                 	add	@2,w
                                 	adc	@1,w
                                 	adc	@0,w
                                 	.endmacro
                                 .macro	DEC2
                                 	ldi	w,0xff
                                 	add	@1,w
                                 	adc	@0,w
                                 	.endmacro
                                 
                                 .macro	CLR9			; clear (also clears the carry)
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	clr	@4
                                 	clr	@5
                                 	clr	@6
                                 	clr	@7
                                 	clr	@8
                                 	.endmacro
                                 .macro	CLR8
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	clr	@4
                                 	clr	@5
                                 	clr	@6
                                 	clr	@7
                                 	.endmacro
                                 .macro	CLR7
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	clr	@4
                                 	clr	@5
                                 	clr	@6
                                 	.endmacro
                                 .macro	CLR6
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	clr	@4
                                 	clr	@5
                                 	.endmacro
                                 .macro	CLR5
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	clr	@4
                                 	.endmacro
                                 .macro	CLR4
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	.endmacro
                                 .macro	CLR3
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	.endmacro
                                 .macro	CLR2
                                 	sub	@0,@0
                                 	clr	@1
                                 	.endmacro
                                 
                                 .macro	COM4			; one's complement
                                 	com	@0
                                 	com	@1
                                 	com	@2
                                 	com	@3
                                 	.endmacro
                                 .macro	COM3
                                 	com	@0
                                 	com	@1
                                 	com	@2
                                 	.endmacro
                                 .macro	COM2
                                 	com	@0
                                 	com	@1
                                 	.endmacro
                                 
                                 .macro	NEG4			; negation (two's complement)
                                 	com	@0
                                 	com	@1
                                 	com	@2
                                 	com	@3
                                 	ldi	w,0xff
                                 	sub	@3,w
                                 	sbc	@2,w
                                 	sbc	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 .macro	NEG3
                                 	com	@0
                                 	com	@1
                                 	com	@2
                                 	ldi	w,0xff
                                 	sub	@2,w
                                 	sbc	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 .macro	NEG2
                                 	com	@0
                                 	com	@1
                                 	ldi	w,0xff
                                 	sub	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 	
                                 .macro	LDI4 	; r..r0, k	; load immediate
                                 	ldi	@3,  low(@4)
                                 	ldi	@2, high(@4)
                                 	ldi	@1,byte3(@4)
                                 	ldi	@0,byte4(@4)
                                 	.endmacro
                                 .macro	LDI3
                                 	ldi	@2,  low(@3)
                                 	ldi	@1, high(@3)
                                 	ldi	@0,byte3(@3)
                                 	.endmacro
                                 .macro	LDI2
                                 	ldi	@1,  low(@2)
                                 	ldi	@0, high(@2)
                                 	.endmacro
                                 
                                 .macro	LDS4			; load direct from SRAM
                                 	lds	@3,@4
                                 	lds	@2,@4+1
                                 	lds	@1,@4+2
                                 	lds	@0,@4+3
                                 	.endmacro
                                 .macro	LDS3
                                 	lds	@2,@3
                                 	lds	@1,@3+1
                                 	lds	@0,@3+2
                                 	.endmacro
                                 .macro	LDS2
                                 	lds	@1,@2
                                 	lds	@0,@2+1
                                 	.endmacro
                                 
                                 .macro	STS4			; store direct to SRAM
                                 	sts	@0+0,@4
                                 	sts	@0+1,@3
                                 	sts	@0+2,@2
                                 	sts	@0+3,@1
                                 	.endmacro
                                 .macro	STS3
                                 	sts	@0+0,@3
                                 	sts	@0+1,@2
                                 	sts	@0+2,@1
                                 	.endmacro
                                 .macro	STS2
                                 	sts	@0+0,@2
                                 	sts	@0+1,@1
                                 	.endmacro
                                 
                                 .macro	STDZ4	; d, r3,r2,r1,r0
                                 	std	z+@0+0,@4
                                 	std	z+@0+1,@3
                                 	std	z+@0+2,@2
                                 	std	z+@0+3,@1
                                 	.endmacro
                                 .macro	STDZ3	; d, r2,r1,r0
                                 	std	z+@0+0,@3
                                 	std	z+@0+1,@2
                                 	std	z+@0+2,@1
                                 	.endmacro
                                 .macro	STDZ2	; d, r1,r0
                                 	std	z+@0+0,@2
                                 	std	z+@0+1,@1
                                 	.endmacro
                                 	
                                 .macro	LPM4			; load program memory
                                 	lpm
                                 	mov	@3,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@2,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@1,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@0,r0
                                 	adiw	zl,1
                                 	.endmacro
                                 .macro	LPM3
                                 	lpm
                                 	mov	@2,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@1,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@0,r0
                                 	adiw	zl,1
                                 	.endmacro
                                 .macro	LPM2
                                 	lpm
                                 	mov	@1,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@0,r0
                                 	adiw	zl,1
                                 	.endmacro
                                 .macro	LPM1
                                 	lpm
                                 	mov	@0,r0
                                 	adiw	zl,1
                                 	.endmacro
                                 
                                 .macro	MOV4			; move between registers
                                 	mov	@3,@7
                                 	mov	@2,@6
                                 	mov	@1,@5
                                 	mov	@0,@4
                                 	.endmacro
                                 .macro	MOV3
                                 	mov	@2,@5
                                 	mov	@1,@4
                                 	mov	@0,@3
                                 	.endmacro
                                 .macro	MOV2
                                 	mov	@1,@3
                                 	mov	@0,@2
                                 	.endmacro
                                 
                                 .macro	ADD4			; add
                                 	add	@3,@7
                                 	adc	@2,@6
                                 	adc	@1,@5
                                 	adc	@0,@4
                                 	.endmacro
                                 .macro	ADD3
                                 	add	@2,@5
                                 	adc	@1,@4
                                 	adc	@0,@3
                                 	.endmacro
                                 .macro	ADD2
                                 	add	@1,@3
                                 	adc	@0,@2
                                 	.endmacro
                                 
                                 .macro	SUB4			; subtract
                                 	sub	@3,@7
                                 	sbc	@2,@6
                                 	sbc	@1,@5
                                 	sbc	@0,@4
                                 	.endmacro
                                 .macro	SUB3
                                 	sub	@2,@5
                                 	sbc	@1,@4
                                 	sbc	@0,@3
                                 	.endmacro
                                 .macro	SUB2
                                 	sub	@1,@3
                                 	sbc	@0,@2
                                 	.endmacro
                                 	
                                 .macro	CP4			; compare
                                 	cp	@3,@7
                                 	cpc	@2,@6
                                 	cpc	@1,@5
                                 	cpc	@0,@4
                                 	.endmacro
                                 .macro	CP3
                                 	cp	@2,@5
                                 	cpc	@1,@4
                                 	cpc	@0,@3
                                 	.endmacro
                                 .macro	CP2
                                 	cp	@1,@3
                                 	cpc	@0,@2
                                 	.endmacro
                                 
                                 .macro	TST4			; test
                                 	clr	w
                                 	cp	@3,w
                                 	cpc	@2,w
                                 	cpc	@1,w
                                 	cpc	@0,w
                                 	.endmacro
                                 .macro	TST3
                                 	clr	w
                                 	cp	@2,w
                                 	cpc	@1,w
                                 	cpc	@0,w
                                 	.endmacro
                                 .macro	TST2
                                 	clr	w
                                 	cp	@1,w
                                 	cpc	@0,w
                                 	.endmacro
                                 
                                 .macro	ADDI4			; add immediate
                                 	subi	@3,  low(-@4)
                                 	sbci	@2, high(-@4)
                                 	sbci	@1,byte3(-@4)
                                 	sbci	@0,byte4(-@4)
                                 	.endmacro
                                 .macro	ADDI3
                                 	subi	@2,  low(-@3)
                                 	sbci	@1, high(-@3)
                                 	sbci	@0,byte3(-@3)
                                 	.endmacro
                                 .macro	ADDI2
                                 	subi	@1,  low(-@2)
                                 	sbci	@0, high(-@2)
                                 	.endmacro
                                 	
                                 .macro	SUBI4			; subtract immediate
                                 	subi	@3,  low(@4)
                                 	sbci	@2, high(@4)
                                 	sbci	@1,byte3(@4)
                                 	sbci	@0,byte4(@4)
                                 	.endmacro
                                 .macro	SUBI3
                                 	subi	@2,  low(@3)
                                 	sbci	@1, high(@3)
                                 	sbci	@0,byte3(@3)
                                 	.endmacro
                                 .macro	SUBI2
                                 	subi	@1,  low(@2)
                                 	sbci	@0, high(@2)
                                 	.endmacro
                                 
                                 .macro	LSL5			; logical shift left
                                 	lsl	@4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	LSL4
                                 	lsl	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	LSL3
                                 	lsl	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	LSL2
                                 	lsl	@1
                                 	rol	@0
                                 	.endmacro
                                 	
                                 .macro	LSR4			; logical shift right
                                 	lsr	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	.endmacro
                                 .macro	LSR3
                                 	lsr	@0
                                 	ror	@1
                                 	ror	@2
                                 	.endmacro
                                 .macro	LSR2
                                 	lsr	@0
                                 	ror	@1
                                 	.endmacro
                                 
                                 .macro	ASR4			; arithmetic shift right
                                 	asr	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	.endmacro
                                 .macro	ASR3
                                 	asr	@0
                                 	ror	@1
                                 	ror	@2
                                 	.endmacro
                                 .macro	ASR2
                                 	asr	@0
                                 	ror	@1
                                 	.endmacro
                                 
                                 .macro	ROL8			; rotate left through carry
                                 	rol	@7
                                 	rol	@6
                                 	rol	@5
                                 	rol	@4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL7
                                 	rol	@6
                                 	rol	@5
                                 	rol	@4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL6
                                 	rol	@5
                                 	rol	@4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL5
                                 	rol	@4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 
                                 .macro	ROR8			; rotate right through carry
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	ror	@4
                                 	ror	@5
                                 	ror	@6
                                 	ror	@7
                                 	.endmacro
                                 .macro	ROR7
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	ror	@4
                                 	ror	@5
                                 	ror	@6
                                 	.endmacro
                                 .macro	ROR6
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	ror	@4
                                 	ror	@5
                                 	.endmacro
                                 .macro	ROR5
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	ror	@4
                                 	.endmacro	
                                 .macro	ROR4
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	.endmacro
                                 .macro	ROR3
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	.endmacro
                                 .macro	ROR2
                                 	ror	@0
                                 	ror	@1
                                 	.endmacro
                                 
                                 .macro	PUSH2
                                 	push	@0
                                 	push	@1
                                 	.endmacro	
                                 .macro	POP2
                                 	pop	@1
                                 	pop	@0
                                 	.endmacro
                                 
                                 .macro	PUSH3
                                 	push	@0
                                 	push	@1
                                 	push	@2
                                 	.endmacro	
                                 .macro	POP3
                                 	pop	@2
                                 	pop	@1
                                 	pop	@0
                                 	.endmacro
                                 	
                                 .macro	PUSH4
                                 	push	@0
                                 	push	@1
                                 	push	@2
                                 	push	@3
                                 	.endmacro	
                                 .macro	POP4
                                 	pop	@3
                                 	pop	@2
                                 	pop	@1
                                 	pop	@0
                                 	.endmacro	
                                 	
                                 .macro	PUSH5
                                 	push	@0
                                 	push	@1
                                 	push	@2
                                 	push	@3
                                 	push	@4
                                 	.endmacro	
                                 .macro	POP5
                                 	pop	@4
                                 	pop	@3
                                 	pop	@2
                                 	pop	@1
                                 	pop	@0
                                 	.endmacro	
                                 
                                 ; --- SRAM operations ---
                                 .macro	INCS4	; sram		; increment SRAM 4-byte variable
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	brne	end
                                 	lds	w,@0+1
                                 	inc	w
                                 	sts	@0+1,w
                                 	brne	end
                                 	lds	w,@0+2
                                 	inc	w
                                 	sts	@0+2,w
                                 	brne	end
                                 	lds	w,@0+3
                                 	inc	w
                                 	sts	@0+3,w
                                 end:	
                                 	.endmacro
                                 
                                 .macro	INCS3	; sram		; increment SRAM 3-byte variable
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	brne	end
                                 	lds	w,@0+1
                                 	inc	w
                                 	sts	@0+1,w
                                 	brne	end
                                 	lds	w,@0+2
                                 	inc	w
                                 	sts	@0+2,w
                                 end:	
                                 	.endmacro
                                 
                                 .macro	INCS2	; sram		; increment SRAM 2-byte variable
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	brne	end
                                 	lds	w,@0+1
                                 	inc	w
                                 	sts	@0+1,w
                                 end:	
                                 	.endmacro
                                 
                                 .macro	INCS	; sram		; increment SRAM 1-byte variable
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	.endmacro
                                 
                                 .macro	DECS4	; sram		; decrement SRAM 4-byte variable
                                 	ldi	w,1
                                 	lds	u,@0
                                 	sub	u,w
                                 	sts	@0,u
                                 	clr	w
                                 	lds	u,@0+1
                                 	sbc	u,w
                                 	sts	@0+1,u
                                 	lds	u,@0+2
                                 	sbc	u,w
                                 	sts	@0+2,u
                                 	lds	u,@0+3
                                 	sbc	u,w
                                 	sts	@0+3,u
                                 	.endmacro
                                 .macro	DECS3	; sram		; decrement SRAM 3-byte variable
                                 	ldi	w,1
                                 	lds	u,@0
                                 	sub	u,w
                                 	sts	@0,u
                                 	clr	w
                                 	lds	u,@0+1
                                 	sbc	u,w
                                 	sts	@0+1,u
                                 	lds	u,@0+2
                                 	sbc	u,w
                                 	sts	@0+2,u
                                 	.endmacro
                                 .macro	DECS2	; sram		; decrement SRAM 2-byte variable
                                 	ldi	w,1
                                 	lds	u,@0
                                 	sub	u,w
                                 	sts	@0,u
                                 	clr	w
                                 	lds	u,@0+1
                                 	sbc	u,w
                                 	sts	@0+1,u
                                 	.endmacro
                                 .macro	DECS	; sram		; decrement
                                 	lds	w,@0
                                 	dec	w
                                 	sts	@0,w
                                 	.endmacro
                                 
                                 .macro	MOVS4	; addr0,addr1	; [addr0] <-- [addr1]
                                 	lds	w,@1
                                 	sts	@0,w
                                 	lds	w,@1+1
                                 	sts	@0+1,w
                                 	lds	w,@1+2
                                 	sts	@0+2,w
                                 	lds	w,@3+1
                                 	sts	@0+3,w	
                                 	.endmacro
                                 .macro	MOVS3	; addr0,addr1	; [addr0] <-- [addr1]
                                 	lds	w,@1
                                 	sts	@0,w
                                 	lds	w,@1+1
                                 	sts	@0+1,w
                                 	lds	w,@1+2
                                 	sts	@0+2,w
                                 	.endmacro
                                 .macro	MOVS2	; addr0,addr1	; [addr0] <-- [addr1]
                                 	lds	w,@1
                                 	sts	@0,w
                                 	lds	w,@1+1
                                 	sts	@0+1,w
                                 	.endmacro
                                 .macro	MOVS	; addr0,addr1	; [addr0] <-- [addr1]
                                 	lds	w,@1
                                 	sts	@0,w
                                 	.endmacro
                                 
                                 .macro	SEXT	; reg1,reg0	; sign extend
                                 	clr	@0
                                 	sbrc	@1,7
                                 	dec	@0
                                 	.endmacro
                                 
                                 ; =======================================
                                 ;	Jump/Call with constant arguments
                                 ; =======================================
                                 	
                                 ; --- calls with arguments a,b,XYZ ---
                                 .macro	CX	; subroutine,x
                                 	ldi	xl, low(@1)
                                 	ldi	xh,high(@1)
                                 	rcall	@0
                                 	.endmacro
                                 .macro	CXY	; subroutine,x,y
                                 	ldi	xl, low(@1)
                                 	ldi	xh,high(@1)
                                 	ldi	yl, low(@2)
                                 	ldi	yh,high(@2)	
                                 	rcall	@0
                                 	.endmacro		
                                 .macro	CXZ	; subroutine,x,z
                                 	ldi	xl, low(@1)
                                 	ldi	xh,high(@1)
                                 	ldi	zl, low(@2)
                                 	ldi	zh,high(@2)	
                                 	rcall	@0
                                 	.endmacro		
                                 .macro	CXYZ	; subroutine,x,y,z
                                 	ldi	xl, low(@1)
                                 	ldi	xh,high(@1)
                                 	ldi	yl, low(@2)
                                 	ldi	yh,high(@2)
                                 	ldi	zl, low(@3)
                                 	ldi	zh,high(@3)		
                                 	rcall	@0
                                 	.endmacro
                                 .macro	CW	; subroutine,w
                                 	ldi	w, @1
                                 	rcall	@0
                                 	.endmacro
                                 .macro	CA	; subroutine,a
                                 	ldi	a0, @1
                                 	rcall	@0
                                 	.endmacro
                                 .macro	CAB	; subroutine,a,b
                                 	ldi	a0, @1
                                 	ldi	b0, @2
                                 	rcall	@0
                                 	.endmacro
                                 
                                 ; --- jump with arguments w,a,b ---
                                 .macro	JW	; subroutine,w
                                 	ldi	w, @1
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	JA	; subroutine,a
                                 	ldi	a0, @1
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	JAB	; subroutine,a,b
                                 	ldi	a0, @1
                                 	ldi	b0, @2
                                 	rjmp	@0
                                 	.endmacro
                                 .list
                                 .include	"Libraries\definitions.asm"	; include register/constant definitions
                                 
                                 ; purpose library, definition of addresses and constants
                                 ; 20171114 A.S.
                                 
                                 ; === definitions  ===
                                 .list
                                 
                                 ; ==== Definitions ==== 
                                 
                                 .def	m = r6					; menu register
                                 .equ	th_addr = 0x0200		; address to store the high temp
                                 .equ	tl_addr = 0x0201		; address to store the low temp
                                 .equ	unit_addr = 0x0202		; address to store the unit
                                 .equ	counter_addr = 0x0203	; address to store the counter for the interrupt
                                 .equ	alarm_addr = 0x0204		; address to store the alarm 
                                 .equ	on_off_addr = 0x205		; address to store if screen is on/off
                                 
                                 .equ	m_eep_addr = 0x0000		; eeprom address to store the menu register
                                 .equ	th_eep = 0x0001			; eeprom address to store the high temp
                                 .equ	tl_eep = 0x0002			; eeprom address to store the low temp
                                 
                                 ;==== Interrupt Vectors ====
                                 
                                 .org	0
000000 940c 0ae6                 	jmp		reset
                                 .org	0x10
000010 940c 0ab4                 	jmp ext_int7
                                 .org	OVF0addr				;overflow timer 0
000020 940c 0abc                 	jmp		ovf0
                                 
                                 
                                 
                                 ; ==== Include Other Files ==== 
                                 
                                 .include	"temp.asm"
                                 
                                 ; purpose call the thermometer to get temperature and update the angular position of the motor
                                 	
                                 .include	"Libraries\math_speed.asm"
                                 
                                 ; purpose library, mathematical routines, optimized for speed
                                 ; copyright R.Holzer	
                                 
                                 ; === multiplication ===
                                 
                                 .macro	M11
                                 	sbrc	b0,@0
                                 	add	c1,a0
                                 	ror	c1
                                 	ror	c0
                                 .endmacro
000022 1899
000023 2488                      mul11:	CLR2	c1,c0	; clears also the carry
000024 fd60
000025 0e92
000026 9497
000027 9487                      	M11	0
000028 fd61
000029 0e92
00002a 9497
00002b 9487                      	M11	1
00002c fd62
00002d 0e92
00002e 9497
00002f 9487                      	M11	2
000030 fd63
000031 0e92
000032 9497
000033 9487                      	M11	3
000034 fd64
000035 0e92
000036 9497
000037 9487                      	M11	4
000038 fd65
000039 0e92
00003a 9497
00003b 9487                      	M11	5
00003c fd66
00003d 0e92
00003e 9497
00003f 9487                      	M11	6
000040 fd67
000041 0e92
000042 9497
000043 9487                      	M11	7
000044 9508                      	ret
                                 
                                 .macro	M21
                                 	sbrs	b0,@0
                                 	rjmp	PC+3
                                 	add	c1,a0
                                 	adc	c2,a1
                                 	ror	c2	; shift-in carry from MSB addition
                                 	ror	c1
                                 	ror	c0
                                 .endmacro
000045 18aa
000046 2499
000047 2488                      mul21:	CLR3	c2,c1,c0
000048 ff60
000049 c002
00004a 0e92
00004b 1ea3
00004c 94a7
00004d 9497
00004e 9487                      	M21	0
00004f ff61
000050 c002
000051 0e92
000052 1ea3
000053 94a7
000054 9497
000055 9487                      	M21	1
000056 ff62
000057 c002
000058 0e92
000059 1ea3
00005a 94a7
00005b 9497
00005c 9487                      	M21	2
00005d ff63
00005e c002
00005f 0e92
000060 1ea3
000061 94a7
000062 9497
000063 9487                      	M21	3
000064 ff64
000065 c002
000066 0e92
000067 1ea3
000068 94a7
000069 9497
00006a 9487                      	M21	4
00006b ff65
00006c c002
00006d 0e92
00006e 1ea3
00006f 94a7
000070 9497
000071 9487                      	M21	5
000072 ff66
000073 c002
000074 0e92
000075 1ea3
000076 94a7
000077 9497
000078 9487                      	M21	6
000079 ff67
00007a c002
00007b 0e92
00007c 1ea3
00007d 94a7
00007e 9497
00007f 9487                      	M21	7
000080 9508                      	ret
                                 	
                                 .macro	M22
                                 	sbrs	b0,@0
                                 	rjmp	PC+4
                                 	add	c1,a0
                                 	adc	c2,a1
                                 	adc	c3,r0	; propagate the carry (r0=0)
                                 	sbrs	b1,@0
                                 	rjmp	PC+3
                                 	add	c2,a0
                                 	adc	c3,a1
                                 	ror	c3	; shift-in carry from MSB addition
                                 	ror	c2
                                 	ror	c1
                                 	ror	c0
                                 .endmacro
000081 18bb
000082 24aa
000083 2499
000084 2488
000085 2400                      mul22:	CLR5	c3,c2,c1,c0,r0
000086 ff60
000087 c003
000088 0e92
000089 1ea3
00008a 1cb0
00008b ff70
00008c c002
00008d 0ea2
00008e 1eb3
00008f 94b7
000090 94a7
000091 9497
000092 9487                      	M22	0
000093 ff61
000094 c003
000095 0e92
000096 1ea3
000097 1cb0
000098 ff71
000099 c002
00009a 0ea2
00009b 1eb3
00009c 94b7
00009d 94a7
00009e 9497
00009f 9487                      	M22	1
0000a0 ff62
0000a1 c003
0000a2 0e92
0000a3 1ea3
0000a4 1cb0
0000a5 ff72
0000a6 c002
0000a7 0ea2
0000a8 1eb3
0000a9 94b7
0000aa 94a7
0000ab 9497
0000ac 9487                      	M22	2
0000ad ff63
0000ae c003
0000af 0e92
0000b0 1ea3
0000b1 1cb0
0000b2 ff73
0000b3 c002
0000b4 0ea2
0000b5 1eb3
0000b6 94b7
0000b7 94a7
0000b8 9497
0000b9 9487                      	M22	3
0000ba ff64
0000bb c003
0000bc 0e92
0000bd 1ea3
0000be 1cb0
0000bf ff74
0000c0 c002
0000c1 0ea2
0000c2 1eb3
0000c3 94b7
0000c4 94a7
0000c5 9497
0000c6 9487                      	M22	4
0000c7 ff65
0000c8 c003
0000c9 0e92
0000ca 1ea3
0000cb 1cb0
0000cc ff75
0000cd c002
0000ce 0ea2
0000cf 1eb3
0000d0 94b7
0000d1 94a7
0000d2 9497
0000d3 9487                      	M22	5
0000d4 ff66
0000d5 c003
0000d6 0e92
0000d7 1ea3
0000d8 1cb0
0000d9 ff76
0000da c002
0000db 0ea2
0000dc 1eb3
0000dd 94b7
0000de 94a7
0000df 9497
0000e0 9487                      	M22	6
0000e1 ff67
0000e2 c003
0000e3 0e92
0000e4 1ea3
0000e5 1cb0
0000e6 ff77
0000e7 c002
0000e8 0ea2
0000e9 1eb3
0000ea 94b7
0000eb 94a7
0000ec 9497
0000ed 9487                      	M22	7
0000ee 9508                      	ret
                                 
                                 .macro	M31
                                 	sbrs	b0,@0
                                 	rjmp	PC+4
                                 	add	c1,a0
                                 	adc	c2,a1
                                 	adc	c3,a2
                                 	ror	c3
                                 	ror	c2
                                 	ror	c1
                                 	ror	c0
                                 .endmacro
0000ef 18bb
0000f0 24aa
0000f1 2499
0000f2 2488                      mul31:	CLR4	c3,c2,c1,c0
0000f3 ff60
0000f4 c003
0000f5 0e92
0000f6 1ea3
0000f7 1eb4
0000f8 94b7
0000f9 94a7
0000fa 9497
0000fb 9487                      	M31	0
0000fc ff61
0000fd c003
0000fe 0e92
0000ff 1ea3
000100 1eb4
000101 94b7
000102 94a7
000103 9497
000104 9487                      	M31	1
000105 ff62
000106 c003
000107 0e92
000108 1ea3
000109 1eb4
00010a 94b7
00010b 94a7
00010c 9497
00010d 9487                      	M31	2
00010e ff63
00010f c003
000110 0e92
000111 1ea3
000112 1eb4
000113 94b7
000114 94a7
000115 9497
000116 9487                      	M31	3
000117 ff64
000118 c003
000119 0e92
00011a 1ea3
00011b 1eb4
00011c 94b7
00011d 94a7
00011e 9497
00011f 9487                      	M31	4
000120 ff65
000121 c003
000122 0e92
000123 1ea3
000124 1eb4
000125 94b7
000126 94a7
000127 9497
000128 9487                      	M31	5
000129 ff66
00012a c003
00012b 0e92
00012c 1ea3
00012d 1eb4
00012e 94b7
00012f 94a7
000130 9497
000131 9487                      	M31	6
000132 ff67
000133 c003
000134 0e92
000135 1ea3
000136 1eb4
000137 94b7
000138 94a7
000139 9497
00013a 9487                      	M31	7
00013b 9508                      	ret	
                                 
                                 .macro	M32
                                 	sbrs	b0,@0
                                 	rjmp	PC+5
                                 	add	c1,a0
                                 	adc	c2,a1
                                 	adc	c3,a2
                                 	adc	d0,r0
                                 	sbrs	b1,@0
                                 	rjmp	PC+4
                                 	add	c2,a0
                                 	adc	c3,a1
                                 	adc	d0,a2
                                 	ror	d0
                                 	ror	c3
                                 	ror	c2
                                 	ror	c1
                                 	ror	c0
                                 .endmacro
00013c 18cc
00013d 24bb
00013e 24aa
00013f 2499
000140 2488
000141 2400                      mul32:	CLR6	d0,c3,c2,c1,c0,r0
000142 ff60
000143 c004
000144 0e92
000145 1ea3
000146 1eb4
000147 1cc0
000148 ff70
000149 c003
00014a 0ea2
00014b 1eb3
00014c 1ec4
00014d 94c7
00014e 94b7
00014f 94a7
000150 9497
000151 9487                      	M32	0
000152 ff61
000153 c004
000154 0e92
000155 1ea3
000156 1eb4
000157 1cc0
000158 ff71
000159 c003
00015a 0ea2
00015b 1eb3
00015c 1ec4
00015d 94c7
00015e 94b7
00015f 94a7
000160 9497
000161 9487                      	M32	1
000162 ff62
000163 c004
000164 0e92
000165 1ea3
000166 1eb4
000167 1cc0
000168 ff72
000169 c003
00016a 0ea2
00016b 1eb3
00016c 1ec4
00016d 94c7
00016e 94b7
00016f 94a7
000170 9497
000171 9487                      	M32	2
000172 ff63
000173 c004
000174 0e92
000175 1ea3
000176 1eb4
000177 1cc0
000178 ff73
000179 c003
00017a 0ea2
00017b 1eb3
00017c 1ec4
00017d 94c7
00017e 94b7
00017f 94a7
000180 9497
000181 9487                      	M32	3
000182 ff64
000183 c004
000184 0e92
000185 1ea3
000186 1eb4
000187 1cc0
000188 ff74
000189 c003
00018a 0ea2
00018b 1eb3
00018c 1ec4
00018d 94c7
00018e 94b7
00018f 94a7
000190 9497
000191 9487                      	M32	4
000192 ff65
000193 c004
000194 0e92
000195 1ea3
000196 1eb4
000197 1cc0
000198 ff75
000199 c003
00019a 0ea2
00019b 1eb3
00019c 1ec4
00019d 94c7
00019e 94b7
00019f 94a7
0001a0 9497
0001a1 9487                      	M32	5
0001a2 ff66
0001a3 c004
0001a4 0e92
0001a5 1ea3
0001a6 1eb4
0001a7 1cc0
0001a8 ff76
0001a9 c003
0001aa 0ea2
0001ab 1eb3
0001ac 1ec4
0001ad 94c7
0001ae 94b7
0001af 94a7
0001b0 9497
0001b1 9487                      	M32	6
0001b2 ff67
0001b3 c004
0001b4 0e92
0001b5 1ea3
0001b6 1eb4
0001b7 1cc0
0001b8 ff77
0001b9 c003
0001ba 0ea2
0001bb 1eb3
0001bc 1ec4
0001bd 94c7
0001be 94b7
0001bf 94a7
0001c0 9497
0001c1 9487                      	M32	7
0001c2 9508                      	ret
                                 
                                 .macro	M33
                                 	sbrs	b0,@0
                                 	rjmp	PC+5
                                 	add	c1,a0
                                 	adc	c2,a1
                                 	adc	c3,a2
                                 	adc	d0,r0
                                 	adc	d1,r0
                                 	sbrs	b1,@0
                                 	rjmp	PC+4
                                 	add	c2,a0
                                 	adc	c3,a1
                                 	adc	d0,a2
                                 	adc	d1,r0
                                 	sbrs	b2,@0
                                 	rjmp	PC+4
                                 	add	c3,a0
                                 	adc	c0,a1
                                 	adc	d1,a2
                                 	ror	d1
                                 	ror	d0
                                 	ror	c3
                                 	ror	c2
                                 	ror	c1
                                 	ror	c0
                                 .endmacro
0001c3 18dd
0001c4 24cc
0001c5 24bb
0001c6 24aa
0001c7 2499
0001c8 2488
0001c9 2400                      mul33:	CLR7	d1,d0,c3,c2,c1,c0,r0
0001ca ff60
0001cb c004
0001cc 0e92
0001cd 1ea3
0001ce 1eb4
0001cf 1cc0
0001d0 1cd0
0001d1 ff70
0001d2 c003
0001d3 0ea2
0001d4 1eb3
0001d5 1ec4
0001d6 1cd0
0001d7 ff80
0001d8 c003
0001d9 0eb2
0001da 1e83
0001db 1ed4
0001dc 94d7
0001dd 94c7
0001de 94b7
0001df 94a7
0001e0 9497
0001e1 9487                      	M33	0
0001e2 ff61
0001e3 c004
0001e4 0e92
0001e5 1ea3
0001e6 1eb4
0001e7 1cc0
0001e8 1cd0
0001e9 ff71
0001ea c003
0001eb 0ea2
0001ec 1eb3
0001ed 1ec4
0001ee 1cd0
0001ef ff81
0001f0 c003
0001f1 0eb2
0001f2 1e83
0001f3 1ed4
0001f4 94d7
0001f5 94c7
0001f6 94b7
0001f7 94a7
0001f8 9497
0001f9 9487                      	M33	1
0001fa ff62
0001fb c004
0001fc 0e92
0001fd 1ea3
0001fe 1eb4
0001ff 1cc0
000200 1cd0
000201 ff72
000202 c003
000203 0ea2
000204 1eb3
000205 1ec4
000206 1cd0
000207 ff82
000208 c003
000209 0eb2
00020a 1e83
00020b 1ed4
00020c 94d7
00020d 94c7
00020e 94b7
00020f 94a7
000210 9497
000211 9487                      	M33	2
000212 ff63
000213 c004
000214 0e92
000215 1ea3
000216 1eb4
000217 1cc0
000218 1cd0
000219 ff73
00021a c003
00021b 0ea2
00021c 1eb3
00021d 1ec4
00021e 1cd0
00021f ff83
000220 c003
000221 0eb2
000222 1e83
000223 1ed4
000224 94d7
000225 94c7
000226 94b7
000227 94a7
000228 9497
000229 9487                      	M33	3
00022a ff64
00022b c004
00022c 0e92
00022d 1ea3
00022e 1eb4
00022f 1cc0
000230 1cd0
000231 ff74
000232 c003
000233 0ea2
000234 1eb3
000235 1ec4
000236 1cd0
000237 ff84
000238 c003
000239 0eb2
00023a 1e83
00023b 1ed4
00023c 94d7
00023d 94c7
00023e 94b7
00023f 94a7
000240 9497
000241 9487                      	M33	4
000242 ff65
000243 c004
000244 0e92
000245 1ea3
000246 1eb4
000247 1cc0
000248 1cd0
000249 ff75
00024a c003
00024b 0ea2
00024c 1eb3
00024d 1ec4
00024e 1cd0
00024f ff85
000250 c003
000251 0eb2
000252 1e83
000253 1ed4
000254 94d7
000255 94c7
000256 94b7
000257 94a7
000258 9497
000259 9487                      	M33	5
00025a ff66
00025b c004
00025c 0e92
00025d 1ea3
00025e 1eb4
00025f 1cc0
000260 1cd0
000261 ff76
000262 c003
000263 0ea2
000264 1eb3
000265 1ec4
000266 1cd0
000267 ff86
000268 c003
000269 0eb2
00026a 1e83
00026b 1ed4
00026c 94d7
00026d 94c7
00026e 94b7
00026f 94a7
000270 9497
000271 9487                      	M33	6
000272 ff67
000273 c004
000274 0e92
000275 1ea3
000276 1eb4
000277 1cc0
000278 1cd0
000279 ff77
00027a c003
00027b 0ea2
00027c 1eb3
00027d 1ec4
00027e 1cd0
00027f ff87
000280 c003
000281 0eb2
000282 1e83
000283 1ed4
000284 94d7
000285 94c7
000286 94b7
000287 94a7
000288 9497
000289 9487                      	M33	7
00028a 9508                      	ret
                                 
                                 .macro	M44
                                 	sbrs	b0,@0
                                 	rjmp	PC+8
                                 	add	c1,a0
                                 	adc	c2,a1
                                 	adc	c3,a2
                                 	adc	d0,a3
                                 	adc	d1,r0
                                 	adc	d2,r0
                                 	adc	d3,r0
                                 	
                                 	sbrs	b1,@0
                                 	rjmp	PC+7
                                 	add	c2,a0
                                 	adc	c3,a1
                                 	adc	d0,a2
                                 	adc	d1,a3
                                 	adc	d2,r0
                                 	adc	d3,r0	
                                 	
                                 	sbrs	b2,@0
                                 	rjmp	PC+6
                                 	add	c3,a0
                                 	adc	d0,a1
                                 	adc	d1,a2
                                 	adc	d2,a3
                                 	adc	d3,r0
                                 	
                                 	sbrs	b3,@0
                                 	rjmp	PC+5
                                 	add	d0,a0
                                 	adc	d1,a1
                                 	adc	d2,a2
                                 	adc	d3,a3
                                 	
                                 	ror	d3
                                 	ror	d2
                                 	ror	d1
                                 	ror	d0
                                 	ror	c3
                                 	ror	c2
                                 	ror	c1
                                 	ror	c0
                                 .endmacro
00028b 18ff
00028c 24ee
00028d 24dd
00028e 24cc
00028f 24bb
000290 24aa
000291 2499
000292 2488
000293 2400                      mul44:	CLR9	d3,d2,d1,d0,c3,c2,c1,c0,r0	
000294 ff60
000295 c007
000296 0e92
000297 1ea3
000298 1eb4
000299 1ec5
00029a 1cd0
00029b 1ce0
00029c 1cf0
00029d ff70
00029e c006
00029f 0ea2
0002a0 1eb3
0002a1 1ec4
0002a2 1ed5
0002a3 1ce0
0002a4 1cf0
0002a5 ff80
0002a6 c005
0002a7 0eb2
0002a8 1ec3
0002a9 1ed4
0002aa 1ee5
0002ab 1cf0
0002ac ff90
0002ad c004
0002ae 0ec2
0002af 1ed3
0002b0 1ee4
0002b1 1ef5
0002b2 94f7
0002b3 94e7
0002b4 94d7
0002b5 94c7
0002b6 94b7
0002b7 94a7
0002b8 9497
0002b9 9487                      	M44	0
0002ba ff61
0002bb c007
0002bc 0e92
0002bd 1ea3
0002be 1eb4
0002bf 1ec5
0002c0 1cd0
0002c1 1ce0
0002c2 1cf0
0002c3 ff71
0002c4 c006
0002c5 0ea2
0002c6 1eb3
0002c7 1ec4
0002c8 1ed5
0002c9 1ce0
0002ca 1cf0
0002cb ff81
0002cc c005
0002cd 0eb2
0002ce 1ec3
0002cf 1ed4
0002d0 1ee5
0002d1 1cf0
0002d2 ff91
0002d3 c004
0002d4 0ec2
0002d5 1ed3
0002d6 1ee4
0002d7 1ef5
0002d8 94f7
0002d9 94e7
0002da 94d7
0002db 94c7
0002dc 94b7
0002dd 94a7
0002de 9497
0002df 9487                      	M44	1
0002e0 ff62
0002e1 c007
0002e2 0e92
0002e3 1ea3
0002e4 1eb4
0002e5 1ec5
0002e6 1cd0
0002e7 1ce0
0002e8 1cf0
0002e9 ff72
0002ea c006
0002eb 0ea2
0002ec 1eb3
0002ed 1ec4
0002ee 1ed5
0002ef 1ce0
0002f0 1cf0
0002f1 ff82
0002f2 c005
0002f3 0eb2
0002f4 1ec3
0002f5 1ed4
0002f6 1ee5
0002f7 1cf0
0002f8 ff92
0002f9 c004
0002fa 0ec2
0002fb 1ed3
0002fc 1ee4
0002fd 1ef5
0002fe 94f7
0002ff 94e7
000300 94d7
000301 94c7
000302 94b7
000303 94a7
000304 9497
000305 9487                      	M44	2
000306 ff63
000307 c007
000308 0e92
000309 1ea3
00030a 1eb4
00030b 1ec5
00030c 1cd0
00030d 1ce0
00030e 1cf0
00030f ff73
000310 c006
000311 0ea2
000312 1eb3
000313 1ec4
000314 1ed5
000315 1ce0
000316 1cf0
000317 ff83
000318 c005
000319 0eb2
00031a 1ec3
00031b 1ed4
00031c 1ee5
00031d 1cf0
00031e ff93
00031f c004
000320 0ec2
000321 1ed3
000322 1ee4
000323 1ef5
000324 94f7
000325 94e7
000326 94d7
000327 94c7
000328 94b7
000329 94a7
00032a 9497
00032b 9487                      	M44	3
00032c ff64
00032d c007
00032e 0e92
00032f 1ea3
000330 1eb4
000331 1ec5
000332 1cd0
000333 1ce0
000334 1cf0
000335 ff74
000336 c006
000337 0ea2
000338 1eb3
000339 1ec4
00033a 1ed5
00033b 1ce0
00033c 1cf0
00033d ff84
00033e c005
00033f 0eb2
000340 1ec3
000341 1ed4
000342 1ee5
000343 1cf0
000344 ff94
000345 c004
000346 0ec2
000347 1ed3
000348 1ee4
000349 1ef5
00034a 94f7
00034b 94e7
00034c 94d7
00034d 94c7
00034e 94b7
00034f 94a7
000350 9497
000351 9487                      	M44	4
000352 ff65
000353 c007
000354 0e92
000355 1ea3
000356 1eb4
000357 1ec5
000358 1cd0
000359 1ce0
00035a 1cf0
00035b ff75
00035c c006
00035d 0ea2
00035e 1eb3
00035f 1ec4
000360 1ed5
000361 1ce0
000362 1cf0
000363 ff85
000364 c005
000365 0eb2
000366 1ec3
000367 1ed4
000368 1ee5
000369 1cf0
00036a ff95
00036b c004
00036c 0ec2
00036d 1ed3
00036e 1ee4
00036f 1ef5
000370 94f7
000371 94e7
000372 94d7
000373 94c7
000374 94b7
000375 94a7
000376 9497
000377 9487                      	M44	5
000378 ff66
000379 c007
00037a 0e92
00037b 1ea3
00037c 1eb4
00037d 1ec5
00037e 1cd0
00037f 1ce0
000380 1cf0
000381 ff76
000382 c006
000383 0ea2
000384 1eb3
000385 1ec4
000386 1ed5
000387 1ce0
000388 1cf0
000389 ff86
00038a c005
00038b 0eb2
00038c 1ec3
00038d 1ed4
00038e 1ee5
00038f 1cf0
000390 ff96
000391 c004
000392 0ec2
000393 1ed3
000394 1ee4
000395 1ef5
000396 94f7
000397 94e7
000398 94d7
000399 94c7
00039a 94b7
00039b 94a7
00039c 9497
00039d 9487                      	M44	6
00039e ff67
00039f c007
0003a0 0e92
0003a1 1ea3
0003a2 1eb4
0003a3 1ec5
0003a4 1cd0
0003a5 1ce0
0003a6 1cf0
0003a7 ff77
0003a8 c006
0003a9 0ea2
0003aa 1eb3
0003ab 1ec4
0003ac 1ed5
0003ad 1ce0
0003ae 1cf0
0003af ff87
0003b0 c005
0003b1 0eb2
0003b2 1ec3
0003b3 1ed4
0003b4 1ee5
0003b5 1cf0
0003b6 ff97
0003b7 c004
0003b8 0ec2
0003b9 1ed3
0003ba 1ee4
0003bb 1ef5
0003bc 94f7
0003bd 94e7
0003be 94d7
0003bf 94c7
0003c0 94b7
0003c1 94a7
0003c2 9497
0003c3 9487                      	M44	7
0003c4 9508                      	ret
                                 
                                 ; === signed multiplication ===		
0003c5 dc5c                      mul11s: rcall	mul11
0003c6 fd27                      	sbrc	a0,7
0003c7 1a96                      	sub	c1,b0
0003c8 fd67                      	sbrc	b0,7
0003c9 1a92                      	sub	c1,a0
0003ca 9508                      	ret
                                 
0003cb dcb5                      mul22s: rcall	mul22
0003cc ff37                      	sbrs	a1,7
0003cd c002                      	rjmp	PC+3
0003ce 1aa6
0003cf 0ab7                      	SUB2	c3,c2, b1,b0
0003d0 ff77                      	sbrs	b1,7
0003d1 c002                      	rjmp	PC+3	
0003d2 1aa2
0003d3 0ab3                      	SUB2	c3,c2, a1,a0
0003d4 9508                      	ret
                                 
0003d5 dded                      mul33s: rcall	mul33
0003d6 ff47                      	sbrs	a2,7
0003d7 c003                      	rjmp	PC+4
0003d8 1ab6
0003d9 0ac7
0003da 0ad8                      	SUB3	d1,d0,c3, b2,b1,b0
0003db ff87                      	sbrs	b2,7
0003dc c003                      	rjmp	PC+4
0003dd 1ab2
0003de 0ac3
0003df 0ad4                      	SUB3	d1,d0,c3, a2,a1,a0
0003e0 9508                      	ret
                                 
0003e1 dea9                      mul44s: rcall	mul44
0003e2 ff57                      	sbrs	a3,7
0003e3 c004                      	rjmp	PC+5
0003e4 1ac6
0003e5 0ad7
0003e6 0ae8
0003e7 0af9                      	SUB4	d3,d2,d1,d0, b3,b2,b1,b0
0003e8 ff97                      	sbrs	b3,7
0003e9 c004                      	rjmp	PC+5
0003ea 1ac2
0003eb 0ad3
0003ec 0ae4
0003ed 0af5                      	SUB4	d3,d2,d1,d0, a3,a2,a1,a0
0003ee 9508                      	ret
                                 
                                 ; === division ===
                                 .macro	D11
                                 	rol	c0
                                 	rol	d0
                                 	sub	d0,b0	; subtract b from remainder a
                                 	brcc	PC+2
                                 	add	d0,b0	; restore if negative
                                 .endmacro
0003ef 2e82                      div11:	mov	c0,a0	; load a into shift register
0003f0 18cc                      	sub	d0,d0	; clear c1 and carry=0
0003f1 1c88
0003f2 1ccc
0003f3 1ac6
0003f4 f408
0003f5 0ec6                      	D11
0003f6 1c88
0003f7 1ccc
0003f8 1ac6
0003f9 f408
0003fa 0ec6                      	D11	
0003fb 1c88
0003fc 1ccc
0003fd 1ac6
0003fe f408
0003ff 0ec6                      	D11
000400 1c88
000401 1ccc
000402 1ac6
000403 f408
000404 0ec6                      	D11	
000405 1c88
000406 1ccc
000407 1ac6
000408 f408
000409 0ec6                      	D11
00040a 1c88
00040b 1ccc
00040c 1ac6
00040d f408
00040e 0ec6                      	D11	
00040f 1c88
000410 1ccc
000411 1ac6
000412 f408
000413 0ec6                      	D11
000414 1c88
000415 1ccc
000416 1ac6
000417 f408
000418 0ec6                      	D11
000419 1c88                      	rol	c0
00041a 9480                      	com	c0	; invert the bits
00041b 9508                      	ret
                                 
                                 .macro	D22
                                 	rol	c0
                                 	rol	c1
                                 	rol	d0
                                 	rol	d1
                                 	sub	d0,b0	; subtract b from a
                                 	sbc	d1,b1
                                 	brcc	PC+3
                                 	add	d0,b0	; restore if negative
                                 	adc	d1,b1
                                 .endmacro
00041c 2e82
00041d 2e93                      div22:	MOV2	c1,c0, a1,a0 ; load a into shift register
00041e 18dd
00041f 24cc                      	CLR2	d1,d0
000420 1c88
000421 1c99
000422 1ccc
000423 1cdd
000424 1ac6
000425 0ad7
000426 f410
000427 0ec6
000428 1ed7                      	D22
000429 1c88
00042a 1c99
00042b 1ccc
00042c 1cdd
00042d 1ac6
00042e 0ad7
00042f f410
000430 0ec6
000431 1ed7                      	D22
000432 1c88
000433 1c99
000434 1ccc
000435 1cdd
000436 1ac6
000437 0ad7
000438 f410
000439 0ec6
00043a 1ed7                      	D22
00043b 1c88
00043c 1c99
00043d 1ccc
00043e 1cdd
00043f 1ac6
000440 0ad7
000441 f410
000442 0ec6
000443 1ed7                      	D22
000444 1c88
000445 1c99
000446 1ccc
000447 1cdd
000448 1ac6
000449 0ad7
00044a f410
00044b 0ec6
00044c 1ed7                      	D22
00044d 1c88
00044e 1c99
00044f 1ccc
000450 1cdd
000451 1ac6
000452 0ad7
000453 f410
000454 0ec6
000455 1ed7                      	D22
000456 1c88
000457 1c99
000458 1ccc
000459 1cdd
00045a 1ac6
00045b 0ad7
00045c f410
00045d 0ec6
00045e 1ed7                      	D22
00045f 1c88
000460 1c99
000461 1ccc
000462 1cdd
000463 1ac6
000464 0ad7
000465 f410
000466 0ec6
000467 1ed7                      	D22
000468 1c88
000469 1c99
00046a 1ccc
00046b 1cdd
00046c 1ac6
00046d 0ad7
00046e f410
00046f 0ec6
000470 1ed7                      	D22
000471 1c88
000472 1c99
000473 1ccc
000474 1cdd
000475 1ac6
000476 0ad7
000477 f410
000478 0ec6
000479 1ed7                      	D22
00047a 1c88
00047b 1c99
00047c 1ccc
00047d 1cdd
00047e 1ac6
00047f 0ad7
000480 f410
000481 0ec6
000482 1ed7                      	D22
000483 1c88
000484 1c99
000485 1ccc
000486 1cdd
000487 1ac6
000488 0ad7
000489 f410
00048a 0ec6
00048b 1ed7                      	D22
00048c 1c88
00048d 1c99
00048e 1ccc
00048f 1cdd
000490 1ac6
000491 0ad7
000492 f410
000493 0ec6
000494 1ed7                      	D22
000495 1c88
000496 1c99
000497 1ccc
000498 1cdd
000499 1ac6
00049a 0ad7
00049b f410
00049c 0ec6
00049d 1ed7                      	D22
00049e 1c88
00049f 1c99
0004a0 1ccc
0004a1 1cdd
0004a2 1ac6
0004a3 0ad7
0004a4 f410
0004a5 0ec6
0004a6 1ed7                      	D22
0004a7 1c88
0004a8 1c99
0004a9 1ccc
0004aa 1cdd
0004ab 1ac6
0004ac 0ad7
0004ad f410
0004ae 0ec6
0004af 1ed7                      	D22
0004b0 1c88
0004b1 1c99                      	ROL2	c1,c0	; last shift
0004b2 9490
0004b3 9480                      	COM2	c1,c0	; invert the bits
                                 .include	"Libraries\lcd.asm"			; include LCD driver routines
0004b4 9508                      
                                 ; purpose  LCD HD44780U library
                                 ; ATmega 128 and Atmel Studio 7.0 compliant
                                 
                                 ; === definitions ===
                                 .equ	LCD_IR	= 0x8000	; address LCD instruction reg
                                 .equ	LCD_DR	= 0xc000	; address LCD data register
                                 
                                 ; === subroutines ===
                                 LCD_wr_ir:
                                 ; in	w (byte to write to LCD IR)
0004b5 9030 8000                 	lds	u, LCD_IR		; read IR to check busy flag  (bit7)
0004b7 fc37
0004b8 cffc                      	JB1	u,7,LCD_wr_ir	; Jump if Bit=1 (still busy)
0004b9 d003                      	rcall	lcd_4us		; delay to increment DRAM addr counter
0004ba 9300 8000                 	sts	LCD_IR, w		; store w in IR
0004bc 9508                      	ret
                                 	
                                 lcd_4us:
0004bd d000                      	rcall	lcd_2us		; recursive call		
                                 lcd_2us:
0004be 0000                      	nop					; rcall(3) + nop(1) + ret(4) = 8 cycles (2us)
0004bf 9508                      	ret
                                 
                                 LCD:
                                 LCD_putc:
0004c0 302d
0004c1 f169                      	JK	a0,CR,LCD_cr	; Jump if a0=CR
0004c2 302a
0004c3 f1a9                      	JK	a0,LF,LCD_lf	; Jump if a0=LF
                                 LCD_wr_dr:
                                 ; in	a0 (byte to write to LCD DR)
0004c4 9100 8000                 	lds	w, LCD_IR		; read IR to check busy flag  (bit7)
0004c6 fd07
0004c7 cffc                      	JB1	w,7,LCD_wr_dr	; Jump if Bit=1 (still busy)
0004c8 dff4                      	rcall	lcd_4us		; delay to increment DRAM addr counter
0004c9 9320 c000                 	sts	LCD_DR, a0		; store a0 in DR
0004cb 9508                      	ret	
                                 	
0004cc e001
0004cd cfe7                      LCD_clear:		JW	LCD_wr_ir, 0b00000001		; clear display
0004ce e002
0004cf cfe5                      LCD_home:		JW	LCD_wr_ir, 0b00000010		; return home
0004d0 e100
0004d1 cfe3                      LCD_cursor_left:	JW	LCD_wr_ir, 0b00010000	; move cursor to left
0004d2 e104
0004d3 cfe1                      LCD_cursor_right:	JW	LCD_wr_ir, 0b00010100	; move cursor to right
0004d4 e108
0004d5 cfdf                      LCD_display_left:	JW	LCD_wr_ir, 0b00011000	; shifts display to left
0004d6 e10c
0004d7 cfdd                      LCD_display_right:	JW	LCD_wr_ir, 0b00011100	; shifts display to right
0004d8 e00d
0004d9 cfdb                      LCD_blink_on:		JW	LCD_wr_ir, 0b00001101	; Display=1,Cursor=0,Blink=1
0004da e00c
0004db cfd9                      LCD_blink_off:		JW	LCD_wr_ir, 0b00001100	; Display=1,Cursor=0,Blink=0
0004dc e00e
0004dd cfd7                      LCD_cursor_on:		JW	LCD_wr_ir, 0b00001110	; Display=1,Cursor=1,Blink=0
0004de e00c
0004df cfd5                      LCD_cursor_off:		JW	LCD_wr_ir, 0b00001100	; Display=1,Cursor=0,Blink=0
                                 		
                                 LCD_init:
0004e0 b705                      	in	w,MCUCR					; enable access to ext. SRAM
0004e1 6c00                      	sbr	w,(1<<SRE)+(1<<SRW10)
0004e2 bf05                      	out	MCUCR,w
0004e3 e001
0004e4 dfd0                      	CW	LCD_wr_ir, 0b00000001	; clear display
0004e5 e006
0004e6 dfce                      	CW	LCD_wr_ir, 0b00000110	; entry mode set (Inc=1, Shift=0)
0004e7 e00c
0004e8 dfcc                      	CW	LCD_wr_ir, 0b00001100	; Display=1,Cursor=0,Blink=0	
0004e9 e308
0004ea dfca                      	CW	LCD_wr_ir, 0b00111000	; 8bits=1, 2lines=1, 5x8dots=0
0004eb 9508                      	ret
                                 
                                 LCD_pos:
                                 ; in	a0 = position (0x00..0x0f first line, 0x40..0x4f second line)
0004ec 2f02                      	mov	w,a0
0004ed 6800                      	ori	w,0b10000000
0004ee cfc6                      	rjmp	LCD_wr_ir
                                 
                                 LCD_cr:
                                 ; moving the cursor to the beginning of the line (carriage return)
0004ef 9100 8000                 	lds	w, LCD_IR			; read IR to check busy flag  (bit7)
0004f1 fd07
0004f2 cffc                      	JB1	w,7,LCD_cr			; Jump if Bit=1 (still busy)
0004f3 7400                      	andi	w,0b01000000	; keep bit6 (begin of line 1/2)
0004f4 6800                      	ori	w,0b10000000		; write address command
0004f5 dfc7                      	rcall	lcd_4us			; delay to increment DRAM addr counter
0004f6 9300 8000                 	sts	LCD_IR,w			; store in IR
0004f8 9508                      	ret
                                 
                                 LCD_lf:
                                 ; moving the cursor to the beginning of the line 2 (line feed)
0004f9 932f                      	push	a0				; safeguard a0
0004fa e420                      	ldi	a0,$40				; load position $40 (begin of line 2)
0004fb dff0                      	rcall	LCD_pos			; set cursor position
0004fc 912f                      	pop	a0					; restore a0
                                 .include	"Libraries\wire1.asm"		; include Dallas 1-wire(R) routines
0004fd 9508                      
                                 ; purpose Dallas 1-wire(R) interface library
                                 
                                 ; === definitions ===
                                 .equ	DQ_port	= PORTD
                                 .equ	DQ_pin	= DQ
                                 
                                 .equ	DS18B20		= 0x28
                                 
                                 .equ	readROM		= 0x33
                                 .equ	matchROM	= 0x55
                                 .equ	skipROM		= 0xcc
                                 .equ	searchROM	= 0xf0
                                 .equ	alarmSearch	= 0xec
                                 
                                 .equ	writeScratchpad	= 0x4e
                                 .equ	readScratchpad	= 0xbe
                                 .equ	copyScratchpad	= 0x48
                                 .equ	convertT	= 0x44
                                 .equ	recallE2	= 0xb8
                                 .equ	readPowerSupply	= 0xb4
                                 
                                 ; === routines ===
                                 
                                 .macro	WIRE1	; t0,t1,t2
                                 	sbi	DQ_port-1,DQ_pin	; pull DQ low (DDR=1 output)
                                 	ldi	w,(@0+1)/2	
                                 	rcall	wire1_wait		; wait low time (t0)
                                 	cbi	DQ_port-1,DQ_pin	; release DQ (DDR=0 input)
                                 	ldi	w,(@1+1)/2	
                                 	rcall	wire1_wait		; wait high time (t1)
                                 	in	w,DQ_port-2			; sample line (PINx=PORTx-2)
                                 	bst	w,DQ_pin			; store result in T
                                 	ldi	w,(@2+1)/2	
                                 	rcall	wire1_wait		; wait separation time (t2)
                                 	ret
                                 	.endmacro	
                                 
                                 wire1_wait:
0004fe 950a                      	dec	w					; loop time 2usec
0004ff 0000                      	nop
000500 0000                      	nop
000501 0000                      	nop
000502 0000                      	nop
000503 0000                      	nop
000504 f7c9                      	brne	wire1_wait
000505 9508                      	ret
                                 
                                 wire1_init:
000506 9895                      	cbi	DQ_port,  DQ_pin	; PORT=0 low (for pull-down)
000507 988d                      	cbi	DQ_port-1,DQ_pin	; DDR=0 (input hi Z)
000508 9508                      	ret
                                 	
000509 9a8d
00050a ef00
00050b dff2
00050c 988d
00050d e203
00050e dfef
00050f b300
000510 fb05
000511 ec0d
000512 dfeb
000513 9508                      wire1_reset:	WIRE1	480,70,410
000514 9a8d
000515 e10c
000516 dfe7
000517 988d
000518 e002
000519 dfe4
00051a b300
00051b fb05
00051c e001
00051d dfe0
00051e 9508                      wire1_write0:	WIRE1	56,4,1
00051f 9a8d
000520 e001
000521 dfdc
000522 988d
000523 e10e
000524 dfd9
000525 b300
000526 fb05
000527 e001
000528 dfd5
000529 9508                      wire1_write1:	WIRE1	1,59,1
00052a 9a8d
00052b e001
00052c dfd1
00052d 988d
00052e e007
00052f dfce
000530 b300
000531 fb05
000532 e107
000533 dfca
000534 9508                      wire1_read1:	WIRE1	1,14,45
                                 	
                                 wire1_write:
000535 933f                      	push	a1
000536 e038                      	ldi	a1,8
000537 9527                      	ror	a0
                                 
000538 f410                      	brcc	PC+3				; if C=1 then wire1, else wire0
000539 dfe5                      	rcall	wire1_write1
00053a c001                      	rjmp	PC+2
00053b dfd8                      	rcall	wire1_write0
                                 
00053c 953a
00053d f7c9                      	DJNZ	a1,wire1_write+2	; dec and jump if not zero
00053e 913f                      	pop	a1	
00053f 9508                      	ret
                                 
                                 wire1_read:
000540 933f                      	push	a1
000541 e038                      	ldi	a1,8
000542 9527                      	ror	a0
000543 dfe6                      	rcall	wire1_read1			; returns result in T
000544 f927                      	bld	a0,7					; move T to MSb
000545 953a
000546 f7d9                      	DJNZ	a1,wire1_read+2		; dec and jump if not zero
000547 913f                      	pop	a1	
000548 9508                      	ret
                                 	
                                 wire1_crc:
000549 e109                      	ldi	w,0b00011001
00054a e048                      	ldi	a2,8
00054b 9527                      crc1:	ror	a0
00054c f408                      	brcc	PC+2
00054d 2730                      	eor	a1,w
00054e fb30                      	bst	a1,0
00054f 9537                      	ror	a1
000550 f937                      	bld	a1,7
000551 954a
000552 f7c1                      	DJNZ	a2,crc1
                                 .include	"Libraries\printf.asm"		; include formatted printing routines
000553 9508                      
                                 ; purpose library, formatted output generation
                                 ; author (c) R.Holzer (adapted MICRO210/EE208 A.Schmid)
                                 ; v2019.02 20180821 AxS supports SRAM input from 0x0260
                                 ;					through 0x02ff that should be reserved
                                 
                                 ; === description ===
                                 ; 
                                 ; The program "printf" interprets and prints formatted strings.
                                 ; The special formatting characters regognized are:
                                 ;
                                 ; FDEC	decimal number
                                 ; FHEX	hexadecimal number
                                 ; FBIN	binary number
                                 ; FFRAC	fixed fraction number
                                 ; FCHAR	single ASCII character
                                 ; FSTR	zero-terminated ASCII string
                                 ;	
                                 ; The special formatting characters are distinguished from normal 
                                 ; ASCII characters by having their bit7 set to 1.
                                 ;
                                 ; Signification of bit fields:
                                 ;
                                 ; b 	bytes		1..4 b bytes		2
                                 ; s 	sign		0(unsigned), 1(signed)	1
                                 ; i		integer digits	
                                 ; e 	base		2,,36			5
                                 ; dp 	dec. point	0..32			5
                                 ; $if	i=integer digits,  0=all digits,  1..15 digits 
                                 ;		f=fraction digits, 0=no fraction, 1..15 digits
                                 ;
                                 ; Formatting characters must be followed by an SRAM address (0..ff)
                                 ; that determines the origin of variables that must be printed (if any)
                                 ; FBIN,	sram
                                 ; FHEX,	sram
                                 ; FDEC,	sram
                                 ; FCHAR,sram
                                 ; FSTR,	sram
                                 ;
                                 ; The address 'sram' is a 1-byte constant. It addresses
                                 ; 	 0..1f	registers r0..r31, 
                                 ; 	20..3f	i/o ports, (need to be addressed with an offset of $20)
                                 ;	0x0260..0x02ff	SRAM
                                 ; Variables can be located into register and I/0s, and can also
                                 ; be stored into data SRAM at locations 0x0200 through 0x02ff. Any
                                 ; sram address higher than 0x0060 is assumed to be at (0x0260+address)
                                 ; from automatic address detection in _printf_formatted: and subsequent
                                 ; assignment to xh; xl keeps its value. Consequently, variables that are
                                 ; to be stored into SRAM and further printed by fprint must reside at
                                 ; 0x0200 up to 0x02ff, and must be addressed using a label. Usage: see
                                 ; file string1.asm, for example.
                                 
                                 ; The FFRAC formatting character must be followed by 
                                 ;	ONE sram address and 
                                 ;	TWO more formatting characters
                                 ; FFRAC,sram,dp,$if
                                 
                                 ; dp	decimal point position, 0=right, 32=left
                                 ; $if	format i.f, i=integer digits, f=fraction digits
                                 
                                 ; The special formatting characters use the following coding
                                 ;
                                 ; FDEC	11bb'iiis	i=0 all digits, i=1-7 digits
                                 ; FBIN	101i'iiis	i=0 8 digits,	i=1-7 digits
                                 ; FHEX	1001'iiis	i=0 8 digits,	i=1-7 digits
                                 ; FFRAC	1000'1bbs
                                 ; FCHAR	1000'0100
                                 ; FSTR	1000'0101
                                 ; FREP	1000'0110
                                 ; FFUNC	1000'0111
                                 ;	1000'0010
                                 ;	1000'0011
                                 ; FESC	1000'0000
                                 
                                 ; examples
                                 ; formatting string			printing
                                 ; "a=",FDEC,a,0				1-byte variable a, unsigned decimal
                                 ; "a=",FDEC2,a,0			2-byte variable a (a1,a0), unsigend
                                 ; "a=",FDEC|FSIGN,a,0		1-byte variable 1, signed decimal
                                 ; "n=",FBIN,PIND+$20,0		i/o port, binary, notice offset of $20
                                 ; "f=",FFRAC4|FSIGN,a,16,$88,0	4-byte signed fixed-point fraction
                                 ;				dec.point at 16, 8 int.digits, 8 frac.digits	
                                 ; "f=",FFRAC2,a,16,$18,0		2-byte unsigned fixed-point fraction
                                 ;				dec.point at 16, 1 int.digits, 8 frac.digits	
                                 ; "a=",FDEC|FDIG5|FSIGN,a,0	1-byte variable, 5-digit, decimal, signed
                                 ; "a=",FDEC|FDIG5,a,0		1-byte variable, 5-digit, decimal, unsigned
                                 
                                 ; === registers modified ===
                                 ; e0,e1	used to transmit address of putc routine
                                 ; zh,zl	used as pointer to prog-memory
                                 
                                 ; === constants ==============================================
                                 
                                 .equ	FDEC	= 0b11000000	; 1-byte variable
                                 .equ	FDEC2	= 0b11010000	; 2-byte variable
                                 .equ	FDEC3	= 0b11100000	; 3-byte variable
                                 .equ	FDEC4	= 0b11110000	; 4-byte variable
                                 
                                 .equ	FBIN	= 0b10100000
                                 .equ	FHEX	= 0b10010100	; 1-byte variable
                                 .equ	FHEX2	= 0b10011000	; 2-byte variable
                                 .equ	FHEX3	= 0b10011100	; 3-byte variable
                                 .equ	FHEX4	= 0b10010000	; 4-byte variable
                                 
                                 .equ	FFRAC	= 0b10001000	; 1-byte variable
                                 .equ	FFRAC2	= 0b10001010	; 2-byte variable
                                 .equ	FFRAC3	= 0b10001100	; 3-byte variable
                                 .equ	FFRAC4	= 0b10001110	; 4-byte variable
                                 
                                 .equ	FCHAR	= 0b10000100
                                 .equ	FSTR	= 0b10000101
                                 
                                 .equ	FSIGN	= 0b00000001
                                 
                                 .equ	FDIG1	= 1<<1
                                 .equ	FDIG2	= 2<<1
                                 .equ	FDIG3	= 3<<1	
                                 .equ	FDIG4	= 4<<1
                                 .equ	FDIG5	= 5<<1
                                 .equ	FDIG6	= 6<<1
                                 .equ	FDIG7	= 7<<1
                                 
                                 ; ===macro ====================================================
                                 
                                 .macro	PRINTF			; putc function (UART, LCD...)
                                 	ldi	w, low(@0)		; address of "putc" in e1:d0
                                 	mov	e0,w
                                 	ldi	w,high(@0)
                                 	mov	e1,w
                                 	rcall	_printf
                                 	.endmacro
                                 
                                 ; mod	y,z
                                 
                                 
                                 ; === routines ================================================
                                 
                                 _printf:
000554 91ff
000555 91ef                      	POPZ			; z points to begin of "string"
000556 0fee
000557 1fff                      	MUL2Z			; multiply Z by two, (word ptr -> byte ptr)
000558 93af
000559 93bf                      	PUSHX
                                 		
                                 _printf_read:
00055a 95c8                      	lpm				; places prog_mem(Z) into r0 (=c)
00055b 9631                      	adiw	zl,1	; increment pointer Z
00055c 2000                      	tst	r0			; test for ZERO (=end of string)
00055d f021                      	breq	_printf_end	; char=0 indicates end of ascii string
00055e f04a                      	brmi	_printf_formatted ; bit7=1 indicates formatting character
00055f 2d00                      	mov	w,r0
000560 d017                      	rcall	_putw	; display the character
000561 cff8                      	rjmp	_printf_read	; read next character in the string
                                 	
                                 _printf_end:
000562 9631                      	adiw	zl,1	; point to the next character
000563 95f6
000564 95e7                      	DIV2Z			; divide by 2 (byte ptr -> word ptr)
000565 91bf
000566 91af                      	POPX
000567 9409                      	ijmp			; return to instruction after "string"
                                 
                                 _printf_formatted:
                                 
                                 ; FDEC	11bb'iiis
                                 ; FBIN	101i'iiis
                                 ; FHEX	1001'iiis
                                 ; FFRAC	1000'1bbs
                                 ; FCHAR	1000'0100
                                 ; FSTR	1000'0101
                                 
000568 fa00                      	bst	r0,0		; store sign in T
000569 2d00                      	mov	w,r0		; store formatting character in w
00056a 95c8                      	lpm	
00056b 2da0                      	mov	xl,r0		; load x-pointer with SRAM address
00056c 36a0                      	cpi	xl,0x60
00056d f010                      	brlo rio_space
                                 dataram_space:		; variable originates from SRAM memory
00056e e0b2                      	ldi	xh,0x02		;>addresses are limited to 0x0260 through 0x02ff
00056f c001                      	rjmp space_detect_end	;>that enables automatic detection of the origin
                                 rio_space:			; variable originates from reg or I/O space 
000570 27bb                      	clr	xh			; clear high-byte, addresses are 0x0000 through 0x003f (0x005f)
                                 space_detect_end:
000571 9631                       	adiw	zl,1	; increment pointer Z
                                 
                                 ;	JB1	w,6,_putdec
                                 ;	JB1	w,5,_putbin
                                 ;	JB1	w,4,_puthex
                                 ;	JB1	w,3,_putfrac
000572 3804
000573 f079                      	JK	w,FCHAR,_putchar
000574 3805
000575 f081                      	JK	w,FSTR ,_putstr
000576 c015                      	rjmp	_putnum
                                 	
000577 cfe2                      	rjmp	_printf_read	
                                 
                                 ; === putc (put character) ===============================
                                 ; in	w	character to put
                                 ;	e1,e0	address of output routine (UART, LCD putc)
                                 _putw:
000578 932f
000579 93ff
00057a 93ef                      	PUSH3	a0,zh,zl
00057b 2de4
00057c 2df5
00057d 2f20                      	MOV3	a0,zh,zl, w,e1,e0
00057e 9509                      	icall			; indirect call to "putc"
00057f 91ef
000580 91ff
000581 912f                      	POP3	a0,zh,zl
000582 9508                      	ret
                                 
                                 ; === putchar (put character) ============================
                                 ; in	x	pointer to character to put
                                 _putchar:
000583 910c                      	ld	w,x
000584 dff3                      	rcall	_putw
000585 cfd4                      	rjmp	_printf_read
                                 	
                                 ; === putstr (put string) ================================
                                 ; in	x	pointer to ascii string
                                 ;	b3,b2	address of output routine (UART, LCD putc)
                                 _putstr:
000586 910d                      	ld	w,x+
000587 2300                      	tst	w
000588 f409                      	brne	PC+2
000589 cfd0                      	rjmp	_printf_read
00058a dfed                      	rcall	_putw
00058b cffa                      	rjmp	_putstr
                                 
                                 ; === putnum (dec/bin/hex/frac) ===========================
                                 ; in	x	pointer to SRAM variable to print
                                 ; 	r0	formatting character
                                 	
                                 _putnum:
00058c 935f
00058d 934f
00058e 933f
00058f 932f                      	PUSH4	a3,a2,a1,a0	; safeguard a
000590 939f
000591 938f
000592 937f
000593 936f                      	PUSH4	b3,b2,b1,b0	; safeguard b	
000594 912d
000595 913d
000596 914d
000597 915d                      	LDX4	a3,a2,a1,a0	; load operand to print into a
                                 
                                 ; FDEC	11bb'iiis
                                 ; FBIN	101i'iiis
                                 ; FHEX	1001'iiis
                                 ; FRACT	1000'1bbs
                                 
000598 fd06
000599 c006                      	JB1	w,6,_putdec
00059a fd05
00059b c00f                      	JB1	w,5,_putbin
00059c fd04
00059d c010                      	JB1	w,4,_puthex
00059e fd03
00059f c019                      	JB1	w,3,_putfrac
                                 
                                 ; FDEC	11bb'iiis
                                 _putdec:
0005a0 e06a                      	ldi	b0,10		; b0 = base (10)
                                 
0005a1 2f70                      	mov	b1,w
0005a2 9576                      	lsr	b1
0005a3 7077                      	andi	b1,0b111	
0005a4 9572                      	swap	b1		; b1 = format 0iii'0000 (integer digits)
0005a5 e080                      	ldi	b2,0		; b2 = dec. point position = 0 (right)
                                 	
0005a6 2f90                      	mov	b3,w
0005a7 9592                      	swap	b3
0005a8 7093                      	andi	b3,0b11
0005a9 9593                      	inc	b3			; b3 = number of bytes (1..4)
0005aa c01a                      	rjmp	_getnum	; get number of digits (iii)
                                 
                                 ; FBIN	101i'iiis	addr
                                 _putbin:	
0005ab e062                      	ldi	b0,2		; b0 = base (2)
0005ac e094                      	ldi	b3,4		; b3 = number of bytes (4)	
0005ad c003                      	rjmp	_getdig	; get number of digits (iii)
                                 
                                 ; FHEX	1001'iiis	addr
                                 _puthex:	
0005ae e160                      	ldi	b0,16		; b0 = base (16)
0005af e094                      	ldi	b3,4		; b3 = number of bytes (4)
0005b0 c000                      	rjmp	_getdig
                                 
                                 _getdig:
0005b1 2f70                      	mov	b1,w
0005b2 9576                      	lsr	b1
0005b3 7077                      	andi	b1,0b111
0005b4 f409                      	brne	PC+2
0005b5 e078                      	ldi	b1,8		; if b1=0 then 8-digits
0005b6 9572                      	swap	b1		; b1 = format 0iii'0000 (integer digits)
0005b7 e080                      	ldi	b2, 0		; b2 = dec. point position = 0 (right)
0005b8 c00c                      	rjmp	_getnum
                                 
                                 ; FFRAC	1000'1bbs	addr	 00dd'dddd, 	iiii'ffff
                                 	
                                 _putfrac:
0005b9 e06a                      	ldi	b0,10		; base=10	
0005ba 95c8                      	lpm
0005bb 2d80                      	mov	b2,r0		; load dec.point position
0005bc 9631                      	adiw	zl,1	; increment char pointer
0005bd 95c8                      	lpm
0005be 2d70                      	mov	b1,r0		; load ii.ff format
0005bf 9631                      	adiw	zl,1	; increment char pointer
                                 	
0005c0 2f90                      	mov	b3,w
0005c1 9595                      	asr	b3
0005c2 7093                      	andi	b3,0b11
0005c3 9593                      	inc	b3			; b3 = number of bytes (1..4)
                                 
0005c4 c000                      	rjmp	_getnum
                                 
                                 _getnum:
                                 ; in 	a	4-byte variable
                                 ; 	b3	number of bytes (1..4)
                                 ;	T	sign, 0=unsigned, 1=signed
                                 
0005c5 3094
0005c6 f081                      	JK	b3,4,_printf_4b
0005c7 3093
0005c8 f051                      	JK	b3,3,_printf_3b
0005c9 3092
0005ca f021                      	JK	b3,2,_printf_2b	
                                 	
                                 _printf_1b:			; sign extension
0005cb 2733                      	clr	a1
0005cc f416                      	brtc	PC+3	; T=1 sign extension
0005cd fd27                      	sbrc	a0,7
0005ce ef3f                      	ldi	a1,0xff
                                 _printf_2b:
0005cf 2744                      	clr	a2
0005d0 f416                      	brtc	PC+3	; T=1 sign extension	
0005d1 fd37                      	sbrc	a1,7
0005d2 ef4f                      	ldi	a2,0xff
                                 _printf_3b:	
0005d3 2755                      	clr	a3
0005d4 f416                      	brtc	PC+3	; T=1 sign extension
0005d5 fd47                      	sbrc	a2,7
0005d6 ef5f                      	ldi	a3,0xff
                                 _printf_4b:
                                 
0005d7 d009                      	rcall	_ftoa		; float to ascii
0005d8 916f
0005d9 917f
0005da 918f
0005db 919f                      	POP4	b3,b2,b1,b0	; restore b
0005dc 912f
0005dd 913f
0005de 914f
0005df 915f                      	POP4	a3,a2,a1,a0	; restore a
                                 	
0005e0 cf79                      	rjmp	_printf_read
                                 
                                 ; ===============================================
                                 ; func	ftoa
                                 ; converts a fixed-point fractional number to an ascii string
                                 ; author (c) Raphael Holzer
                                 ;
                                 ; in	a3-a0	variable to print
                                 ;	b0	base, 2 to 36, but usually decimal (10)
                                 ;	b1	number of digits to print ii.ff
                                 ; 	b2	position of the decimal point (0=right, 32=left)
                                 ;	T	sign (T=0 unsiged, T=1 signed)
                                 
                                 _ftoa:
0005e1 92cf                      	push	d0
0005e2 92bf
0005e3 92af
0005e4 929f
0005e5 928f                      	PUSH4	c3,c2,c1,c0	; c = fraction part, a = integer part
0005e6 18bb
0005e7 24aa
0005e8 2499
0005e9 2488                      	CLR4	c3,c2,c1,c0	; clear fraction part
                                 
0005ea f486                      	brtc	_ftoa_plus	; if T=0 then unsigned
0005eb 94e8                      	clt
0005ec 2355                      	tst	a3				; if MSb(a)=1 then a=-a
0005ed f46a                      	brpl	_ftoa_plus
0005ee 9468                      	set					; T=1 (minus)
0005ef 2377                      	tst	b1
0005f0 f009                      	breq	PC+2		; if b1=0 the print ALL digits
0005f1 5170                      	subi	b1,0x10		; decrease int digits
0005f2 9550
0005f3 9540
0005f4 9530
0005f5 9520
0005f6 ef0f
0005f7 1b20
0005f8 0b30
0005f9 0b40
0005fa 0b50                      	NEG4	a3,a2,a1,a0	; negate a
                                 _ftoa_plus:	
0005fb 2388                      	tst	b2				; b0=0 (only integer part)
0005fc f051                      	breq	_ftoa_int	
                                 _ftoa_shift:	
0005fd 9555
0005fe 9547
0005ff 9537
000600 9527                      	ASR4	a3,a2,a1,a0	; a = integer part	
000601 94b7
000602 94a7
000603 9497
000604 9487                      	ROR4	c3,c2,c1,c0	; c = fraction part
000605 958a
000606 f7b1                      	DJNZ	b2,_ftoa_shift
                                 _ftoa_int:
000607 937f                      	push	b1			; ii.ff (ii=int digits)
000608 9572                      	swap	b1
000609 707f                      	andi	b1,0x0f
                                 	
00060a e20e                      	ldi	w,'.'			; push decimal point
00060b 930f                      	push	w
                                 _ftoa_int1:
00060c d045                      	rcall	_div41		; int=int/10
00060d 2d0c                      	mov	w,d0			; d=reminder
00060e d030                      	rcall	_hex2asc
00060f 930f                      	push	w			; push rem(int/10)
000610 2700
000611 1720
000612 0730
000613 0740
000614 0750                      	TST4	a3,a2,a1,a0	; (int/10)=?
000615 f029                      	breq	_ftoa_space	; (int/10)=0 then finished
000616 2377                      	tst	b1
000617 f3a1                      	breq	_ftoa_int1	; if b1=0 then print ALL int-digits
000618 957a
000619 f791                      	DJNZ	b1,_ftoa_int1
00061a c007                      	rjmp	_ftoa_sign
                                 _ftoa_space:
00061b 2377                      	tst	b1				; if b1=0 then print ALL int-digits
00061c f029                      	breq	_ftoa_sign
00061d 957a                      	dec	b1
00061e f019                      	breq	_ftoa_sign
00061f e200                      	ldi	w,' '			; write spaces
000620 df57                      	rcall	_putw	
000621 cff9                      	rjmp	_ftoa_space
                                 _ftoa_sign:
000622 f416                      	brtc	PC+3		; if T=1 then write 'minus'
000623 e20d                      	ldi	w,'-'
000624 df53                      	rcall	_putw
                                 _ftoa_int3:
000625 910f                      	pop	w
000626 320e                      	cpi	w,'.'
000627 f011                      	breq	PC+3
000628 df4f                      	rcall	_putw
000629 cffb                      	rjmp	_ftoa_int3
                                 
00062a 917f                      	pop	b1				; ii.ff (ff=frac digits)
00062b 707f                      	andi	b1,0x0f
00062c 2377                      	tst	b1
00062d f059                      	breq	_ftoa_end
                                 _ftoa_point:	
00062e df49                      	rcall	_putw		; write decimal point
00062f 2d28
000630 2d39
000631 2d4a
000632 2d5b                      	MOV4	a3,a2,a1,a0, c3,c2,c1,c0		
                                 _ftoa_frac:
000633 d011                      	rcall	_mul41		; d.frac=10*frac
000634 2d0c                      	mov	w,d0
000635 d009                      	rcall	_hex2asc
000636 df41                      	rcall	_putw
000637 957a
000638 f7d1                      	DJNZ	b1,_ftoa_frac
                                 _ftoa_end:
000639 908f
00063a 909f
00063b 90af
00063c 90bf                      	POP4	c3,c2,c1,c0
00063d 90cf                      	pop	d0
00063e 9508                      	ret
                                 
                                 ; === hexadecimal to ascii ===
                                 ; in	w
                                 _hex2asc:
00063f 300a                      	cpi	w,10
000640 f410                      	brsh	PC+3
000641 5d00                      	addi	w,'0'
000642 9508                      	ret
000643 5a09                      	addi	w,('a'-10)
000644 9508                      	ret
                                 
                                 ; === multiply 4byte*1byte ===
                                 ; funct mul41
                                 ; multiplies a3-a0 (4-byte) by b0 (1-byte)
                                 ; author (c) Raphael Holzer, EPFL
                                 ; 
                                 ; in	a3..a0	multiplicand (argument to multiply)
                                 ;	b0	multiplier
                                 ; out	a3..a0	result
                                 ; 	d0	result MSB (byte 4)
                                 ;
000645 24cc                      _mul41:	clr	d0			; clear byte4 of result
000646 e200                      	ldi	w,32			; load bit counter
000647 9488                      __m41:	clc				; clear carry
000648 fd20                      	sbrc	a0,0		; skip addition if LSB=0
000649 0ec6                      	add	d0,b0			; add b to MSB of a
00064a 94c7
00064b 9557
00064c 9547
00064d 9537
00064e 9527                      	ROR5	d0,a3,a2,a1,a0	; shift-right c, LSB (of b) into carry
00064f 950a
000650 f7b1                      	DJNZ	w,__m41		; Decrement and Jump if bit-count Not Zero
000651 9508                      	ret
                                 
                                 ; === divide 4byte/1byte ===
                                 ; func div41
                                 ; in	a0..a3 	divident (argument to divide)
                                 ;	b0 	divider
                                 ; out	a0..a3 	result 
                                 ;	d0	reminder
                                 ;
000652 24cc                      _div41:	clr	d0			; d will contain the remainder
000653 e200                      	ldi	w,32			; load bit counter
000654 1f22
000655 1f33
000656 1f44
000657 1f55
000658 1ccc                      __d41:	ROL5	d0,a3,a2,a1,a0	; shift carry into result c
000659 1ac6                      	sub	d0, b0			; subtract b from remainder
00065a f408                      	brcc	PC+2	
00065b 0ec6                      	add	d0, b0			; restore if remainder became negative
00065c 950a
00065d f7b1                      	DJNZ	w,__d41		; Decrement and Jump if bit-count Not Zero
00065e 1f22
00065f 1f33
000660 1f44
000661 1f55                      	ROL4	a3,a2,a1,a0	; last shift (carry into result c)
000662 9550
000663 9540
000664 9530
000665 9520                      	COM4	a3,a2,a1,a0	; complement result
000666 9508                      	ret
                                 .include	"macro_projet.asm"
                                 
                                 ; various macros we need for the code
                                 
                                 ; --- divide a 2-byte number (@1:@0) by 2 ---
                                 .macro		DIV22B
                                 	bst		@1,7
                                 	lsr		@1
                                 	ror		@0
                                 	bld		@1,7	
                                 .endmacro
                                 
                                 ; --- multiply a 2-byte number (@1:@0) by 2 ---
                                 .macro		MUL22B
                                 	lsl		@0
                                 	rol		@1
                                 .endmacro
                                 
                                 ; --- two's complement of a 2-byte number (@1:@0) ---
                                 .macro		COM2B
                                 	ldi		w, 0xff
                                 	eor		@0, w
                                 	eor		@1, w
                                 	ldi		w, 1
                                 	add		@0, w
                                 	clr		w
                                 	adc		@1, w
                                 .endmacro
                                 
                                 ; --- check if we are in a specific menu ---
                                 .macro CHECK_MENU_LIMIT	
                                 	mov		w, m			;load m in w
                                 	andi	w, 0b00001011	;use a mask to keep only the bits 0,1,3
                                 	cpi		w, 0b00001000	;see if we are in the the correct sub menu
                                 	breq	PC+2			
                                 	jmp		affichage		;we are in the wrong sub menu
                                 .endmacro
                                 
                                 .macro CHECK_MENU_MUSIC
                                 	mov		w, m			;load m in w
                                 	andi	w, 0b00001011	;use a mask to keep only the bits 0,1,3
                                 	cpi		w, 0b00001010	;see if we are in the the correct sub menu
                                 	breq	PC+2			
                                 	jmp		affichage		;we are in the wrong sub menu
                                 
                                 ; routine called to reset 1-wire
                                 temp_reset:
000667 de9e                      	rcall	wire1_init				;init. 1-wire interface
000668 dea0                      	rcall	wire1_reset
000669 eb28
00066a deca                      	CA		wire1_write,recallE2	;recall the th and conf. from EEPROM
                                 
00066b d093                      	rcall	load_t_eeprom
                                 
00066c ef0f
00066d bb07                      	OUTI	DDRB,0xff				; configure portB to output
                                 
00066e 9508                      	ret
                                 
                                 ; routine used to update temperature, needs the motor Futaba S3003 in PORT B
                                 ; changes the value at alarm_addr in the SRAM to indicate if the limits of temp are not respected
                                 ; it changes its 5th bit
                                 update_temp:
00066f de99                      	rcall	wire1_reset				; send a reset pulse
000670 ec2c
000671 dec3                      	CA		wire1_write, skipROM	; skip ROM identification
000672 e424
000673 dec1                      	CA		wire1_write, convertT	; initiate temp conversion
000674 ee0e
000675 2e30
000676 e003
000677 930f
000678 923f
000679 e300
00067a 2e30
00067b e006
00067c 943a
00067d f7f1
00067e 943a
00067f 950a
000680 f7d9
000681 903f
000682 910f
000683 943a
000684 f791
000685 950a
000686 f781                      	WAIT_MS	750						; wait 750 msec
                                 	
000687 de81                      	rcall	wire1_reset				; send a reset pulse
000688 ec2c
000689 deab                      	CA		wire1_write, skipROM
00068a eb2e
00068b dea9                      	CA		wire1_write, readScratchpad	
00068c deb3                      	rcall	wire1_read				; read temperature LSB
00068d 2e82                      	mov		c0,a0
00068e deb1                      	rcall	wire1_read				; read temperature MSB
00068f 2f32                      	mov		a1,a0
000690 2d28                      	mov		a0,c0
000691 2e93                      	mov		c1,a1
                                 
                                 	; do the calculation to get the length of the pulse to send to the motor 
000692 e168                      	ldi		b0, 24
                                 add_loop:
000693 0d28                      	add		a0, c0
000694 1d39                      	adc		a1, c1
000695 5061                      	subi	b0, 1
000696 f7e1                      	brne	add_loop
                                 
000697 fb37
000698 9536
000699 9527
00069a f937                      	DIV22B	a0, a1
                                 
                                 	; get rid of the last 4 digits as we need an integer
00069b fb37
00069c 9536
00069d 9527
00069e f937                      	DIV22B	a0, a1
00069f fb37
0006a0 9536
0006a1 9527
0006a2 f937                      	DIV22B	a0, a1
0006a3 fb37
0006a4 9536
0006a5 9527
0006a6 f937                      	DIV22B	a0, a1
0006a7 fb37
0006a8 9536
0006a9 9527
0006aa f937                      	DIV22B	a0, a1
                                 
0006ab ef0f
0006ac 2720
0006ad 2730
0006ae e001
0006af 0f20
0006b0 2700
0006b1 1f30                      	COM2B	a0, a1
                                 
0006b2 e509                      	ldi		w, low(1625)
0006b3 e016                      	ldi		_w, high(1625)
0006b4 0f20                      	add		a0, w
0006b5 1f31                      	adc		a1, _w
                                 
                                 	; Copy the values in the right registers
0006b6 2f62                      	mov		b0, a0
0006b7 2f73                      	mov		b1, a1
0006b8 e184                      	ldi		b2, 20
                                 
                                 	; To be sure the motor reaches the required position, we repeat the instruction
                                 	; long enough for it to go from 0 to 90
                                 recall_motor:
0006b9 2f26                      	mov		a0, b0
0006ba 2f37                      	mov		a1, b1
0006bb 9ac4                      	P1		PORTB,SERVO1	; pin 4 at 1
                                 loop_motor:
0006bc 5021
0006bd 4030                      	SUBI2	a1,a0,0x1
0006be f7e9                      	brne	loop_motor
                                 
0006bf 98c4                      	P0		PORTB,SERVO1	; pin 4 at 0 after the pulse width is reached
0006c0 e209
0006c1 2e30
0006c2 e609
0006c3 943a
0006c4 f7f1
0006c5 943a
0006c6 950a
0006c7 f7d9                      	WAIT_US	20000
                                 
0006c8 5081                      	subi	b2, 1
0006c9 f779                      	brne	recall_motor	; do another pulse if necessary
                                 
                                 
                                 	; Check if the alarm needs to ring
0006ca de3e                      	rcall	wire1_reset
0006cb ee2c
0006cc de68                      	CA		wire1_write, alarmSearch
0006cd de72                      	rcall	wire1_read
                                 
0006ce e200                      	ldi		w, 0b00100000
0006cf 3f2f                      	cpi		a0, 0xff
0006d0 f009                      	breq	PC+2
0006d1 9300 0204                 	sts		alarm_addr, w
                                 
0006d3 9508                      	ret
                                 
                                 
                                 ; Routine to save the Th and Tl in the EEPROM
                                 ; at addresses : th_eep and tl_eep 
                                 ; from SRAM addresses : th_addr and tl_addr
                                 ; uses the 3rd bit of r6 to determine if th and tl are in C (=0) or in F (=1)
                                 save_t_eeprom:
0006d4 e0b0                      	ldi		xh, high(th_eep)
0006d5 e0a1                      	ldi		xl, low(th_eep)
0006d6 9120 0200                 	lds		a0, th_addr
0006d8 d196                      	rcall	eeprom_store
                                 
0006d9 e0b0                      	ldi		xh, high(tl_eep)
0006da e0a2                      	ldi		xl, low(tl_eep)
0006db 9120 0201                 	lds		a0, tl_addr
0006dd d191                      	rcall	eeprom_store
                                 
0006de fc62                      	sbrc	m,2
0006df c015                      	rjmp	conv_to_c
                                 
0006e0 90c0 0200                 	lds		d0, th_addr
0006e2 90d0 0201                 	lds		d1, tl_addr
                                 
                                 ; also changes the scratchpad and eeprom of the thermometer (in Celsius)
                                 back_to_save:
0006e4 de24                      	rcall	wire1_reset			; send a reset pulse
0006e5 ec2c
0006e6 de4e                      	CA		wire1_write, skipROM
0006e7 e42e
0006e8 de4c                      	CA		wire1_write, writeScratchpad
0006e9 2d2c                      	mov		a0,d0
0006ea de4a                      	rcall 	wire1_write
0006eb 2d2d                      	mov		a0,d1
0006ec de48                      	rcall 	wire1_write
0006ed e72f                      	ldi		a0,0b01111111
0006ee de46                      	rcall 	wire1_write
                                 
0006ef de19                      	rcall	wire1_reset
0006f0 ec2c
0006f1 de43                      	CA		wire1_write, skipROM
0006f2 e428
0006f3 de41                      	CA		wire1_write, copyScratchpad
0006f4 9508                      	ret
                                 ; if the temps are in F, converts them in C for the thermometer
                                 conv_to_c:
0006f5 9120 0200                 	lds		a0, th_addr
0006f7 d026                      	rcall	fahr_to_c
0006f8 932f                      	push	a0
0006f9 9120 0201                 	lds		a0, tl_addr
0006fb d022                      	rcall	fahr_to_c
0006fc 2ed2                      	mov		d1,a0
0006fd 90cf                      	pop		d0
0006fe cfe5                      	rjmp	back_to_save
                                 
                                 ; Routine to load the Th and Tl from the EEPROM
                                 ; from addresses : th_eep and tl_eep 
                                 ; to SRAM addresses : th_addr and tl_addr
                                 load_t_eeprom:
0006ff e0b0                      	ldi		xh, high(th_eep)
000700 e0a1                      	ldi		xl, low(th_eep)
000701 d17b                      	rcall	eeprom_load
000702 2ec2                      	mov		d0,a0
000703 e0b0                      	ldi		xh, high(tl_eep)
000704 e0a2                      	ldi		xl, low(tl_eep)
000705 d177                      	rcall	eeprom_load
000706 2ed2                      	mov		d1,a0
                                 
000707 92c0 0200                 	sts		th_addr, d0
000709 92d0 0201                 	sts		tl_addr, d1
00070b 9508                      	ret
                                 
                                 ; Routine to transform a value from C to F
                                 ; in : a0 the temperature
                                 cel_to_f:
00070c fb27                      	bst		a0,7
00070d 3020                      	cpi		a0, 0
00070e f412                      	brpl	mul_c_f
                                 
                                 ; a0 is negative, we take its absolute value
00070f 9520                      	com		a0
000710 5f2f                      	subi	a0, (-1)
                                 
                                 mul_c_f:
000711 e069                      	ldi		b0, 9
000712 d90f                      	rcall	mul11
000713 2d28                      	mov		a0,c0
000714 2d39                      	mov		a1,c1
000715 e065                      	ldi		b0, 5
000716 2777                      	clr		b1
000717 dd04                      	rcall	div22
                                 	
000718 2d28                      	mov		a0,c0
000719 f416                      	brtc	add_c_f
                                 
                                 ; a0 is turned back into a negative number
00071a 9520                      	com		a0
00071b 5f2f                      	subi	a0, (-1)
                                 
                                 add_c_f:
00071c 5e20                      	subi	a0, (-32) ; a0 : T in F
00071d 9508                      	ret
                                 
                                 ; Routine to transform a value from F to C
                                 ; in : a0 the temperature
                                 fahr_to_c:
00071e 5220                      	subi	a0, 32 
                                 
00071f fb27                      	bst		a0,7
000720 3020                      	cpi		a0, 0
000721 f412                      	brpl	mul_f_c
                                 
                                 ; a0 is negative, we take its absolute value
000722 9520                      	com		a0
000723 5f2f                      	subi	a0, (-1)
                                 
                                 mul_f_c:
000724 e065                      	ldi		b0, 5
000725 d8fc                      	rcall	mul11
000726 2d28                      	mov		a0,c0
000727 2d39                      	mov		a1,c1
000728 e069                      	ldi		b0, 9
000729 2777                      	clr		b1
00072a dcf1                      	rcall	div22
                                 	
00072b 2d28                      	mov a0,c0
00072c f416                      	brtc	end_f_c
                                 
                                 ; a0 is turned back into a negative number
00072d 9520                      	com		a0
00072e 5f2f                      	subi	a0, (-1)
                                 
                                 end_f_c:
                                 .include	"remote.asm"
00072f 9508                      
                                 ; purpose get the codes sent by the remote
                                 
                                 .include "musique.asm"
                                 
                                 ; purpose send frequency to the buzzer to produce a music 
                                 
                                 .include	"Libraries/sound.asm"
                                 
                                 ; purpose library, sound generation
                                 
                                 sound:
                                 ; in	a0	period of oscillation (in 10us)
                                 ; 	b0	duration of sound (in 2.5ms)
                                 
000730 2f76                      	mov	b1,b0		; duration high byte = b
000731 2766                      	clr	b0		; duration  low byte = 0
000732 2733                      	clr	a1		; period high byte = a
000733 3021                      	cpi	a0,1
000734 f071                      	breq	sound_off	; if a0=1 then no sound	
                                 sound1:
000735 2f02                      	mov	w,a0		
000736 d012                      	rcall	wait9us		; 9us
000737 0000                      	nop			; 0.25us
000738 950a                      	dec	w		; 0.25us
000739 f7e1                      	brne	PC-3		; 0.50us	total = 10us
00073a 9b1a
00073b c002
00073c 981a
00073d c001
00073e 9a1a                      	INVP	PORTE,SPEAKER	; invert piezo output
00073f 1b62                      	sub	b0,a0		; decrement duration low  byte
000740 0b73                      	sbc	b1,a1		; decrement duration high byte
000741 f798                      	brcc	sound1		; continue if duration>0
000742 9508                      	ret
                                 
                                 sound_off:
000743 e021                      	ldi	a0,1
000744 d004                      	rcall	wait9us
000745 1b62                      	sub	b0,a0		; decrement duration low  byte
000746 0b73                      	sbc	b1,a1		; decrement duration high byte
000747 f7e0                      	brcc	PC-3		; continue if duration>0
000748 9508                      	ret
                                 
                                 ; === wait routines ===
                                 
000749 c000                      wait9us:rjmp	PC+1		; waiting 2 cycles
00074a c000                      	rjmp	PC+1		; waiting 2 cylces
00074b d000                      wait8us:rcall	wait4us		; recursive call with "falling through"
00074c d000                      wait4us:rcall	wait2us	
00074d 0000                      wait2us:nop
00074e 9508                      	ret		; rcall(4), nop(1), ret(3) = 8cycl. (=2us)
                                 
                                 ; === calculation of the musical scale ===
                                  
                                 ; period (10us)	= 100'000/freq(Hz)
                                 .equ	soupir = 1
                                 
                                 .equ	do	= 100000/517	; (517 Hz)
                                 .equ	dom	= do*944/1000	; do major
                                 .equ	re	= do*891/1000
                                 .equ	rem	= do*841/1000	; re major
                                 .equ	mi	= do*794/1000
                                 .equ	mib	= do*754/1000
                                 .equ	fa	= do*749/1000
                                 .equ	fam	= do*707/1000	; fa major
                                 .equ	so	= do*667/1000
                                 .equ	som	= do*630/1000	; so major
                                 .equ	la	= do*595/1000
                                 .equ	lam	= do*561/1000	; la major
                                 .equ	si	= do*530/1000
                                 
                                 .equ	do2	= do/2
                                 .equ	dom2	= dom/2
                                 .equ	re2	= re/2
                                 .equ	rem2	= rem/2
                                 .equ	mi2	= mi/2
                                 .equ	fa2	= fa/2
                                 .equ	fam2	= fam/2
                                 .equ	so2	= so/2
                                 .equ	som2	= som/2
                                 .equ	la2	= la/2
                                 .equ	lam2	= lam/2
                                 .equ	si2	= si/2
                                 
                                 .equ	do3	= do/4
                                 .equ	dom3	= dom/4
                                 .equ	re3	= re/4
                                 .equ	rem3	= rem/4
                                 .equ	mi3	= mi/4
                                 .equ	fa3	= fa/4
                                 .equ	fam3	= fam/4
                                 .equ	so3	= so/4
                                 .equ	som3	= som/4
                                 .equ	la3	= la/4
                                 .equ	lam3	= lam/4
                                 .equ	si3	= si/4	
                                 
                                 ;---- music score----
                                 
                                 elise: ;	Fr Elise
00074f 2826                      .db		mi3,rem3
000750 2826
000751 3326
000752 302a
000753 9939
000754 6072
000755 394c                      .db		mi3,rem3,mi3,si2,re3,do3,		la2,mi,la,do2,mi2,la2
000756 9933
000757 4c79
000758 3379
000759 9930
00075a 4c72
00075b 2826                      .db		si2,mi,som,mi2,som,si2,			do3,mi,la,mi2,mi3,rem3
00075c 2826
00075d 3326
00075e 302a
00075f 9939
000760 6072
000761 394c                      .db		mi3,rem3,mi3,si2,re3,do3,		la2,mi,la,do2,mi2,la2
000762 9933
000763 5579
000764 3330
000765 9939
000766 3372
000767 2a30                      .db		si2,mi,som,re2,do3,si2,			la2,mi,la,si2,do3,re3
                                 
000768 8026
000769 4060
00076a 2624
00076b 802a
00076c 4866
00076d 2a26                      .db		mi3,so,do2,so2,fa3,mi3,			re3,so,si,fa2,mi3,re3
00076e 8030
00076f 4060
000770 2624
000771 9933
000772 4c4c
000773 4c26                      .db		do3,so,do2,so2,fa3,mi3,			si2,mi,mi2,mi2,mi3,mi2
000774 4c26
000775 2826
000776 2826
000777 2826
000778 2826
000779 2826                      .db		mi3,mi2,mi3,rem3,mi3,rem3,		mi3,rem3,mi3,rem3,mi3,rem3
00077a 2826
00077b 3326
00077c 302a
00077d 9939
00077e 6072
00077f 394c                      .db		mi3,rem3,mi3,si2,re3,do3,		la2,mi,la,do2,mi2,la2
000780 9933
000781 4c79
000782 663c
000783 9930
000784 4c72
000785 2826                      .db		si2,mi,som,mi2,som2,si,			do3,mi,la,mi2,mi3,rem3
000786 2826
000787 3326
000788 302a
000789 9939
00078a 6072
00078b 394c                      .db		mi3,rem3,mi3,si2,re3,do3,		la2,mi,la,do2,mi2,la2
00078c 9933
00078d 5579
00078e 3330
00078f 9939
000790 3372
000791 2a30                      .db		si2,mi,som,re2,do3,si2,			la2,mi,la,si2,do3,re3
000792 0101
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\musique.asm(22): warning: .cseg .db misalignment - padding zero byte
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\remote.asm(4): 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\musique.asm' included form here
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\main.asm(37): 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\remote.asm' included form here
000793 0000                      .db		soupir, soupir, 0
                                 
                                 jacques: ;	 Frre Jacques
000794 2a30
000795 3026
000796 3001
000797 262a
000798 0130
000799 2426                      .db		do3,re3,mi3,do3,soupir,do3,		re3,mi3,do3,soupir,mi3,fa3
00079a 2020
00079b 2601
00079c 2024
00079d 0120
00079e 1c20
00079f 2420
0007a0 3026                      .db		so3,so3,soupir,mi3,fa3,so3,		so3,soupir,so3,la3,so3,fa3,mi3,do3
0007a1 2001
0007a2 201c
0007a3 2624
0007a4 0130
0007a5 3030
0007a6 8080                      .db		soupir,so3,la3,so3,fa3,mi3,		do3,soupir,do3,do3,so,so
0007a7 3030
0007a8 3001
0007a9 8030
0007aa 3080
0007ab 0130
0007ac 0001                      .db		do3,do3,soupir,do3,do3,so,		so,do3,do3,soupir,soupir,0
                                 
                                 clair:	 ;	 Au Clair De La Lune
0007ad 6060
0007ae 5560
0007af 4c4c
0007b0 5555
0007b1 4c60
0007b2 5555                      .db		do2,do2,do2,re2,mi2,mi2,		re2,re2,do2,mi2,re2,re2
0007b3 6060
0007b4 6060
0007b5 6001
0007b6 6060                      .db		do2,do2,do2,do2,soupir,			do2,do2,do2
0007b7 4c55
0007b8 554c
0007b9 6055
0007ba 554c
0007bb 6055
0007bc 6060                      .db		re2,mi2,mi2,re2,re2,do2,		mi2,re2,re2,do2,do2,do2
0007bd 0160
0007be 5555
0007bf 5555
0007c0 7272
0007c1 7272
0007c2 6055                      .db		do2,soupir,re2,re2,re2,re2,		la,la,la,la,re2,do2
0007c3 7266
0007c4 8080
0007c5 0101
0007c6 6060
0007c7 5560
0007c8 4c4c                      .db		si,la,so,so,soupir,soupir,		do2,do2,do2,re2,mi2,mi2
0007c9 5555
0007ca 4c60
0007cb 5555
0007cc 6060
0007cd 0101
0007ce 0101
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\musique.asm(36): warning: .cseg .db misalignment - padding zero byte
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\remote.asm(4): 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\musique.asm' included form here
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\main.asm(37): 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\remote.asm' included form here
0007cf 0000                      .db		re2,re2,do2,mi2,re2,re2,		do2,do2,soupir,soupir,soupir,soupir, 0
                                 
                                 alarme:	 ;	 Sound for alarm
0007d0 4860
0007d1 3939
0007d2 6048
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\musique.asm(39): warning: .cseg .db misalignment - padding zero byte
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\remote.asm(4): 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\musique.asm' included form here
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\main.asm(37): 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\remote.asm' included form here
0007d3 0000                      .db		do2, fa2, la2, la2, fa2, do2, 0
                                 
                                 ; start playing one of the score, gets from r6 which of the 4
                                 ; the encoding of the choice is in the 2 MSBs
                                 ; needs the address alarm_addr in the SRAM to determine if the music needs to be played, the 5th bit = 1 --> playing
                                 play:		
0007d4 2d06                      	mov		w, m
0007d5 7c00                      	andi	w, 0b11000000
                                 
0007d6 3000                      	cpi		w, 0b00000000
0007d7 f031                      	breq	load_music1
0007d8 3400                      	cpi		w, 0b01000000
0007d9 f039                      	breq	load_music2
0007da 3800                      	cpi		w, 0b10000000
0007db f041                      	breq	load_music3
0007dc 3c00                      	cpi		w, 0b11000000
0007dd f049                      	breq	load_music4
                                 
                                 load_music1:
0007de e9ee                      	ldi		zl, low(2*elise)
0007df e0fe                      	ldi		zh, high(2*elise)
0007e0 c009                      	rjmp play_loop
                                 
                                 load_music2:
0007e1 e2e8                      	ldi		zl, low(2*jacques)
0007e2 e0ff                      	ldi		zh, high(2*jacques)
0007e3 c006                      	rjmp play_loop
                                 
                                 load_music3:
0007e4 e5ea                      	ldi		zl, low(2*clair)
0007e5 e0ff                      	ldi		zh, high(2*clair)
0007e6 c003                      	rjmp play_loop
                                 
                                 load_music4:
0007e7 eae0                      	ldi		zl, low(2*alarme)
0007e8 e0ff                      	ldi		zh, high(2*alarme)
0007e9 c000                      	rjmp	play_loop
                                 
                                 ; start the music here
                                 play_loop:
0007ea 9100 0204                 	lds		w, alarm_addr	; load the value indicating if the alarm needs to ring (in the 5th bit)
0007ec ff05                      	sbrs	w, 5
0007ed c00b                      	rjmp	end
                                 
                                 	; load the music note
0007ee 95c8                      	lpm
0007ef 9631                      	adiw	zl,1
0007f0 2000                      	tst		r0
0007f1 f311                      	breq	play			; if reaches the end of the score, start again
0007f2 2d20                      	mov		a0,r0
                                 
0007f3 e664                      	ldi		b0,100
0007f4 3021                      	cpi		a0, 1
0007f5 f409                      	brne	PC+2
0007f6 e169                      	ldi		b0, 25
                                 	
                                 	; plays the note
0007f7 df38                      	rcall	sound
0007f8 cff1                      	rjmp	play_loop
                                 
                                 end:
0007f9 e000                      	ldi		w, 0
0007fa 9300 0204                 	sts		alarm_addr, w	; stops the music from restarting
0007fc 9508                      	ret
                                 
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\remote.asm(6): warning: float->int cast, truncated
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\main.asm(37): 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\remote.asm' included form here
                                 .equ	T2 = 14906*(1+0.034)		; start timout, T2 = (14906 + (14906 * Terr2)) 
                                 									;>with Terr2 = 3.4% observed with the oscilloscope
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\remote.asm(8): warning: float->int cast, truncated
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\main.asm(37): 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\remote.asm' included form here
                                 .equ	T1 = 1125*(1+0.044)			; bit period, T1 = (1125 + (1125 * Terr1)) with 
                                 									;>Terr1 = 4.4% observed with the oscilloscope
                                 .equ	PINIR = PINE							
                                 
                                 ; Init the remote 
                                 remote_reset:
0007fd 9817                      	cbi		DDRE,IR			; set IR as input
0007fe 9a12                      	sbi		DDRE,SPEAKER	; set buzzer as output
0007ff e000                      	ldi		w, 0
000800 9300 0204                 	sts		alarm_addr, w
000802 9508                      	ret
                                 
                                 ; reads the remote signal from PINIR
                                 ; out : b0 the code pressed or 0 if there is an error or repeat
                                 read_remote:
000803 1b77
000804 2766                      	CLR2	b1,b0			; clear 2-byte register
000805 1b33
000806 2722                      	CLR2	a1,a0
000807 e180                      	ldi		b2,16
                                 
000808 e404
000809 2e30
00080a e501
00080b 943a
00080c f7f1
00080d 943a
00080e 950a
00080f f7d9                      	WAIT_US	T2				; wait for timeout
000810 9488                      	clc						; clearing carry
                                 	
                                 addr: 
000811 990f
000812 9408
000813 9b0f
000814 9488                      	P2C		PINIR,IR		; move Pin to Carry (P2C, 4 cycles)
000815 1f66
000816 1f77                      	ROL2	b1,b0			; roll carry into 2-byte reg (ROL2, 2 cycles)
000817 fd60                      	sbrc	b0,0			; (branch not taken, 1 cycle; taken 2 cycles)
000818 c00c                      	rjmp	rdz_a			; (rjmp, 2 cycles)
000819 e109
00081a 2e30
00081b e007
00081c 943a
00081d f7f1
00081e 943a
00081f 950a
000820 f7d9                      	WAIT_US	(T1 - 2)
000821 958a
000822 f771                      	DJNZ	b2,addr			; Decrement and Jump if Not Zero (true, 2 cycles; false, 1 cycle)
000823 940c 082f                 	jmp		next_a			; (jmp, 3 cycles)
                                 rdz_a:						; read a zero
000825 e305
000826 2e30
000827 e00d
000828 943a
000829 f7f1
00082a 943a
00082b 950a
00082c f7d9                      	WAIT_US	(2*T1 - 3)
00082d 958a
00082e f711                      	DJNZ	b2,addr			; Decrement and Jump if Not Zero
                                 
                                 next_a: 
00082f 2ec6
000830 2ed7                      	MOV2	d1,d0, b1, b0	; store current address
000831 2f26
000832 2f37                      	MOV2	a1,a0,b1,b0
000833 e180                      	ldi		b2,16			; load bit-counter
000834 9488                      	clc
000835 1b77
000836 2766                      	CLR2	b1,b0
                                 
                                 data: 
000837 990f
000838 9408
000839 9b0f
00083a 9488                      	P2C		PINIR,IR		; PINE to carry	
00083b 1f66
00083c 1f77                      	ROL2	b1,b0			; rotate left through carry
00083d fd60                      	sbrc	b0,0			; skip bit in reg clear
00083e c00c                      	rjmp	rdz_d			; if LSB from b0 = 0 go to rdz_d
00083f e109
000840 2e30
000841 e007
000842 943a
000843 f7f1
000844 943a
000845 950a
000846 f7d9                      	WAIT_US	(T1 - 2)		; wait a certain time
000847 958a
000848 f771                      	DJNZ	b2,data			; decrement and jump if not zero
000849 940c 0855                 	jmp		next_b			; go to next_b
                                 		
                                 rdz_d:							
00084b e305
00084c 2e30
00084d e00d
00084e 943a
00084f f7f1
000850 943a
000851 950a
000852 f7d9                      	WAIT_US	(2*T1 - 3)		; wait a certain time
000853 958a
000854 f711                      	DJNZ	b2,data			; decrement and jump if not zero
                                 
                                 next_b:
000855 2ee6
000856 2ef7                      	MOV2	d3,d2,b1, b0	; store current command
                                 
                                  data_proc01:				; detect repeated code
000857 ef0f
000858 16f0                      	_CPI		d3, 0xff
000859 f459                      	brne	data_proc02
00085a ef0f
00085b 16e0                      	_CPI		d2, 0xff
00085c f441                      	brne	data_proc02
00085d ef0f
00085e 16d0                      	_CPI		d1, 0xff 
00085f f429                      	brne	data_proc02
000860 ef0f
000861 16c0                      	_CPI		d0, 0xff
000862 f411                      	brne	data_proc02 
                                 
                                 code_repeat:
000863 e060                      	ldi		b0, 0
000864 9508                      	ret
                                 
                                 data_proc02:				; detect transmission error
000865 94d0                      	com		d1
000866 10cd                      	cpse	d0, d1
000867 f429                      	brne	code_error
000868 94f0                      	com		d3
000869 10ef                      	cpse	d2, d3
00086a f411                      	brne	code_error
                                 	
                                 code_correct:			;bitwise complement
00086b 9560                      	com		b0
00086c 9508                      	ret						
                                 
                                 code_error:
00086d e060                      	ldi		b0, 0
                                 .include	"Libraries\eeprom.asm"
00086e 9508                      
                                 ; purpose library, internal EEPROM
                                 
                                 eeprom_store:
                                 ; in:	xh:xl 	EEPROM address
                                 ;	a0	EEPROM data byte to store
                                 
00086f 99e1                      	sbic	EECR,EEWE	; skip if EEWE=0 (wait it EEWE=1)
000870 cffe                      	rjmp	PC-1		; jump back to previous address
000871 bbae                      	out	EEARL,xl		; load EEPROM address low	
000872 bbbf                      	out	EEARH,xh		; load EEPROM address high
000873 bb2d                      	out	EEDR,a0			; set EEPROM data register
000874 f01f                      	brie	eeprom_cli	; if I=1 then temporarily disable interrupts
000875 9ae2                      	sbi	EECR,EEMWE		; set EEPROM Master Write Enable
000876 9ae1                      	sbi	EECR,EEWE		; set EEPROM Write Enable
000877 9508                      	ret	
                                 eeprom_cli:
000878 94f8                      	cli					; disable interrupts
000879 9ae2                      	sbi	EECR,EEMWE		; set EEPROM Master Write Enable
00087a 9ae1                      	sbi	EECR,EEWE		; set EEPROM Write Enable
00087b 9478                      	sei					; enable interrupts
00087c 9508                      	ret
                                 
                                 eeprom_load:
                                 ; in:	xh:xl 	EEPROM address
                                 ; out:	a0	EEPROM data byte to load
                                 
00087d 99e1                      	sbic	EECR,EEWE	; skip if EEWE=0 (wait it EEWE=1)
00087e cffe                      	rjmp	PC-1		; jump back to previous address
00087f bbae                      	out	EEARL,xl	
000880 bbbf                      	out	EEARH,xh
000881 9ae0                      	sbi	EECR,EERE		; set EEPROM Read Enable
000882 b32d                      	in	a0,EEDR			; read data register of EEPROM
                                 .include	"affichage.asm"
000883 9508                      
                                 ; purpose display on the LCD screen the correct menu
                                 
                                 
                                 ; ====	Display Routine ====
                                 
                                 affichage:
000884 dc47                      	rcall	LCD_clear		;clear LCD
000885 dc48                      	rcall	LCD_home
                                 
000886 9100 0205                 	lds		w, on_off_addr	;load the address ON/OFF in w
000888 3000                      	cpi		w, 0			;compare with 0, if w = 0 go to main 
000889 f009                      	breq	PC+2
00088a c280                      	rjmp	main
                                 
00088b 2d16                      	mov		_w, m			; load m in _w
00088c 7013                      	andi	_w, 0b11		; select the two last bits of m 
00088d e000
00088e 1710                      	_CPI	_w, 0		
00088f f111                      	breq	menu_set_temp	; if their are 00 -> menu set temp
000890 e001
000891 1710                      	_CPI	_w, 1		
000892 f199                      	breq	menu_temp		; if their are 01 ->	menu temp
000893 e002
000894 1710                      	_CPI	_w, 2
000895 f021                      	breq	menu_music		; if their are 10 ->	menu music
000896 e003
000897 1710                      	_CPI	_w, 3
000898 f069                      	breq	menu_error		; if their are 11 -> menu jeu
                                 
000899 c271                      	rjmp	main
                                 
                                 menu_music:			
                                 	; print music
00089a fc63                      	sbrc	m,3
00089b c0a5                      	rjmp	music_choice
                                 
00089c ec00
00089d 2e40
00089e e004
00089f 2e50
0008a0 dcb3                      	PRINTF	LCD
0008a1 6c41
0008a2 7261
0008a3 656d
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\affichage.asm(35): warning: .cseg .db misalignment - padding zero byte
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\main.asm(39): 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\affichage.asm' included form here
0008a4 0000                      	.db		"Alarme",0
0008a5 c08f                      	rjmp	music_on_off
                                 	
                                 
                                 menu_error:			
                                 	; print error
0008a6 fc63                      	sbrc	m,3
0008a7 c075                      	rjmp	error_sub
                                 	
0008a8 ec00
0008a9 2e40
0008aa e004
0008ab 2e50
0008ac dca7                      	PRINTF	LCD
0008ad 5245
0008ae 4f52
0008af 0052                      	.db		"ERROR",0
0008b0 940c 0b0b                 	jmp		main
                                 
                                 menu_set_temp:		
                                 	; print temp lim
0008b2 fc63                      	sbrc	m,3
0008b3 c049                      	rjmp	print_limit
                                 
0008b4 ec00
0008b5 2e40
0008b6 e004
0008b7 2e50
0008b8 dc9b                      	PRINTF	LCD
0008b9 6554
0008ba 706d
0008bb 7265
0008bc 7461
0008bd 7275
0008be 7365
0008bf 6c0a
0008c0 6d69
0008c1 7469
0008c2 7365
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\affichage.asm(54): warning: .cseg .db misalignment - padding zero byte
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\main.asm(39): 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\affichage.asm' included form here
0008c3 0000                      	.db		"Temperatures",LF,"limites",0
0008c4 940c 0b0b                 	jmp		main
                                 
                                 menu_temp:			
                                 	; print temp	
0008c6 fc63                      	sbrc	m,3
0008c7 c013                      	rjmp	degre
                                 
0008c8 ec00
0008c9 2e40
0008ca e004
0008cb 2e50
0008cc dc87                      	PRINTF LCD
0008cd 6345
0008ce 6568
0008cf 6c6c
0008d0 2065
0008d1 6564
0008d2 740a
0008d3 6d65
0008d4 6570
0008d5 6172
0008d6 7574
0008d7 6572
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\affichage.asm(63): warning: .cseg .db misalignment - padding zero byte
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\main.asm(39): 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\affichage.asm' included form here
0008d8 0000                      	.db		"Echelle de",LF,"temperature",0
0008d9 940c 0b0b                 	jmp		main
                                 
                                 ; ==== Menu Choix Unite Temperature ====
                                 degre:
0008db ec00
0008dc 2e40
0008dd e004
0008de 2e50
0008df dc74                      	PRINTF	LCD
0008e0 6544
0008e1 7267
0008e2 2065
0008e3 0a3a
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\affichage.asm(69): warning: .cseg .db misalignment - padding zero byte
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\main.asm(39): 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\affichage.asm' included form here
0008e4 0000                      	.db		"Degre :",LF,0
                                 
0008e5 fc62                      	sbrc	m,2
0008e6 c00a                      	rjmp	print_f
                                 
                                 print_c:			
                                 	; print Celsius
0008e7 ec00
0008e8 2e40
0008e9 e004
0008ea 2e50
0008eb dc68                      	PRINTF	LCD
0008ec 6543
0008ed 736c
0008ee 7569
0008ef 0073                      	.db		"Celsius",0
0008f0 c21a                      	rjmp	main
                                 
                                 print_f:			
                                 	; print Fahrenheit
0008f1 ec00
0008f2 2e40
0008f3 e004
0008f4 2e50
0008f5 dc5e                      	PRINTF	LCD
0008f6 6146
0008f7 7268
0008f8 6e65
0008f9 6568
0008fa 7469
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\affichage.asm(83): warning: .cseg .db misalignment - padding zero byte
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\main.asm(39): 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\affichage.asm' included form here
0008fb 0000                      	.db		"Fahrenheit",0
0008fc c20e                      	rjmp	main
                                 
                                 
                                 ; ==== Menu Limite Temperature ====
                                 print_limit:		
                                 	; print Limite
0008fd 9130 0202                 	lds		r19, unit_addr				;load the unit in r19 
0008ff 9110 0200                 	lds		r17, th_addr				;load the high temp in r17 
000901 9120 0201                 	lds		r18, tl_addr				;load the low temp in r18
000903 ec00
000904 2e40
000905 e004
000906 2e50
000907 dc4c                      	PRINTF	LCD
000908 6854
000909 203a
00090a 11c1
00090b 2020
00090c 3a75
00090d 13c0
00090e 540a
00090f 3a6c
000910 c120
000911 0012                      	.db		"Th: ",FDEC|FSIGN,17,"  u:",FDEC,19,LF,"Tl: ",FDEC|FSIGN,18,0
                                 
000912 940c 0914                 	jmp		display_cursor
                                 
                                 display_cursor:		
                                 	; show in which sub menu we are: <-
000914 e400                      	ldi		w, 0x40
000915 e02f                      	ldi		a0, 0x0f
000916 fc64                      	sbrc	m, 4
000917 0f20                      	add		a0, w
000918 dbd3                      	rcall	LCD_pos
000919 e72f                      	ldi		a0, 127
00091a dba5                      	rcall	LCD_putc
00091b 940c 0b0b                 	jmp		main
                                 
                                 ; ==== Menu Error ====
                                 error_sub:
00091d ec00
00091e 2e40
00091f e004
000920 2e50
000921 dc32                      	PRINTF	LCD
000922 5245
000923 4f52
000924 2052
000925 203a
000926 7250
000927 7365
000928 2073
000929 5145
00092a 540a
00092b 6568
00092c 206e
00092d 6863
00092e 6e61
00092f 6567
000930 6d20
000931 6e65
000932 0075                      	.db		"ERROR : Press EQ", LF, "Then change menu",0
000933 940c 0b0b                 	jmp		main
                                 
                                 ; ==== Menu Musique ====
                                 music_on_off:
                                 	; print	a music note
000935 e02f                      	ldi		a0, 0x0f	;set the cursor position 
000936 dbb5                      	rcall	LCD_pos		
000937 fe65                      	sbrs	m, 5		
000938 c004                      	rjmp	print_off	
                                 
000939 e021                      	ldi		a0,1		
00093a db85                      	rcall	LCD_putc	
00093b 940c 0b0b                 	jmp		main		
                                 
                                 print_off:
                                 	; print a reversed music note
00093d e022                      	ldi		a0,2		
00093e db81                      	rcall	LCD_putc
00093f 940c 0b0b                 	jmp		main
                                 
                                 music_choice:
                                 	;print the music choice
000941 ec00
000942 2e40
000943 e004
000944 2e50
000945 dc0e                      	PRINTF	LCD
000946 7551
000947 6c65
000948 656c
000949 6120
00094a 616c
00094b 6d72
00094c 2065
00094d 0a3f
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\affichage.asm(136): warning: .cseg .db misalignment - padding zero byte
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\main.asm(39): 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\affichage.asm' included form here
00094e 0000                      	.db		"Quelle alarme ?",LF,0
                                 
00094f 2d06                      	mov		w, m				;load the menu register in w
000950 7c00                      	andi	w, 0b11000000		;select the two highest bits of w with a mask
                                 
000951 3000                      	cpi		w, 0b00000000		;music 1 correspond to 00
000952 f031                      	breq	music1
000953 3400                      	cpi		w, 0b01000000		;music 2 correspond to 01
000954 f081                      	breq	music2
000955 3800                      	cpi		w, 0b10000000		;music 3 correspond to 10
000956 f0e1                      	breq	music3
000957 3c00                      	cpi		w, 0b11000000		;music 4 correspond to 11
000958 f141                      	breq	music4
                                 
                                 music1:	
                                 	; print Fr Elise
000959 ec00
00095a 2e40
00095b e004
00095c 2e50
00095d dbf6                      	PRINTF	LCD
00095e 7546
00095f 2072
000960 6c45
000961 7369
000962 0065                      	.db		"Fur Elise",0
000963 940c 0b0b                 	jmp		main
                                 
                                 music2:
                                 	; print Frre Jacques
000965 ec00
000966 2e40
000967 e004
000968 2e50
000969 dbea                      	PRINTF	LCD
00096a 7246
00096b 7265
00096c 2065
00096d 614a
00096e 7163
00096f 6575
000970 0073                      	.db		"Frere Jacques",0
000971 940c 0b0b                 	jmp		main
                                 
                                 music3:
                                 	; print Clair de lune
000973 ec00
000974 2e40
000975 e004
000976 2e50
000977 dbdc                      	PRINTF	LCD
000978 6c43
000979 6961
00097a 2072
00097b 6564
00097c 6c20
00097d 6e75
00097e 0065                      	.db		"Clair de lune",0
00097f 940c 0b0b                 	jmp		main
                                 
                                 music4:
                                 	; print Alarme
000981 ec00
000982 2e40
000983 e004
000984 2e50
000985 dbce                      	PRINTF	LCD
000986 6c41
000987 7261
000988 656d
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\affichage.asm(171): warning: .cseg .db misalignment - padding zero byte
C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\main.asm(39): 'C:\Users\Administrateur\Desktop\redesigned-pancake\Projet\Projet\affichage.asm' included form here
000989 0000                      	.db		"Alarme",0
00098a 940c 0b0b                 	jmp		main
                                 
                                 
                                 note_music:
00098c 0604
00098d 0505
00098e 1c04
00098f 001c                      .db	0b00000100, 0b00000110, 0b00000101, 0b00000101, 0b00000100, 0b00011100, 0b00011100, 0b00000000
                                 
                                 note_music_off:
000990 f9fb
000991 fafa
000992 e3fb
000993 ffe3                      .db 0b11111011, 0b11111001, 0b11111010, 0b11111010, 0b11111011, 0b11100011, 0b11100011, 0b11111111
                                 
                                 store_custom_char: 
000994 9030 8000                 	lds		u, LCD_IR					; load the address LCD instruction reg in u
000996 fc37
000997 cffc                      	JB1		u,7,store_custom_char		; print a music note if the 7th bit of u is 1
                                 	
000998 e408                      	ldi		r16, 0b01001000				
000999 9300 8000                 	sts		LCD_IR,r16					; store direct to SRAM at the address LCD instruction
00099b e1e8                      	ldi		zl,low(2*note_music)
00099c e1f3                      	ldi		zh,high(2*note_music)
00099d e028                      	ldi		r18,8						; load 8 in r18
00099e d00c                      	rcall	store_lcd_loop
                                 
                                 store_music_off_char:
00099f 9030 8000                 	lds		u, LCD_IR					; load the address LCD instruction reg in u
0009a1 fc37
0009a2 cffc                      	JB1		u,7,store_music_off_char	; print a reversed music note if the 7th bit of u is 1
                                 
0009a3 e500                      	ldi		r16, 0b01010000
0009a4 9300 8000                 	sts		LCD_IR,r16					; store r16 direct to SRAM at the address LCD instruction
0009a6 e2e0                      	ldi		zl,low(2*note_music_off)
0009a7 e1f3                      	ldi		zh,high(2*note_music_off)
0009a8 e028                      	ldi		r18,8						; load 8 in r18
0009a9 d001                      	rcall	store_lcd_loop
                                 
0009aa 9508                      	ret
                                 
                                 store_lcd_loop: 
0009ab 9030 8000                   	lds		u, LCD_IR					; load the value from LCD_IR in u 
0009ad fc37
0009ae cffc                      	JB1		u,7,store_lcd_loop			; loop if the 7th bit of u is 1
0009af 95c8                      	lpm									; load program memory
0009b0 2d00                      	mov		r16,r0
0009b1 9631                      	adiw	zl,1						; add immediate to word
0009b2 9300 c000                 	sts		LCD_DR, r16					; store r16 direct to SRAM at the address LCD data register
0009b4 952a                      	dec		r18							; decrement r18
0009b5 f7a9                      	brne	store_lcd_loop				; loop if r18 not equal to 0 
0009b6 db17                      	rcall	LCD_home	
                                 .include	"ir_button.asm"
0009b7 9508                      
                                 ; purpose link each button from the remote to its function
                                 
                                  menu_bouton:					; button code to their function
0009b8 3a62                      	cpi		b0, 0xa2
0009b9 f099                      	breq	turn_on_off			; power button
                                 
0009ba 9100 0205                 	lds		w, on_off_addr		; load direct from SRAM to w the address to store if screen is on/off
0009bc 3000                      	cpi		w, 0				; compare imm w with 0
0009bd f009                      	breq	PC+2				; jump the next line if w = 0
0009be c14c                      	rjmp	main
                                 
                                 	; compare imm b0 with the value of the button and go to their function 
0009bf 3e60                      	cpi		b0, 0xe0		
0009c0 f0a9                      	breq	enter_sub_button	; EQ
0009c1 3c62                      	cpi		b0, 0xC2		
0009c2 f0b9                      	breq	next_menu			; >>|
0009c3 3062                      	cpi		b0, 0x02
0009c4 f111                      	breq	previous_menu		; |<<
0009c5 3e62                      	cpi		b0, 0xe2
0009c6 f169                      	breq	button_music		; Sound ON/OFF
0009c7 3262                      	cpi		b0, 0x22
0009c8 f179                      	breq	test_music			; >||
0009c9 3b60                      	cpi		b0, 0xb0
0009ca f1e9                      	breq	change_music		; U/SD
                                 	
0009cb 940c 0a16                 	jmp temp_buttons
                                 
                                 turn_on_off:					; turn On/OFF the screen
0009cd 9100 0205                 	lds		w, on_off_addr		; load direct from SRAM to w the address to store if screen is on/off
0009cf 9500                      	com		w					; bitwise complement
0009d0 9300 0205                 	sts		on_off_addr,w		; store direct to SRAM
                                 
0009d2 3000                      	cpi		w, 0				; compare imm w and 0
0009d3 f009                      	breq	PC+2				; jump next line if W = 0
                                 
0009d4 940c 0884                 	jmp		affichage
                                 
                                 enter_sub_button:				; enter or exit the sub menu (3rd bit of m)
0009d6 e008                      	ldi		w, 0b00001000		; load the 3rd bit in w
0009d7 2660                      	eor		m, w				; change the 3rd bit of m
0009d8 940c 0aae                 	jmp		save_m_eeprom
                                 
                                 next_menu:						; change menu (two last bits of m) to the right
0009da fc63                      	sbrc	m,3					; enter in the sub menu 
0009db c028                      	rjmp	change_sub
                                 
0009dc 2d16                      	mov		_w, m				; save the m register in _w
0009dd 7013                      	andi	_w, 0b00000011		; save the two la bits of m and clear the other
0009de 5f1f                      	subi	_w, -1				; change the two last bits of m by adding 1: 00-01-10-00-...
0009df 3013                      	cpi		_w, 0x3				; only 3 menus
0009e0 f409                      	brne	PC+2
0009e1 e010                      	ldi		_w, 0
0009e2 ef0c
0009e3 2260                      	_ANDI	m, 0b11111100		; clear the two lastbits of m with a mask
0009e4 0e61                      	add		m,_w				; assemble the unmodified part with the last two bits
0009e5 940c 0aae                 	jmp		save_m_eeprom
                                 
                                 previous_menu:					; change menu (two last bits of m) to the left
0009e7 fc63                      	sbrc	m,3					; enter in the sub menu 
0009e8 c01b                      	rjmp	change_sub
                                 
0009e9 2d16                      	mov		_w, m				; save the m register in _w 
0009ea 7013                      	andi	_w, 0b00000011		; save the first two bits of m and clear the other
0009eb 5011                      	subi	_w, 1				; change the first two  bits of register m by substracting 1: 00-11-10-01-00-...
0009ec 3f1f                      	cpi		_w, 0xff			; only 3 menus
0009ed f409                      	brne	PC+2
0009ee e012                      	ldi		_w, 2
0009ef ef0c
0009f0 2260                      	_ANDI	m, 0b11111100		; clear the first two bits of m with a mask
0009f1 0e61                      	add		m,_w				; assemble the unmodified part with the last two bits
0009f2 940c 0aae                 	jmp		save_m_eeprom
                                 
                                 button_music:					; sound ON/OFF 
0009f4 e200                      	ldi		w, 0b00100000		; load the 5th bit in w
0009f5 2660                      	eor		m, w				; invert the 5th bit in m
0009f6 940c 0aae                 	jmp		save_m_eeprom
                                 
                                 test_music:						; play the alarm / music
0009f8 2d06
0009f9 700b
0009fa 300a
0009fb f009
0009fc 940c 0884                 	CHECK_MENU_MUSIC			; check if we are in the correct submenu
0009fe e200                      	ldi		w, 32				; load 32 in 32
0009ff 9300 0204                 	sts		alarm_addr, w		; store direct the alarm address to SRAM
000a01 ddd2                      	rcall	play				; play the music
000a02 940c 0884                 	jmp		affichage
                                 
                                 change_sub:						; change the sub menu (4th bit of m)
000a04 e100                      	ldi		w, 0b00010000		; load the 4th bit in w
000a05 2660                      	eor		m, w				; change the 4th bit of m
000a06 940c 0aae                 	jmp		save_m_eeprom
                                 
                                 change_music:					; change the music: Alarm -> Elise -> Frere Jacques -> Clair De Lune -> Alarm ...
000a08 2d06
000a09 700b
000a0a 300a
000a0b f009
000a0c 940c 0884                 	CHECK_MENU_MUSIC			; check if we are in the correct submenu
000a0e 2d06                      	mov		w, m				; save the m register in w 
000a0f 7c00                      	andi	w, 0b11000000		; save the two largest bits of m and clear the other
000a10 5c00                      	subi	w, -(0b01000000)	; change the first two  bits of register m by adding 1: 00-01-10-11-00-...
000a11 e31f                      	ldi		_w, 0b00111111		; load bits 0 to 5 in _w
000a12 2261                      	and		m, _w				; save bits 0 to 5 from m and clear the other 
000a13 0e60                      	add		m, w				; add m and w
000a14 940c 0aae                 	jmp		save_m_eeprom
                                 
                                 temp_buttons:
000a16 3968                      	cpi		b0, 0x98
000a17 f031                      	breq	switch_button		; double arrow
000a18 3960                      	cpi		b0, 0x90
000a19 f121                      	breq	plus_button			; +
000a1a 3a68                      	cpi		b0, 0xa8
000a1b f159                      	breq	minus_button		; -
                                 
000a1c 940c 0a7a                 	jmp		num_pad_buttons
                                 
                                 switch_button:					; choose btw Celcius and Fahrenheit
000a1e 2d06                      	mov		w, m				; load m in w
000a1f 700b                      	andi	w, 0b00001011		; use a mask to keep only the bits 0,1,3
000a20 3009                      	cpi		w, 0b00001001		; see if we are in the the correct sub menu
000a21 f009                      	breq	PC+2			
000a22 940c 0884                 	jmp		affichage			; we are in the wrong sub menu
000a24 e004                      	ldi		w, 0b00000100		; correct sub menu, load the 2nd bit in w
000a25 2660                      	eor		m, w				; modify the 2nd bit of m
                                 
000a26 9120 0200                 	lds		a0, th_addr			; load the temperature
                                 
000a28 fc62                      	sbrc	m, 2				; check if we are now in F or C
000a29 c009                      	rjmp	change_to_fahr
                                 
                                 change_to_cels:
                                 	; change the temp unit from Fahrenheit to Celsius
000a2a dcf3                      	rcall	fahr_to_c
000a2b 9320 0200                 	sts		th_addr, a0
000a2d 9120 0201                 	lds		a0, tl_addr
000a2f dcee                      	rcall	fahr_to_c
000a30 9320 0201                 	sts		tl_addr, a0
000a32 c008                      	rjmp	end_of_switch
                                 
                                 change_to_fahr:
                                 	; change the temp unit from Celsius to Fahrenheit
000a33 dcd8                      	rcall	cel_to_f
000a34 9320 0200                 	sts		th_addr, a0
000a36 9120 0201                 	lds		a0, tl_addr
000a38 dcd3                      	rcall	cel_to_f
000a39 9320 0201                 	sts		tl_addr, a0
                                 
                                 end_of_switch:
                                 	; after the change is done, save the temperatures in the EEPROM
000a3b dc98                      	rcall	save_t_eeprom
000a3c 940c 0aae                 	jmp		save_m_eeprom
                                 
                                 plus_button:					; button used to increase the temp value
000a3e 2d06
000a3f 700b
000a40 3008
000a41 f009
000a42 940c 0884                 	CHECK_MENU_LIMIT
000a44 9100 0202                 	lds		w, unit_addr		; unit_addr contains a value between 1-10, changed using num pad
000a46 c00b                      	rjmp	change_temp
                                 
                                 minus_button:					; button used to lower the temp value
000a47 2d06
000a48 700b
000a49 3008
000a4a f009
000a4b 940c 0884                 	CHECK_MENU_LIMIT
000a4d 9100 0202                 	lds		w, unit_addr
000a4f 9500                      	com		w					; start reversing bits
000a50 5f0f                      	subi	w, (-1)				; add 1 so that all bits are inverted
000a51 c000                      	rjmp	change_temp
                                 
                                 change_temp:					; effectively add the value of the unit_addr to the chosen limit
000a52 9120 0200                 	lds		a0, th_addr
000a54 9130 0201                 	lds		a1, tl_addr
                                 	
000a56 fc64                      	sbrc	m, 4				; check if the user is pointing at th or tl
000a57 c00e                      	rjmp	change_tl
                                 
                                 change_th:						; TH was changed
000a58 0f20                      	add		a0, w
                                 
                                 	; TH needs to be lower than 50C or 125F
000a59 f40b                      	brvc	PC+2
000a5a e72d                      	ldi		a0, 125
                                 	
000a5b e302                      	ldi		w, 50
000a5c fc62                      	sbrc	m, 2
000a5d e70d                      	ldi		w, 125
                                 
000a5e 1720                      	cp		a0, w
                                 	
000a5f f00c                      	brlt	PC+2
000a60 2f20                      	mov		a0, w
                                 
                                 	; check if TH gets smaller than TL
000a61 1732                      	cp		a1, a0
000a62 f084                      	brlt	save_t
                                 
000a63 2f23                      	mov		a0, a1
000a64 5f2f                      	subi	a0, -1
000a65 c00d                      	rjmp	save_t
                                 
                                 change_tl:						; TL was changed
000a66 0f30                      	add		a1, w
                                 
                                 	; check if TL gets smaller than -30C or -20F
000a67 f40b                      	brvc	PC+2
000a68 e73d                      	ldi		a1, 125
                                 
000a69 ee02                      	ldi		w, -30
000a6a fc62                      	sbrc	m, 2
000a6b ee07                      	ldi		w, -25
                                 
000a6c 1730                      	cp		a1, w
                                 	
000a6d f40c                      	brge	PC+2
000a6e 2f30                      	mov		a1, w
                                 
                                 	; check if TL gets bigger than TH
000a6f 1732                      	cp		a1, a0
000a70 f014                      	brlt	save_t
                                 
000a71 2f32                      	mov		a1, a0
000a72 5031                      	subi	a1, 1
                                 
                                 save_t:							; The temperature is saved in the SRAM and the EEPROM
000a73 9320 0200                 	sts		th_addr, a0
000a75 9330 0201                 	sts		tl_addr, a1
                                 
000a77 dc5c                      	rcall	save_t_eeprom
000a78 940c 0884                 	jmp		affichage
                                 
                                 
                                 num_pad_buttons:				; connection from button code to their function
000a7a 2d06
000a7b 700b
000a7c 3008
000a7d f009
000a7e 940c 0884                 	CHECK_MENU_LIMIT
000a80 3360                      	cpi		b0, 0x30
000a81 f0a1                      	breq	button_one		;1
000a82 3168                      	cpi		b0, 0x18
000a83 f0a1                      	breq	button_two		;2
000a84 376a                      	cpi		b0, 0x7a
000a85 f0a1                      	breq	button_three	;3
000a86 3160                      	cpi		b0, 0x10
000a87 f0a1                      	breq	button_four		;4
000a88 3368                      	cpi		b0, 0x38
000a89 f0a1                      	breq	button_five		;5
000a8a 356a                      	cpi		b0, 0x5a
000a8b f0a1                      	breq	button_six		;6
000a8c 3462                      	cpi		b0, 0x42
000a8d f0a1                      	breq	button_seven	;7
000a8e 346a                      	cpi		b0, 0x4a
000a8f f0a1                      	breq	button_eight	;8
000a90 3562                      	cpi		b0, 0x52
000a91 f0a1                      	breq	button_nine		;9
000a92 3668                      	cpi		b0, 0x68
000a93 f0a1                      	breq	button_zero		;0
                                 
000a94 940c 0884                 	jmp		affichage
                                 
                                 button_one:						; button used to change to 1 the unit to add/remove at the temp lim
000a96 e001                      	ldi		w,1
000a97 c012                      	rjmp	change_unit
                                 
                                 button_two:						; button used to change to 2 the unit to add/remove at the temp lim
000a98 e002                      	ldi		w,2
000a99 c010                      	rjmp	change_unit
                                 
                                 button_three:					; button used to change to 3 the unit to add/remove at the temp lim
000a9a e003                      	ldi		w,3
000a9b c00e                      	rjmp	change_unit
                                 	
                                 button_four:					; button used to change to 4 the unit to add/remove at the temp lim
000a9c e004                      	ldi		w,4
000a9d c00c                      	rjmp	change_unit
                                 
                                 button_five:					; button used to change to 5 the unit to add/remove at the temp lim
000a9e e005                      	ldi		w,5
000a9f c00a                      	rjmp	change_unit
                                 
                                 button_six:						; button used to change to 6 the unit to add/remove at the temp lim
000aa0 e006                      	ldi		w,6
000aa1 c008                      	rjmp	change_unit
                                 
                                 button_seven:					; button used to change to 7 the unit to add/remove at the temp lim
000aa2 e007                      	ldi		w,7
000aa3 c006                      	rjmp	change_unit
                                 
                                 button_eight:					; button used to change to 8 the unit to add/remove at the temp lim
000aa4 e008                      	ldi		w,8
000aa5 c004                      	rjmp	change_unit
                                 
                                 button_nine:					; button used to change to 9 the unit to add/remove at the temp lim
000aa6 e009                      	ldi		w,9
000aa7 c002                      	rjmp	change_unit
                                 
                                 button_zero:					; button used to change to 10 the unit to add/remove at the temp lim
000aa8 e00a                      	ldi		w,10
000aa9 c000                      	rjmp	change_unit
                                 
                                 change_unit:					; change the value of the unit in the address
000aaa 9300 0202                 	sts		unit_addr, w
000aac 940c 0884                 	jmp		affichage
                                 
                                 save_m_eeprom:					; save the menu register in the EEPROM
000aae e0b0                      	ldi		xh, high(m_eep_addr)
000aaf e0a0                      	ldi		xl, low(m_eep_addr)
000ab0 2d26                      	mov		a0,m
000ab1 ddbd                      	rcall	eeprom_store
000ab2 940c 0884                 
                                 ; ==== Code ==== 
                                 
                                 ext_int7:
000ab4 930f                      	push	w
000ab5 b61f                      	in		_sreg, SREG
000ab6 e000                      	ldi		w, 0
000ab7 9300 0204                 	sts		alarm_addr,w
000ab9 be1f                      	out		SREG,_sreg
000aba 910f                      	pop		w
000abb 9518                      	reti
                                 
                                 ovf0:
                                 	; this counter is used to slow down the timer to 40s instead of 8s						
000abc 930f                      	push	w
000abd 9100 0203                 	lds		w, counter_addr
000abf 5001                      	subi	w, 1
000ac0 9300 0203                 	sts		counter_addr, w
000ac2 3000                      	cpi		w,0
000ac3 f011                      	breq	PC+3
000ac4 910f                      	pop		w
000ac5 9518                      	reti
                                 
000ac6 e005                      	ldi		w,5
000ac7 9300 0203                 	sts		counter_addr, w
                                 
                                 	; push and pop and call the routine to read the temp 
000ac9 931f                      	push	_w
000aca 932f                      	push	a0
000acb 933f                      	push	a1
000acc 936f                      	push	b0
000acd 937f                      	push	b1
000ace 938f                      	push	b2
000acf 928f                      	push	c0
000ad0 929f                      	push	c1
000ad1 92cf                      	push	d0
000ad2 92df                      	push	d1
000ad3 93bf                      	push	xh
000ad4 93af                      	push	xl
000ad5 b61f                      	in		_sreg,SREG
000ad6 db98                      	rcall	update_temp
000ad7 be1f                      	out		SREG,_sreg
000ad8 91af                      	pop		xl
000ad9 91bf                      	pop		xh
000ada 90df                      	pop		d1
000adb 90cf                      	pop		d0
000adc 909f                      	pop		c1
000add 908f                      	pop		c0
000ade 918f                      	pop		b2
000adf 917f                      	pop		b1
000ae0 916f                      	pop		b0
000ae1 913f                      	pop		a1
000ae2 912f                      	pop		a0
000ae3 911f                      	pop		_w
000ae4 910f                      	pop		w
000ae5 9518                      	reti
                                 
                                 reset:	
000ae6 ef0f
000ae7 bf0d
000ae8 e100
000ae9 bf0e                      	LDSP	RAMEND			; load stack pointer (SP)
                                 	
                                 	; get the menu register from the eeprom at reset
000aea e0b0                      	ldi		xh,	high(m_eep_addr)
000aeb e0a0                      	ldi		xl, low(m_eep_addr)
000aec dd90                      	rcall	eeprom_load
000aed 2e62                      	mov		m,a0
                                 
                                 	; set up values in the SRAM
000aee e001                      	ldi		w,1
000aef 9300 0202                 	sts		unit_addr,w
000af1 e005                      	ldi		w,5
000af2 9300 0203                 	sts		counter_addr,w
000af4 e000                      	ldi		w,0
000af5 9300 0204                 	sts		alarm_addr,w
000af7 e000                      	ldi		w,0
000af8 9300 0205                 	sts		on_off_addr,w
                                 
                                 	; set up interrupt
000afa e800
000afb bf09                      	OUTI	EIMSK, 0b10000000
000afc e800
000afd bf0a                      	OUTI	EICRB, 0b10000000
                                 
                                 	; call the reset 
000afe dcfe                      	rcall	remote_reset
000aff db67                      	rcall	temp_reset	
000b00 d9df                      	rcall	LCD_init		; initialize LCD
000b01 de92                      	rcall	store_custom_char
                                 
                                 	; set up timer
000b02 e008
000b03 bf00                      	OUTI	ASSR, (1<<AS0)	; clock from TOSC1 (external)
000b04 e007
000b05 bf03                      	OUTI	TCCR0,7			; CS0=7 CK/1024
000b06 e001
000b07 bf07                      	OUTI	TIMSK, 1<<TOIE0 ; set up the timer as overflow
000b08 9478                      	sei		
                                 
000b09 db65                      	rcall	update_temp
                                 
000b0a cd79                      	rjmp	affichage		; turn on the screen
                                 
                                 main:
                                 
000b0b 9100 0204                 	lds		w, alarm_addr	; load the value indicating if the alarm needs to ring (in the 5th bit)
000b0d 2106                      	and		w, m			; the 5th bit of m indicates if the alarm is activated by user
000b0e fd05                      	sbrc	w, 5			; if one of the two is 0, no need to play alarm	
000b0f dcc4                      	rcall	play			; otherwise, play
                                 
000b10 990f                      	sbic	PINIR,IR		; if the remote is sending a code, it needs to be read
000b11 cff9                      	rjmp	main			; otherwise, wait in main
                                 
000b12 94f8                      	cli						; The NEC signals have to be read without interrupt
000b13 dcef                      	rcall	read_remote		; wait for the user to press a button
000b14 9478                      	sei						; the interrupt is disabled in read_remote we reactivate it here
                                 
000b15 3060                      	cpi		b0,0			; if its 0, then it's a repeat or an error
000b16 f3a1                      	breq	main
                                 
000b17 cea0                      	rjmp	menu_bouton
                                 


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega128" register use summary:
x  :   6 y  :   0 z  :   0 r0 : 102 r1 :   4 r2 :   0 r3 :  33 r4 :  15 
r5 :  15 r6 :  39 r7 :   0 r8 : 115 r9 : 152 r10: 142 r11: 145 r12: 192 
r13: 140 r14:  46 r15:  48 r16: 346 r17:  25 r18: 245 r19: 182 r20: 100 
r21:  49 r22: 167 r23: 111 r24:  36 r25:  25 r26:  14 r27:  14 r28:   0 
r29:   0 r30:  19 r31:  12 
Registers used: 29 out of 35 (82.9%)

"ATmega128" instruction use summary:
.lds  :   0 .sts  :   0 adc   : 323 add   : 147 adiw  :   7 and   :   4 
andi  :  19 asr   :   2 bclr  :   0 bld   :   7 brbc  :   0 brbs  :   0 
brcc  :  29 brcs  :   0 break :   0 breq  :  62 brge  :   1 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   1 brlo  :   1 brlt  :   3 brmi  :   1 
brne  :  45 brpl  :   3 brsh  :   1 brtc  :   7 brts  :   0 brvc  :   2 
brvs  :   0 bset  :   0 bst   :  13 call  :   0 cbi   :   9 cbr   :   0 
clc   :   5 clh   :   0 cli   :   2 cln   :   0 clr   :  48 cls   :   0 
clt   :   1 clv   :   0 clz   :   0 com   :  20 cp    :  13 cpc   :   3 
cpi   :  56 cpse  :   2 dec   :  39 elpm  :   0 eor   :   7 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   1 ijmp  :   1 in    :   8 inc   :   2 
jmp   :  38 ld    :   6 ldd   :   0 ldi   : 207 lds   :  28 lpm   :  18 
lsl   :   1 lsr   :   8 mov   : 105 movw  :   0 mul   :   0 muls  :   0 
mulsu :   0 neg   :   0 nop   :   8 or    :   0 ori   :   2 out   :  16 
pop   :  43 push  :  41 rcall : 121 ret   :  53 reti  :   3 rjmp  : 197 
rol   :  97 ror   : 278 sbc   :  33 sbci  :   1 sbi   :  12 sbic  :   5 
sbis  :   3 sbiw  :   0 sbr   :   1 sbrc  :  40 sbrs  : 112 sec   :   2 
seh   :   0 sei   :   3 sen   :   0 ser   :   0 ses   :   0 set   :   1 
sev   :   0 sez   :   0 sleep :   0 spm   :   0 st    :   0 std   :   0 
sts   :  27 sub   :  49 subi  :  19 swap  :   4 tst   :   9 wdr   :   0 

Instructions used: 71 out of 114 (62.3%)

"ATmega128" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x001630   5134    490   5624  131072   4.3%
[.dseg] 0x000100 0x000100      0      0      0    4096   0.0%
[.eseg] 0x000000 0x000000      0      0      0    4096   0.0%

Assembly complete, 0 errors, 12 warnings
